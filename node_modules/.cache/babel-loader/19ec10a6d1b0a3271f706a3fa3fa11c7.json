{"ast":null,"code":"/*! For license information please see web3.min.js.LICENSE.txt */\n!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define([], t) : \"object\" == typeof exports ? exports.Web3 = t() : e.Web3 = t();\n}(this, () => (() => {\n  var e = {\n      7256: (e, t) => {\n        \"use strict\";\n\n        function r(e) {\n          if (Array.isArray(e)) {\n            const t = [];\n            let n = 0;\n            for (let o = 0; o < e.length; o++) {\n              const i = r(e[o]);\n              t.push(i), n += i.length;\n            }\n            return h(i(n, 192), ...t);\n          }\n          const t = g(e);\n          return 1 === t.length && t[0] < 128 ? t : h(i(t.length, 128), t);\n        }\n        function n(e, t, r) {\n          if (r > e.length) throw new Error(\"invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds\");\n          return e.slice(t, r);\n        }\n        function o(e) {\n          if (0 === e[0]) throw new Error(\"invalid RLP: extra zeros\");\n          return d(u(e));\n        }\n        function i(e, t) {\n          if (e < 56) return Uint8Array.from([e + t]);\n          const r = p(e),\n            n = p(t + 55 + r.length / 2);\n          return Uint8Array.from(l(n + r));\n        }\n        function s(e, t = !1) {\n          if (null == e || 0 === e.length) return Uint8Array.from([]);\n          const r = a(g(e));\n          if (t) return r;\n          if (0 !== r.remainder.length) throw new Error(\"invalid RLP: remainder must be zero\");\n          return r.data;\n        }\n        function a(e) {\n          let t, r, i, s, c;\n          const u = [],\n            d = e[0];\n          if (d <= 127) return {\n            data: e.slice(0, 1),\n            remainder: e.slice(1)\n          };\n          if (d <= 183) {\n            if (t = d - 127, i = 128 === d ? Uint8Array.from([]) : n(e, 1, t), 2 === t && i[0] < 128) throw new Error(\"invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed\");\n            return {\n              data: i,\n              remainder: e.slice(t)\n            };\n          }\n          if (d <= 191) {\n            if (r = d - 182, e.length - 1 < r) throw new Error(\"invalid RLP: not enough bytes for string length\");\n            if (t = o(n(e, 1, r)), t <= 55) throw new Error(\"invalid RLP: expected string length to be greater than 55\");\n            return i = n(e, r, t + r), {\n              data: i,\n              remainder: e.slice(t + r)\n            };\n          }\n          if (d <= 247) {\n            for (t = d - 191, s = n(e, 1, t); s.length;) c = a(s), u.push(c.data), s = c.remainder;\n            return {\n              data: u,\n              remainder: e.slice(t)\n            };\n          }\n          {\n            if (r = d - 246, t = o(n(e, 1, r)), t < 56) throw new Error(\"invalid RLP: encoded list too short\");\n            const i = r + t;\n            if (i > e.length) throw new Error(\"invalid RLP: total length is larger than the data\");\n            for (s = n(e, r, i); s.length;) c = a(s), u.push(c.data), s = c.remainder;\n            return {\n              data: u,\n              remainder: e.slice(i)\n            };\n          }\n        }\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.RLP = t.utils = t.decode = t.encode = void 0, t.encode = r, t.decode = s;\n        const c = Array.from({\n          length: 256\n        }, (e, t) => t.toString(16).padStart(2, \"0\"));\n        function u(e) {\n          let t = \"\";\n          for (let r = 0; r < e.length; r++) t += c[e[r]];\n          return t;\n        }\n        function d(e) {\n          const t = Number.parseInt(e, 16);\n          if (Number.isNaN(t)) throw new Error(\"Invalid byte sequence\");\n          return t;\n        }\n        function l(e) {\n          if (\"string\" != typeof e) throw new TypeError(\"hexToBytes: expected string, got \" + typeof e);\n          if (e.length % 2) throw new Error(\"hexToBytes: received invalid unpadded hex\");\n          const t = new Uint8Array(e.length / 2);\n          for (let r = 0; r < t.length; r++) {\n            const n = 2 * r;\n            t[r] = d(e.slice(n, n + 2));\n          }\n          return t;\n        }\n        function h(...e) {\n          if (1 === e.length) return e[0];\n          const t = e.reduce((e, t) => e + t.length, 0),\n            r = new Uint8Array(t);\n          for (let t = 0, n = 0; t < e.length; t++) {\n            const o = e[t];\n            r.set(o, n), n += o.length;\n          }\n          return r;\n        }\n        function f(e) {\n          return new TextEncoder().encode(e);\n        }\n        function p(e) {\n          if (e < 0) throw new Error(\"Invalid integer as argument, must be unsigned!\");\n          const t = e.toString(16);\n          return t.length % 2 ? `0${t}` : t;\n        }\n        function m(e) {\n          return e.length >= 2 && \"0\" === e[0] && \"x\" === e[1];\n        }\n        function g(e) {\n          if (e instanceof Uint8Array) return e;\n          if (\"string\" == typeof e) return m(e) ? l((t = \"string\" != typeof (r = e) ? r : m(r) ? r.slice(2) : r).length % 2 ? `0${t}` : t) : f(e);\n          var t, r;\n          if (\"number\" == typeof e || \"bigint\" == typeof e) return e ? l(p(e)) : Uint8Array.from([]);\n          if (null == e) return Uint8Array.from([]);\n          throw new Error(\"toBytes: received unsupported type \" + typeof e);\n        }\n        t.utils = {\n          bytesToHex: u,\n          concatBytes: h,\n          hexToBytes: l,\n          utf8ToBytes: f\n        }, t.RLP = {\n          encode: r,\n          decode: s\n        };\n      },\n      5887: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.createCurve = t.getHash = void 0;\n        const n = r(7493),\n          o = r(488),\n          i = r(7851);\n        function s(e) {\n          return {\n            hash: e,\n            hmac: (t, ...r) => (0, n.hmac)(e, t, (0, o.concatBytes)(...r)),\n            randomBytes: o.randomBytes\n          };\n        }\n        t.getHash = s, t.createCurve = function (e, t) {\n          const r = t => (0, i.weierstrass)({\n            ...e,\n            ...s(t)\n          });\n          return Object.freeze({\n            ...r(t),\n            create: r\n          });\n        };\n      },\n      1465: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.validateBasic = t.wNAF = void 0;\n        const n = r(9530),\n          o = r(4323),\n          i = BigInt(0),\n          s = BigInt(1);\n        t.wNAF = function (e, t) {\n          const r = (e, t) => {\n              const r = t.negate();\n              return e ? r : t;\n            },\n            n = e => ({\n              windows: Math.ceil(t / e) + 1,\n              windowSize: 2 ** (e - 1)\n            });\n          return {\n            constTimeNegate: r,\n            unsafeLadder(t, r) {\n              let n = e.ZERO,\n                o = t;\n              for (; r > i;) r & s && (n = n.add(o)), o = o.double(), r >>= s;\n              return n;\n            },\n            precomputeWindow(e, t) {\n              const {\n                  windows: r,\n                  windowSize: o\n                } = n(t),\n                i = [];\n              let s = e,\n                a = s;\n              for (let e = 0; e < r; e++) {\n                a = s, i.push(a);\n                for (let e = 1; e < o; e++) a = a.add(s), i.push(a);\n                s = a.double();\n              }\n              return i;\n            },\n            wNAF(t, o, i) {\n              const {\n                windows: a,\n                windowSize: c\n              } = n(t);\n              let u = e.ZERO,\n                d = e.BASE;\n              const l = BigInt(2 ** t - 1),\n                h = 2 ** t,\n                f = BigInt(t);\n              for (let e = 0; e < a; e++) {\n                const t = e * c;\n                let n = Number(i & l);\n                i >>= f, n > c && (n -= h, i += s);\n                const a = t,\n                  p = t + Math.abs(n) - 1,\n                  m = e % 2 != 0,\n                  g = n < 0;\n                0 === n ? d = d.add(r(m, o[a])) : u = u.add(r(g, o[p]));\n              }\n              return {\n                p: u,\n                f: d\n              };\n            },\n            wNAFCached(e, t, r, n) {\n              const o = e._WINDOW_SIZE || 1;\n              let i = t.get(e);\n              return i || (i = this.precomputeWindow(e, o), 1 !== o && t.set(e, n(i))), this.wNAF(o, i, r);\n            }\n          };\n        }, t.validateBasic = function (e) {\n          return (0, n.validateField)(e.Fp), (0, o.validateObject)(e, {\n            n: \"bigint\",\n            h: \"bigint\",\n            Gx: \"field\",\n            Gy: \"field\"\n          }, {\n            nBitLength: \"isSafeInteger\",\n            nByteLength: \"isSafeInteger\"\n          }), Object.freeze({\n            ...(0, n.nLength)(e.n, e.nBitLength),\n            ...e,\n            p: e.Fp.ORDER\n          });\n        };\n      },\n      1322: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.createHasher = t.isogenyMap = t.hash_to_field = t.expand_message_xof = t.expand_message_xmd = void 0;\n        const n = r(9530),\n          o = r(4323),\n          i = o.bytesToNumberBE;\n        function s(e, t) {\n          if (e < 0 || e >= 1 << 8 * t) throw new Error(`bad I2OSP call: value=${e} length=${t}`);\n          const r = Array.from({\n            length: t\n          }).fill(0);\n          for (let n = t - 1; n >= 0; n--) r[n] = 255 & e, e >>>= 8;\n          return new Uint8Array(r);\n        }\n        function a(e, t) {\n          const r = new Uint8Array(e.length);\n          for (let n = 0; n < e.length; n++) r[n] = e[n] ^ t[n];\n          return r;\n        }\n        function c(e) {\n          if (!(e instanceof Uint8Array)) throw new Error(\"Uint8Array expected\");\n        }\n        function u(e) {\n          if (!Number.isSafeInteger(e)) throw new Error(\"number expected\");\n        }\n        function d(e, t, r, n) {\n          c(e), c(t), u(r), t.length > 255 && (t = n((0, o.concatBytes)((0, o.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), t)));\n          const {\n              outputLen: i,\n              blockLen: d\n            } = n,\n            l = Math.ceil(r / i);\n          if (l > 255) throw new Error(\"Invalid xmd length\");\n          const h = (0, o.concatBytes)(t, s(t.length, 1)),\n            f = s(0, d),\n            p = s(r, 2),\n            m = new Array(l),\n            g = n((0, o.concatBytes)(f, e, p, s(0, 1), h));\n          m[0] = n((0, o.concatBytes)(g, s(1, 1), h));\n          for (let e = 1; e <= l; e++) {\n            const t = [a(g, m[e - 1]), s(e + 1, 1), h];\n            m[e] = n((0, o.concatBytes)(...t));\n          }\n          return (0, o.concatBytes)(...m).slice(0, r);\n        }\n        function l(e, t, r, n, i) {\n          if (c(e), c(t), u(r), t.length > 255) {\n            const e = Math.ceil(2 * n / 8);\n            t = i.create({\n              dkLen: e\n            }).update((0, o.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(t).digest();\n          }\n          if (r > 65535 || t.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n          return i.create({\n            dkLen: r\n          }).update(e).update(s(r, 2)).update(t).update(s(t.length, 1)).digest();\n        }\n        function h(e, t, r) {\n          (0, o.validateObject)(r, {\n            DST: \"string\",\n            p: \"bigint\",\n            m: \"isSafeInteger\",\n            k: \"isSafeInteger\",\n            hash: \"hash\"\n          });\n          const {\n            p: s,\n            k: a,\n            m: h,\n            hash: f,\n            expand: p,\n            DST: m\n          } = r;\n          c(e), u(t);\n          const g = function (e) {\n              if (e instanceof Uint8Array) return e;\n              if (\"string\" == typeof e) return (0, o.utf8ToBytes)(e);\n              throw new Error(\"DST must be Uint8Array or string\");\n            }(m),\n            y = s.toString(2).length,\n            v = Math.ceil((y + a) / 8),\n            b = t * h * v;\n          let E;\n          if (\"xmd\" === p) E = d(e, g, b, f);else if (\"xof\" === p) E = l(e, g, b, a, f);else {\n            if (\"_internal_pass\" !== p) throw new Error('expand must be \"xmd\" or \"xof\"');\n            E = e;\n          }\n          const _ = new Array(t);\n          for (let e = 0; e < t; e++) {\n            const t = new Array(h);\n            for (let r = 0; r < h; r++) {\n              const o = v * (r + e * h),\n                a = E.subarray(o, o + v);\n              t[r] = (0, n.mod)(i(a), s);\n            }\n            _[e] = t;\n          }\n          return _;\n        }\n        t.expand_message_xmd = d, t.expand_message_xof = l, t.hash_to_field = h, t.isogenyMap = function (e, t) {\n          const r = t.map(e => Array.from(e).reverse());\n          return (t, n) => {\n            const [o, i, s, a] = r.map(r => r.reduce((r, n) => e.add(e.mul(r, t), n)));\n            return t = e.div(o, i), n = e.mul(n, e.div(s, a)), {\n              x: t,\n              y: n\n            };\n          };\n        }, t.createHasher = function (e, t, r) {\n          if (\"function\" != typeof t) throw new Error(\"mapToCurve() must be defined\");\n          return {\n            hashToCurve(n, o) {\n              const i = h(n, 2, {\n                  ...r,\n                  DST: r.DST,\n                  ...o\n                }),\n                s = e.fromAffine(t(i[0])),\n                a = e.fromAffine(t(i[1])),\n                c = s.add(a).clearCofactor();\n              return c.assertValidity(), c;\n            },\n            encodeToCurve(n, o) {\n              const i = h(n, 1, {\n                  ...r,\n                  DST: r.encodeDST,\n                  ...o\n                }),\n                s = e.fromAffine(t(i[0])).clearCofactor();\n              return s.assertValidity(), s;\n            }\n          };\n        };\n      },\n      9530: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.hashToPrivateScalar = t.FpSqrtEven = t.FpSqrtOdd = t.Field = t.nLength = t.FpIsSquare = t.FpDiv = t.FpInvertBatch = t.FpPow = t.validateField = t.isNegativeLE = t.FpSqrt = t.tonelliShanks = t.invert = t.pow2 = t.pow = t.mod = void 0;\n        const n = r(4323),\n          o = BigInt(0),\n          i = BigInt(1),\n          s = BigInt(2),\n          a = BigInt(3),\n          c = BigInt(4),\n          u = BigInt(5),\n          d = BigInt(8);\n        function l(e, t) {\n          const r = e % t;\n          return r >= o ? r : t + r;\n        }\n        function h(e, t, r) {\n          if (r <= o || t < o) throw new Error(\"Expected power/modulo > 0\");\n          if (r === i) return o;\n          let n = i;\n          for (; t > o;) t & i && (n = n * e % r), e = e * e % r, t >>= i;\n          return n;\n        }\n        function f(e, t) {\n          if (e === o || t <= o) throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);\n          let r = l(e, t),\n            n = t,\n            s = o,\n            a = i,\n            c = i,\n            u = o;\n          for (; r !== o;) {\n            const e = n / r,\n              t = n % r,\n              o = s - c * e,\n              i = a - u * e;\n            n = r, r = t, s = c, a = u, c = o, u = i;\n          }\n          if (n !== i) throw new Error(\"invert: does not exist\");\n          return l(s, t);\n        }\n        function p(e) {\n          const t = (e - i) / s;\n          let r, n, a;\n          for (r = e - i, n = 0; r % s === o; r /= s, n++);\n          for (a = s; a < e && h(a, t, e) !== e - i; a++);\n          if (1 === n) {\n            const t = (e + i) / c;\n            return function (e, r) {\n              const n = e.pow(r, t);\n              if (!e.eql(e.sqr(n), r)) throw new Error(\"Cannot find square root\");\n              return n;\n            };\n          }\n          const u = (r + i) / s;\n          return function (e, o) {\n            if (e.pow(o, t) === e.neg(e.ONE)) throw new Error(\"Cannot find square root\");\n            let s = n,\n              c = e.pow(e.mul(e.ONE, a), r),\n              d = e.pow(o, u),\n              l = e.pow(o, r);\n            for (; !e.eql(l, e.ONE);) {\n              if (e.eql(l, e.ZERO)) return e.ZERO;\n              let t = 1;\n              for (let r = e.sqr(l); t < s && !e.eql(r, e.ONE); t++) r = e.sqr(r);\n              const r = e.pow(c, i << BigInt(s - t - 1));\n              c = e.sqr(r), d = e.mul(d, r), l = e.mul(l, c), s = t;\n            }\n            return d;\n          };\n        }\n        function m(e) {\n          if (e % c === a) {\n            const t = (e + i) / c;\n            return function (e, r) {\n              const n = e.pow(r, t);\n              if (!e.eql(e.sqr(n), r)) throw new Error(\"Cannot find square root\");\n              return n;\n            };\n          }\n          if (e % d === u) {\n            const t = (e - u) / d;\n            return function (e, r) {\n              const n = e.mul(r, s),\n                o = e.pow(n, t),\n                i = e.mul(r, o),\n                a = e.mul(e.mul(i, s), o),\n                c = e.mul(i, e.sub(a, e.ONE));\n              if (!e.eql(e.sqr(c), r)) throw new Error(\"Cannot find square root\");\n              return c;\n            };\n          }\n          return p(e);\n        }\n        BigInt(9), BigInt(16), t.mod = l, t.pow = h, t.pow2 = function (e, t, r) {\n          let n = e;\n          for (; t-- > o;) n *= n, n %= r;\n          return n;\n        }, t.invert = f, t.tonelliShanks = p, t.FpSqrt = m, t.isNegativeLE = (e, t) => (l(e, t) & i) === i;\n        const g = [\"create\", \"isValid\", \"is0\", \"neg\", \"inv\", \"sqrt\", \"sqr\", \"eql\", \"add\", \"sub\", \"mul\", \"pow\", \"div\", \"addN\", \"subN\", \"mulN\", \"sqrN\"];\n        function y(e, t, r) {\n          if (r < o) throw new Error(\"Expected power > 0\");\n          if (r === o) return e.ONE;\n          if (r === i) return t;\n          let n = e.ONE,\n            s = t;\n          for (; r > o;) r & i && (n = e.mul(n, s)), s = e.sqr(s), r >>= i;\n          return n;\n        }\n        function v(e, t) {\n          const r = new Array(t.length),\n            n = t.reduce((t, n, o) => e.is0(n) ? t : (r[o] = t, e.mul(t, n)), e.ONE),\n            o = e.inv(n);\n          return t.reduceRight((t, n, o) => e.is0(n) ? t : (r[o] = e.mul(t, r[o]), e.mul(t, n)), o), r;\n        }\n        function b(e, t) {\n          const r = void 0 !== t ? t : e.toString(2).length;\n          return {\n            nBitLength: r,\n            nByteLength: Math.ceil(r / 8)\n          };\n        }\n        t.validateField = function (e) {\n          const t = g.reduce((e, t) => (e[t] = \"function\", e), {\n            ORDER: \"bigint\",\n            MASK: \"bigint\",\n            BYTES: \"isSafeInteger\",\n            BITS: \"isSafeInteger\"\n          });\n          return (0, n.validateObject)(e, t);\n        }, t.FpPow = y, t.FpInvertBatch = v, t.FpDiv = function (e, t, r) {\n          return e.mul(t, \"bigint\" == typeof r ? f(r, e.ORDER) : e.inv(r));\n        }, t.FpIsSquare = function (e) {\n          const t = (e.ORDER - i) / s;\n          return r => {\n            const n = e.pow(r, t);\n            return e.eql(n, e.ZERO) || e.eql(n, e.ONE);\n          };\n        }, t.nLength = b, t.Field = function (e, t, r = !1, s = {}) {\n          if (e <= o) throw new Error(`Expected Fp ORDER > 0, got ${e}`);\n          const {\n            nBitLength: a,\n            nByteLength: c\n          } = b(e, t);\n          if (c > 2048) throw new Error(\"Field lengths over 2048 bytes are not supported\");\n          const u = m(e),\n            d = Object.freeze({\n              ORDER: e,\n              BITS: a,\n              BYTES: c,\n              MASK: (0, n.bitMask)(a),\n              ZERO: o,\n              ONE: i,\n              create: t => l(t, e),\n              isValid: t => {\n                if (\"bigint\" != typeof t) throw new Error(\"Invalid field element: expected bigint, got \" + typeof t);\n                return o <= t && t < e;\n              },\n              is0: e => e === o,\n              isOdd: e => (e & i) === i,\n              neg: t => l(-t, e),\n              eql: (e, t) => e === t,\n              sqr: t => l(t * t, e),\n              add: (t, r) => l(t + r, e),\n              sub: (t, r) => l(t - r, e),\n              mul: (t, r) => l(t * r, e),\n              pow: (e, t) => y(d, e, t),\n              div: (t, r) => l(t * f(r, e), e),\n              sqrN: e => e * e,\n              addN: (e, t) => e + t,\n              subN: (e, t) => e - t,\n              mulN: (e, t) => e * t,\n              inv: t => f(t, e),\n              sqrt: s.sqrt || (e => u(d, e)),\n              invertBatch: e => v(d, e),\n              cmov: (e, t, r) => r ? t : e,\n              toBytes: e => r ? (0, n.numberToBytesLE)(e, c) : (0, n.numberToBytesBE)(e, c),\n              fromBytes: e => {\n                if (e.length !== c) throw new Error(`Fp.fromBytes: expected ${c}, got ${e.length}`);\n                return r ? (0, n.bytesToNumberLE)(e) : (0, n.bytesToNumberBE)(e);\n              }\n            });\n          return Object.freeze(d);\n        }, t.FpSqrtOdd = function (e, t) {\n          if (!e.isOdd) throw new Error(\"Field doesn't have isOdd\");\n          const r = e.sqrt(t);\n          return e.isOdd(r) ? r : e.neg(r);\n        }, t.FpSqrtEven = function (e, t) {\n          if (!e.isOdd) throw new Error(\"Field doesn't have isOdd\");\n          const r = e.sqrt(t);\n          return e.isOdd(r) ? e.neg(r) : r;\n        }, t.hashToPrivateScalar = function (e, t, r = !1) {\n          const o = (e = (0, n.ensureBytes)(\"privateHash\", e)).length,\n            s = b(t).nByteLength + 8;\n          if (s < 24 || o < s || o > 1024) throw new Error(`hashToPrivateScalar: expected ${s}-1024 bytes of input, got ${o}`);\n          return l(r ? (0, n.bytesToNumberLE)(e) : (0, n.bytesToNumberBE)(e), t - i) + i;\n        };\n      },\n      4323: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.validateObject = t.createHmacDrbg = t.bitMask = t.bitSet = t.bitGet = t.bitLen = t.utf8ToBytes = t.equalBytes = t.concatBytes = t.ensureBytes = t.numberToVarBytesBE = t.numberToBytesLE = t.numberToBytesBE = t.bytesToNumberLE = t.bytesToNumberBE = t.hexToBytes = t.hexToNumber = t.numberToHexUnpadded = t.bytesToHex = void 0;\n        const r = BigInt(0),\n          n = BigInt(1),\n          o = BigInt(2),\n          i = e => e instanceof Uint8Array,\n          s = Array.from({\n            length: 256\n          }, (e, t) => t.toString(16).padStart(2, \"0\"));\n        function a(e) {\n          if (!i(e)) throw new Error(\"Uint8Array expected\");\n          let t = \"\";\n          for (let r = 0; r < e.length; r++) t += s[e[r]];\n          return t;\n        }\n        function c(e) {\n          const t = e.toString(16);\n          return 1 & t.length ? `0${t}` : t;\n        }\n        function u(e) {\n          if (\"string\" != typeof e) throw new Error(\"hex string expected, got \" + typeof e);\n          return BigInt(\"\" === e ? \"0\" : `0x${e}`);\n        }\n        function d(e) {\n          if (\"string\" != typeof e) throw new Error(\"hex string expected, got \" + typeof e);\n          if (e.length % 2) throw new Error(\"hex string is invalid: unpadded \" + e.length);\n          const t = new Uint8Array(e.length / 2);\n          for (let r = 0; r < t.length; r++) {\n            const n = 2 * r,\n              o = e.slice(n, n + 2),\n              i = Number.parseInt(o, 16);\n            if (Number.isNaN(i) || i < 0) throw new Error(\"invalid byte sequence\");\n            t[r] = i;\n          }\n          return t;\n        }\n        function l(...e) {\n          const t = new Uint8Array(e.reduce((e, t) => e + t.length, 0));\n          let r = 0;\n          return e.forEach(e => {\n            if (!i(e)) throw new Error(\"Uint8Array expected\");\n            t.set(e, r), r += e.length;\n          }), t;\n        }\n        t.bytesToHex = a, t.numberToHexUnpadded = c, t.hexToNumber = u, t.hexToBytes = d, t.bytesToNumberBE = function (e) {\n          return u(a(e));\n        }, t.bytesToNumberLE = function (e) {\n          if (!i(e)) throw new Error(\"Uint8Array expected\");\n          return u(a(Uint8Array.from(e).reverse()));\n        }, t.numberToBytesBE = (e, t) => d(e.toString(16).padStart(2 * t, \"0\")), t.numberToBytesLE = (e, r) => (0, t.numberToBytesBE)(e, r).reverse(), t.numberToVarBytesBE = e => d(c(e)), t.ensureBytes = function (e, t, r) {\n          let n;\n          if (\"string\" == typeof t) try {\n            n = d(t);\n          } catch (r) {\n            throw new Error(`${e} must be valid hex string, got \"${t}\". Cause: ${r}`);\n          } else {\n            if (!i(t)) throw new Error(`${e} must be hex string or Uint8Array`);\n            n = Uint8Array.from(t);\n          }\n          const o = n.length;\n          if (\"number\" == typeof r && o !== r) throw new Error(`${e} expected ${r} bytes, got ${o}`);\n          return n;\n        }, t.concatBytes = l, t.equalBytes = function (e, t) {\n          if (e.length !== t.length) return !1;\n          for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1;\n          return !0;\n        }, t.utf8ToBytes = function (e) {\n          if (\"string\" != typeof e) throw new Error(\"utf8ToBytes expected string, got \" + typeof e);\n          return new TextEncoder().encode(e);\n        }, t.bitLen = function (e) {\n          let t;\n          for (t = 0; e > r; e >>= n, t += 1);\n          return t;\n        }, t.bitGet = (e, t) => e >> BigInt(t) & n, t.bitSet = (e, t, o) => e | (o ? n : r) << BigInt(t), t.bitMask = e => (o << BigInt(e - 1)) - n;\n        const h = e => new Uint8Array(e),\n          f = e => Uint8Array.from(e);\n        t.createHmacDrbg = function (e, t, r) {\n          if (\"number\" != typeof e || e < 2) throw new Error(\"hashLen must be a number\");\n          if (\"number\" != typeof t || t < 2) throw new Error(\"qByteLen must be a number\");\n          if (\"function\" != typeof r) throw new Error(\"hmacFn must be a function\");\n          let n = h(e),\n            o = h(e),\n            i = 0;\n          const s = () => {\n              n.fill(1), o.fill(0), i = 0;\n            },\n            a = (...e) => r(o, n, ...e),\n            c = (e = h()) => {\n              o = a(f([0]), e), n = a(), 0 !== e.length && (o = a(f([1]), e), n = a());\n            },\n            u = () => {\n              if (i++ >= 1e3) throw new Error(\"drbg: tried 1000 values\");\n              let e = 0;\n              const r = [];\n              for (; e < t;) {\n                n = a();\n                const t = n.slice();\n                r.push(t), e += n.length;\n              }\n              return l(...r);\n            };\n          return (e, t) => {\n            let r;\n            for (s(), c(e); !(r = t(u()));) c();\n            return s(), r;\n          };\n        };\n        const p = {\n          bigint: e => \"bigint\" == typeof e,\n          function: e => \"function\" == typeof e,\n          boolean: e => \"boolean\" == typeof e,\n          string: e => \"string\" == typeof e,\n          isSafeInteger: e => Number.isSafeInteger(e),\n          array: e => Array.isArray(e),\n          field: (e, t) => t.Fp.isValid(e),\n          hash: e => \"function\" == typeof e && Number.isSafeInteger(e.outputLen)\n        };\n        t.validateObject = function (e, t, r = {}) {\n          const n = (t, r, n) => {\n            const o = p[r];\n            if (\"function\" != typeof o) throw new Error(`Invalid validator \"${r}\", expected function`);\n            const i = e[t];\n            if (!(n && void 0 === i || o(i, e))) throw new Error(`Invalid param ${String(t)}=${i} (${typeof i}), expected ${r}`);\n          };\n          for (const [e, r] of Object.entries(t)) n(e, r, !1);\n          for (const [e, t] of Object.entries(r)) n(e, t, !0);\n          return e;\n        };\n      },\n      7851: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.mapToCurveSimpleSWU = t.SWUFpSqrtRatio = t.weierstrass = t.weierstrassPoints = t.DER = void 0;\n        const n = r(9530),\n          o = r(4323),\n          i = r(4323),\n          s = r(1465),\n          {\n            bytesToNumberBE: a,\n            hexToBytes: c\n          } = o;\n        t.DER = {\n          Err: class extends Error {\n            constructor(e = \"\") {\n              super(e);\n            }\n          },\n          _parseInt(e) {\n            const {\n              Err: r\n            } = t.DER;\n            if (e.length < 2 || 2 !== e[0]) throw new r(\"Invalid signature integer tag\");\n            const n = e[1],\n              o = e.subarray(2, n + 2);\n            if (!n || o.length !== n) throw new r(\"Invalid signature integer: wrong length\");\n            if (128 & o[0]) throw new r(\"Invalid signature integer: negative\");\n            if (0 === o[0] && !(128 & o[1])) throw new r(\"Invalid signature integer: unnecessary leading zero\");\n            return {\n              d: a(o),\n              l: e.subarray(n + 2)\n            };\n          },\n          toSig(e) {\n            const {\n                Err: r\n              } = t.DER,\n              n = \"string\" == typeof e ? c(e) : e;\n            if (!(n instanceof Uint8Array)) throw new Error(\"ui8a expected\");\n            let o = n.length;\n            if (o < 2 || 48 != n[0]) throw new r(\"Invalid signature tag\");\n            if (n[1] !== o - 2) throw new r(\"Invalid signature: incorrect length\");\n            const {\n                d: i,\n                l: s\n              } = t.DER._parseInt(n.subarray(2)),\n              {\n                d: a,\n                l: u\n              } = t.DER._parseInt(s);\n            if (u.length) throw new r(\"Invalid signature: left bytes after parsing\");\n            return {\n              r: i,\n              s: a\n            };\n          },\n          hexFromSig(e) {\n            const t = e => 8 & Number.parseInt(e[0], 16) ? \"00\" + e : e,\n              r = e => {\n                const t = e.toString(16);\n                return 1 & t.length ? `0${t}` : t;\n              },\n              n = t(r(e.s)),\n              o = t(r(e.r)),\n              i = n.length / 2,\n              s = o.length / 2,\n              a = r(i),\n              c = r(s);\n            return `30${r(s + i + 4)}02${c}${o}02${a}${n}`;\n          }\n        };\n        const u = BigInt(0),\n          d = BigInt(1),\n          l = BigInt(2),\n          h = BigInt(3),\n          f = BigInt(4);\n        function p(e) {\n          const t = function (e) {\n              const t = (0, s.validateBasic)(e);\n              o.validateObject(t, {\n                a: \"field\",\n                b: \"field\"\n              }, {\n                allowedPrivateKeyLengths: \"array\",\n                wrapPrivateKey: \"boolean\",\n                isTorsionFree: \"function\",\n                clearCofactor: \"function\",\n                allowInfinityPoint: \"boolean\",\n                fromBytes: \"function\",\n                toBytes: \"function\"\n              });\n              const {\n                endo: r,\n                Fp: n,\n                a: i\n              } = t;\n              if (r) {\n                if (!n.eql(i, n.ZERO)) throw new Error(\"Endomorphism can only be defined for Koblitz curves that have a=0\");\n                if (\"object\" != typeof r || \"bigint\" != typeof r.beta || \"function\" != typeof r.splitScalar) throw new Error(\"Expected endomorphism with beta: bigint and splitScalar: function\");\n              }\n              return Object.freeze({\n                ...t\n              });\n            }(e),\n            {\n              Fp: r\n            } = t,\n            a = t.toBytes || ((e, t, n) => {\n              const i = t.toAffine();\n              return o.concatBytes(Uint8Array.from([4]), r.toBytes(i.x), r.toBytes(i.y));\n            }),\n            c = t.fromBytes || (e => {\n              const t = e.subarray(1);\n              return {\n                x: r.fromBytes(t.subarray(0, r.BYTES)),\n                y: r.fromBytes(t.subarray(r.BYTES, 2 * r.BYTES))\n              };\n            });\n          function l(e) {\n            const {\n                a: n,\n                b: o\n              } = t,\n              i = r.sqr(e),\n              s = r.mul(i, e);\n            return r.add(r.add(s, r.mul(e, n)), o);\n          }\n          if (!r.eql(r.sqr(t.Gy), l(t.Gx))) throw new Error(\"bad generator point: equation left != right\");\n          function f(e) {\n            return \"bigint\" == typeof e && u < e && e < t.n;\n          }\n          function p(e) {\n            if (!f(e)) throw new Error(\"Expected valid bigint: 0 < bigint < curve.n\");\n          }\n          function m(e) {\n            const {\n              allowedPrivateKeyLengths: r,\n              nByteLength: s,\n              wrapPrivateKey: a,\n              n: c\n            } = t;\n            if (r && \"bigint\" != typeof e) {\n              if (e instanceof Uint8Array && (e = o.bytesToHex(e)), \"string\" != typeof e || !r.includes(e.length)) throw new Error(\"Invalid key\");\n              e = e.padStart(2 * s, \"0\");\n            }\n            let u;\n            try {\n              u = \"bigint\" == typeof e ? e : o.bytesToNumberBE((0, i.ensureBytes)(\"private key\", e, s));\n            } catch (t) {\n              throw new Error(`private key must be ${s} bytes, hex or bigint, not ${typeof e}`);\n            }\n            return a && (u = n.mod(u, c)), p(u), u;\n          }\n          const g = new Map();\n          function y(e) {\n            if (!(e instanceof v)) throw new Error(\"ProjectivePoint expected\");\n          }\n          class v {\n            constructor(e, t, n) {\n              if (this.px = e, this.py = t, this.pz = n, null == e || !r.isValid(e)) throw new Error(\"x required\");\n              if (null == t || !r.isValid(t)) throw new Error(\"y required\");\n              if (null == n || !r.isValid(n)) throw new Error(\"z required\");\n            }\n            static fromAffine(e) {\n              const {\n                x: t,\n                y: n\n              } = e || {};\n              if (!e || !r.isValid(t) || !r.isValid(n)) throw new Error(\"invalid affine point\");\n              if (e instanceof v) throw new Error(\"projective point not allowed\");\n              const o = e => r.eql(e, r.ZERO);\n              return o(t) && o(n) ? v.ZERO : new v(t, n, r.ONE);\n            }\n            get x() {\n              return this.toAffine().x;\n            }\n            get y() {\n              return this.toAffine().y;\n            }\n            static normalizeZ(e) {\n              const t = r.invertBatch(e.map(e => e.pz));\n              return e.map((e, r) => e.toAffine(t[r])).map(v.fromAffine);\n            }\n            static fromHex(e) {\n              const t = v.fromAffine(c((0, i.ensureBytes)(\"pointHex\", e)));\n              return t.assertValidity(), t;\n            }\n            static fromPrivateKey(e) {\n              return v.BASE.multiply(m(e));\n            }\n            _setWindowSize(e) {\n              this._WINDOW_SIZE = e, g.delete(this);\n            }\n            assertValidity() {\n              if (this.is0()) {\n                if (t.allowInfinityPoint) return;\n                throw new Error(\"bad point: ZERO\");\n              }\n              const {\n                x: e,\n                y: n\n              } = this.toAffine();\n              if (!r.isValid(e) || !r.isValid(n)) throw new Error(\"bad point: x or y not FE\");\n              const o = r.sqr(n),\n                i = l(e);\n              if (!r.eql(o, i)) throw new Error(\"bad point: equation left != right\");\n              if (!this.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n            }\n            hasEvenY() {\n              const {\n                y: e\n              } = this.toAffine();\n              if (r.isOdd) return !r.isOdd(e);\n              throw new Error(\"Field doesn't support isOdd\");\n            }\n            equals(e) {\n              y(e);\n              const {\n                  px: t,\n                  py: n,\n                  pz: o\n                } = this,\n                {\n                  px: i,\n                  py: s,\n                  pz: a\n                } = e,\n                c = r.eql(r.mul(t, a), r.mul(i, o)),\n                u = r.eql(r.mul(n, a), r.mul(s, o));\n              return c && u;\n            }\n            negate() {\n              return new v(this.px, r.neg(this.py), this.pz);\n            }\n            double() {\n              const {\n                  a: e,\n                  b: n\n                } = t,\n                o = r.mul(n, h),\n                {\n                  px: i,\n                  py: s,\n                  pz: a\n                } = this;\n              let c = r.ZERO,\n                u = r.ZERO,\n                d = r.ZERO,\n                l = r.mul(i, i),\n                f = r.mul(s, s),\n                p = r.mul(a, a),\n                m = r.mul(i, s);\n              return m = r.add(m, m), d = r.mul(i, a), d = r.add(d, d), c = r.mul(e, d), u = r.mul(o, p), u = r.add(c, u), c = r.sub(f, u), u = r.add(f, u), u = r.mul(c, u), c = r.mul(m, c), d = r.mul(o, d), p = r.mul(e, p), m = r.sub(l, p), m = r.mul(e, m), m = r.add(m, d), d = r.add(l, l), l = r.add(d, l), l = r.add(l, p), l = r.mul(l, m), u = r.add(u, l), p = r.mul(s, a), p = r.add(p, p), l = r.mul(p, m), c = r.sub(c, l), d = r.mul(p, f), d = r.add(d, d), d = r.add(d, d), new v(c, u, d);\n            }\n            add(e) {\n              y(e);\n              const {\n                  px: n,\n                  py: o,\n                  pz: i\n                } = this,\n                {\n                  px: s,\n                  py: a,\n                  pz: c\n                } = e;\n              let u = r.ZERO,\n                d = r.ZERO,\n                l = r.ZERO;\n              const f = t.a,\n                p = r.mul(t.b, h);\n              let m = r.mul(n, s),\n                g = r.mul(o, a),\n                b = r.mul(i, c),\n                E = r.add(n, o),\n                _ = r.add(s, a);\n              E = r.mul(E, _), _ = r.add(m, g), E = r.sub(E, _), _ = r.add(n, i);\n              let A = r.add(s, c);\n              return _ = r.mul(_, A), A = r.add(m, b), _ = r.sub(_, A), A = r.add(o, i), u = r.add(a, c), A = r.mul(A, u), u = r.add(g, b), A = r.sub(A, u), l = r.mul(f, _), u = r.mul(p, b), l = r.add(u, l), u = r.sub(g, l), l = r.add(g, l), d = r.mul(u, l), g = r.add(m, m), g = r.add(g, m), b = r.mul(f, b), _ = r.mul(p, _), g = r.add(g, b), b = r.sub(m, b), b = r.mul(f, b), _ = r.add(_, b), m = r.mul(g, _), d = r.add(d, m), m = r.mul(A, _), u = r.mul(E, u), u = r.sub(u, m), m = r.mul(E, g), l = r.mul(A, l), l = r.add(l, m), new v(u, d, l);\n            }\n            subtract(e) {\n              return this.add(e.negate());\n            }\n            is0() {\n              return this.equals(v.ZERO);\n            }\n            wNAF(e) {\n              return E.wNAFCached(this, g, e, e => {\n                const t = r.invertBatch(e.map(e => e.pz));\n                return e.map((e, r) => e.toAffine(t[r])).map(v.fromAffine);\n              });\n            }\n            multiplyUnsafe(e) {\n              const n = v.ZERO;\n              if (e === u) return n;\n              if (p(e), e === d) return this;\n              const {\n                endo: o\n              } = t;\n              if (!o) return E.unsafeLadder(this, e);\n              let {\n                  k1neg: i,\n                  k1: s,\n                  k2neg: a,\n                  k2: c\n                } = o.splitScalar(e),\n                l = n,\n                h = n,\n                f = this;\n              for (; s > u || c > u;) s & d && (l = l.add(f)), c & d && (h = h.add(f)), f = f.double(), s >>= d, c >>= d;\n              return i && (l = l.negate()), a && (h = h.negate()), h = new v(r.mul(h.px, o.beta), h.py, h.pz), l.add(h);\n            }\n            multiply(e) {\n              p(e);\n              let n,\n                o,\n                i = e;\n              const {\n                endo: s\n              } = t;\n              if (s) {\n                const {\n                  k1neg: e,\n                  k1: t,\n                  k2neg: a,\n                  k2: c\n                } = s.splitScalar(i);\n                let {\n                    p: u,\n                    f: d\n                  } = this.wNAF(t),\n                  {\n                    p: l,\n                    f: h\n                  } = this.wNAF(c);\n                u = E.constTimeNegate(e, u), l = E.constTimeNegate(a, l), l = new v(r.mul(l.px, s.beta), l.py, l.pz), n = u.add(l), o = d.add(h);\n              } else {\n                const {\n                  p: e,\n                  f: t\n                } = this.wNAF(i);\n                n = e, o = t;\n              }\n              return v.normalizeZ([n, o])[0];\n            }\n            multiplyAndAddUnsafe(e, t, r) {\n              const n = v.BASE,\n                o = (e, t) => t !== u && t !== d && e.equals(n) ? e.multiply(t) : e.multiplyUnsafe(t),\n                i = o(this, t).add(o(e, r));\n              return i.is0() ? void 0 : i;\n            }\n            toAffine(e) {\n              const {\n                  px: t,\n                  py: n,\n                  pz: o\n                } = this,\n                i = this.is0();\n              null == e && (e = i ? r.ONE : r.inv(o));\n              const s = r.mul(t, e),\n                a = r.mul(n, e),\n                c = r.mul(o, e);\n              if (i) return {\n                x: r.ZERO,\n                y: r.ZERO\n              };\n              if (!r.eql(c, r.ONE)) throw new Error(\"invZ was invalid\");\n              return {\n                x: s,\n                y: a\n              };\n            }\n            isTorsionFree() {\n              const {\n                h: e,\n                isTorsionFree: r\n              } = t;\n              if (e === d) return !0;\n              if (r) return r(v, this);\n              throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n            }\n            clearCofactor() {\n              const {\n                h: e,\n                clearCofactor: r\n              } = t;\n              return e === d ? this : r ? r(v, this) : this.multiplyUnsafe(t.h);\n            }\n            toRawBytes(e = !0) {\n              return this.assertValidity(), a(v, this, e);\n            }\n            toHex(e = !0) {\n              return o.bytesToHex(this.toRawBytes(e));\n            }\n          }\n          v.BASE = new v(t.Gx, t.Gy, r.ONE), v.ZERO = new v(r.ZERO, r.ONE, r.ZERO);\n          const b = t.nBitLength,\n            E = (0, s.wNAF)(v, t.endo ? Math.ceil(b / 2) : b);\n          return {\n            CURVE: t,\n            ProjectivePoint: v,\n            normPrivateKeyToScalar: m,\n            weierstrassEquation: l,\n            isWithinCurveOrder: f\n          };\n        }\n        function m(e, t) {\n          const r = e.ORDER;\n          let n = u;\n          for (let e = r - d; e % l === u; e /= l) n += d;\n          const o = n,\n            i = (r - d) / l ** o,\n            s = (i - d) / l,\n            a = l ** o - d,\n            c = l ** (o - d),\n            p = e.pow(t, i),\n            m = e.pow(t, (i + d) / l);\n          let g = (t, r) => {\n            let n = p,\n              i = e.pow(r, a),\n              u = e.sqr(i);\n            u = e.mul(u, r);\n            let h = e.mul(t, u);\n            h = e.pow(h, s), h = e.mul(h, i), i = e.mul(h, r), u = e.mul(h, t);\n            let f = e.mul(u, i);\n            h = e.pow(f, c);\n            let g = e.eql(h, e.ONE);\n            i = e.mul(u, m), h = e.mul(f, n), u = e.cmov(i, u, g), f = e.cmov(h, f, g);\n            for (let t = o; t > d; t--) {\n              let r = l ** (t - l),\n                o = e.pow(f, r);\n              const s = e.eql(o, e.ONE);\n              i = e.mul(u, n), n = e.mul(n, n), o = e.mul(f, n), u = e.cmov(i, u, s), f = e.cmov(o, f, s);\n            }\n            return {\n              isValid: g,\n              value: u\n            };\n          };\n          if (e.ORDER % f === h) {\n            const r = (e.ORDER - h) / f,\n              n = e.sqrt(e.neg(t));\n            g = (t, o) => {\n              let i = e.sqr(o);\n              const s = e.mul(t, o);\n              i = e.mul(i, s);\n              let a = e.pow(i, r);\n              a = e.mul(a, s);\n              const c = e.mul(a, n),\n                u = e.mul(e.sqr(a), o),\n                d = e.eql(u, t);\n              return {\n                isValid: d,\n                value: e.cmov(c, a, d)\n              };\n            };\n          }\n          return g;\n        }\n        t.weierstrassPoints = p, t.weierstrass = function (e) {\n          const r = function (e) {\n              const t = (0, s.validateBasic)(e);\n              return o.validateObject(t, {\n                hash: \"hash\",\n                hmac: \"function\",\n                randomBytes: \"function\"\n              }, {\n                bits2int: \"function\",\n                bits2int_modN: \"function\",\n                lowS: \"boolean\"\n              }), Object.freeze({\n                lowS: !0,\n                ...t\n              });\n            }(e),\n            {\n              Fp: a,\n              n: c\n            } = r,\n            l = a.BYTES + 1,\n            h = 2 * a.BYTES + 1;\n          function f(e) {\n            return n.mod(e, c);\n          }\n          function m(e) {\n            return n.invert(e, c);\n          }\n          const {\n              ProjectivePoint: g,\n              normPrivateKeyToScalar: y,\n              weierstrassEquation: v,\n              isWithinCurveOrder: b\n            } = p({\n              ...r,\n              toBytes(e, t, r) {\n                const n = t.toAffine(),\n                  i = a.toBytes(n.x),\n                  s = o.concatBytes;\n                return r ? s(Uint8Array.from([t.hasEvenY() ? 2 : 3]), i) : s(Uint8Array.from([4]), i, a.toBytes(n.y));\n              },\n              fromBytes(e) {\n                const t = e.length,\n                  r = e[0],\n                  n = e.subarray(1);\n                if (t !== l || 2 !== r && 3 !== r) {\n                  if (t === h && 4 === r) return {\n                    x: a.fromBytes(n.subarray(0, a.BYTES)),\n                    y: a.fromBytes(n.subarray(a.BYTES, 2 * a.BYTES))\n                  };\n                  throw new Error(`Point of length ${t} was invalid. Expected ${l} compressed bytes or ${h} uncompressed bytes`);\n                }\n                {\n                  const e = o.bytesToNumberBE(n);\n                  if (!(u < (i = e) && i < a.ORDER)) throw new Error(\"Point is not on curve\");\n                  const t = v(e);\n                  let s = a.sqrt(t);\n                  return 1 == (1 & r) != ((s & d) === d) && (s = a.neg(s)), {\n                    x: e,\n                    y: s\n                  };\n                }\n                var i;\n              }\n            }),\n            E = e => o.bytesToHex(o.numberToBytesBE(e, r.nByteLength));\n          function _(e) {\n            return e > c >> d;\n          }\n          const A = (e, t, r) => o.bytesToNumberBE(e.slice(t, r));\n          class T {\n            constructor(e, t, r) {\n              this.r = e, this.s = t, this.recovery = r, this.assertValidity();\n            }\n            static fromCompact(e) {\n              const t = r.nByteLength;\n              return e = (0, i.ensureBytes)(\"compactSignature\", e, 2 * t), new T(A(e, 0, t), A(e, t, 2 * t));\n            }\n            static fromDER(e) {\n              const {\n                r,\n                s: n\n              } = t.DER.toSig((0, i.ensureBytes)(\"DER\", e));\n              return new T(r, n);\n            }\n            assertValidity() {\n              if (!b(this.r)) throw new Error(\"r must be 0 < r < CURVE.n\");\n              if (!b(this.s)) throw new Error(\"s must be 0 < s < CURVE.n\");\n            }\n            addRecoveryBit(e) {\n              return new T(this.r, this.s, e);\n            }\n            recoverPublicKey(e) {\n              const {\n                  r: t,\n                  s: n,\n                  recovery: o\n                } = this,\n                s = P((0, i.ensureBytes)(\"msgHash\", e));\n              if (null == o || ![0, 1, 2, 3].includes(o)) throw new Error(\"recovery id invalid\");\n              const c = 2 === o || 3 === o ? t + r.n : t;\n              if (c >= a.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n              const u = 0 == (1 & o) ? \"02\" : \"03\",\n                d = g.fromHex(u + E(c)),\n                l = m(c),\n                h = f(-s * l),\n                p = f(n * l),\n                y = g.BASE.multiplyAndAddUnsafe(d, h, p);\n              if (!y) throw new Error(\"point at infinify\");\n              return y.assertValidity(), y;\n            }\n            hasHighS() {\n              return _(this.s);\n            }\n            normalizeS() {\n              return this.hasHighS() ? new T(this.r, f(-this.s), this.recovery) : this;\n            }\n            toDERRawBytes() {\n              return o.hexToBytes(this.toDERHex());\n            }\n            toDERHex() {\n              return t.DER.hexFromSig({\n                r: this.r,\n                s: this.s\n              });\n            }\n            toCompactRawBytes() {\n              return o.hexToBytes(this.toCompactHex());\n            }\n            toCompactHex() {\n              return E(this.r) + E(this.s);\n            }\n          }\n          const w = {\n            isValidPrivateKey(e) {\n              try {\n                return y(e), !0;\n              } catch (e) {\n                return !1;\n              }\n            },\n            normPrivateKeyToScalar: y,\n            randomPrivateKey: () => {\n              const e = r.randomBytes(a.BYTES + 8),\n                t = n.hashToPrivateScalar(e, c);\n              return o.numberToBytesBE(t, r.nByteLength);\n            },\n            precompute: (e = 8, t = g.BASE) => (t._setWindowSize(e), t.multiply(BigInt(3)), t)\n          };\n          function I(e) {\n            const t = e instanceof Uint8Array,\n              r = \"string\" == typeof e,\n              n = (t || r) && e.length;\n            return t ? n === l || n === h : r ? n === 2 * l || n === 2 * h : e instanceof g;\n          }\n          const R = r.bits2int || function (e) {\n              const t = o.bytesToNumberBE(e),\n                n = 8 * e.length - r.nBitLength;\n              return n > 0 ? t >> BigInt(n) : t;\n            },\n            P = r.bits2int_modN || function (e) {\n              return f(R(e));\n            },\n            x = o.bitMask(r.nBitLength);\n          function O(e) {\n            if (\"bigint\" != typeof e) throw new Error(\"bigint expected\");\n            if (!(u <= e && e < x)) throw new Error(`bigint expected < 2^${r.nBitLength}`);\n            return o.numberToBytesBE(e, r.nByteLength);\n          }\n          const S = {\n              lowS: r.lowS,\n              prehash: !1\n            },\n            C = {\n              lowS: r.lowS,\n              prehash: !1\n            };\n          return g.BASE._setWindowSize(8), {\n            CURVE: r,\n            getPublicKey: function (e, t = !0) {\n              return g.fromPrivateKey(e).toRawBytes(t);\n            },\n            getSharedSecret: function (e, t, r = !0) {\n              if (I(e)) throw new Error(\"first arg must be private key\");\n              if (!I(t)) throw new Error(\"second arg must be public key\");\n              return g.fromHex(t).multiply(y(e)).toRawBytes(r);\n            },\n            sign: function (e, t, n = S) {\n              const {\n                seed: s,\n                k2sig: c\n              } = function (e, t, n = S) {\n                if ([\"recovered\", \"canonical\"].some(e => e in n)) throw new Error(\"sign() legacy options not supported\");\n                const {\n                  hash: s,\n                  randomBytes: c\n                } = r;\n                let {\n                  lowS: l,\n                  prehash: h,\n                  extraEntropy: p\n                } = n;\n                null == l && (l = !0), e = (0, i.ensureBytes)(\"msgHash\", e), h && (e = (0, i.ensureBytes)(\"prehashed msgHash\", s(e)));\n                const v = P(e),\n                  E = y(t),\n                  A = [O(E), O(v)];\n                if (null != p) {\n                  const e = !0 === p ? c(a.BYTES) : p;\n                  A.push((0, i.ensureBytes)(\"extraEntropy\", e, a.BYTES));\n                }\n                const w = o.concatBytes(...A),\n                  I = v;\n                return {\n                  seed: w,\n                  k2sig: function (e) {\n                    const t = R(e);\n                    if (!b(t)) return;\n                    const r = m(t),\n                      n = g.BASE.multiply(t).toAffine(),\n                      o = f(n.x);\n                    if (o === u) return;\n                    const i = f(r * f(I + o * E));\n                    if (i === u) return;\n                    let s = (n.x === o ? 0 : 2) | Number(n.y & d),\n                      a = i;\n                    return l && _(i) && (a = function (e) {\n                      return _(e) ? f(-e) : e;\n                    }(i), s ^= 1), new T(o, a, s);\n                  }\n                };\n              }(e, t, n);\n              return o.createHmacDrbg(r.hash.outputLen, r.nByteLength, r.hmac)(s, c);\n            },\n            verify: function (e, n, o, s = C) {\n              const a = e;\n              if (n = (0, i.ensureBytes)(\"msgHash\", n), o = (0, i.ensureBytes)(\"publicKey\", o), \"strict\" in s) throw new Error(\"options.strict was renamed to lowS\");\n              const {\n                lowS: c,\n                prehash: u\n              } = s;\n              let d, l;\n              try {\n                if (\"string\" == typeof a || a instanceof Uint8Array) try {\n                  d = T.fromDER(a);\n                } catch (e) {\n                  if (!(e instanceof t.DER.Err)) throw e;\n                  d = T.fromCompact(a);\n                } else {\n                  if (\"object\" != typeof a || \"bigint\" != typeof a.r || \"bigint\" != typeof a.s) throw new Error(\"PARSE\");\n                  {\n                    const {\n                      r: e,\n                      s: t\n                    } = a;\n                    d = new T(e, t);\n                  }\n                }\n                l = g.fromHex(o);\n              } catch (e) {\n                if (\"PARSE\" === e.message) throw new Error(\"signature must be Signature instance, Uint8Array or hex string\");\n                return !1;\n              }\n              if (c && d.hasHighS()) return !1;\n              u && (n = r.hash(n));\n              const {\n                  r: h,\n                  s: p\n                } = d,\n                y = P(n),\n                v = m(p),\n                b = f(y * v),\n                E = f(h * v),\n                _ = g.BASE.multiplyAndAddUnsafe(l, b, E)?.toAffine();\n              return !!_ && f(_.x) === h;\n            },\n            ProjectivePoint: g,\n            Signature: T,\n            utils: w\n          };\n        }, t.SWUFpSqrtRatio = m, t.mapToCurveSimpleSWU = function (e, t) {\n          if (n.validateField(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n          const r = m(e, t.Z);\n          if (!e.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n          return n => {\n            let o, i, s, a, c, u, d, l;\n            o = e.sqr(n), o = e.mul(o, t.Z), i = e.sqr(o), i = e.add(i, o), s = e.add(i, e.ONE), s = e.mul(s, t.B), a = e.cmov(t.Z, e.neg(i), !e.eql(i, e.ZERO)), a = e.mul(a, t.A), i = e.sqr(s), u = e.sqr(a), c = e.mul(u, t.A), i = e.add(i, c), i = e.mul(i, s), u = e.mul(u, a), c = e.mul(u, t.B), i = e.add(i, c), d = e.mul(o, s);\n            const {\n              isValid: h,\n              value: f\n            } = r(i, u);\n            l = e.mul(o, n), l = e.mul(l, f), d = e.cmov(d, s, h), l = e.cmov(l, f, h);\n            const p = e.isOdd(n) === e.isOdd(l);\n            return l = e.cmov(e.neg(l), l, p), d = e.div(d, a), {\n              x: d,\n              y: l\n            };\n          };\n        };\n      },\n      1613: (e, t) => {\n        \"use strict\";\n\n        function r(e) {\n          if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);\n        }\n        function n(e) {\n          if (\"boolean\" != typeof e) throw new Error(`Expected boolean, not ${e}`);\n        }\n        function o(e, ...t) {\n          if (!(e instanceof Uint8Array)) throw new TypeError(\"Expected Uint8Array\");\n          if (t.length > 0 && !t.includes(e.length)) throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);\n        }\n        function i(e) {\n          if (\"function\" != typeof e || \"function\" != typeof e.create) throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n          r(e.outputLen), r(e.blockLen);\n        }\n        function s(e, t = !0) {\n          if (e.destroyed) throw new Error(\"Hash instance has been destroyed\");\n          if (t && e.finished) throw new Error(\"Hash#digest() has already been called\");\n        }\n        function a(e, t) {\n          o(e);\n          const r = t.outputLen;\n          if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);\n        }\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.output = t.exists = t.hash = t.bytes = t.bool = t.number = void 0, t.number = r, t.bool = n, t.bytes = o, t.hash = i, t.exists = s, t.output = a;\n        const c = {\n          number: r,\n          bool: n,\n          bytes: o,\n          hash: i,\n          exists: s,\n          output: a\n        };\n        t.default = c;\n      },\n      4490: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SHA2 = void 0;\n        const n = r(1613),\n          o = r(488);\n        class i extends o.Hash {\n          constructor(e, t, r, n) {\n            super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = (0, o.createView)(this.buffer);\n          }\n          update(e) {\n            n.default.exists(this);\n            const {\n                view: t,\n                buffer: r,\n                blockLen: i\n              } = this,\n              s = (e = (0, o.toBytes)(e)).length;\n            for (let n = 0; n < s;) {\n              const a = Math.min(i - this.pos, s - n);\n              if (a !== i) r.set(e.subarray(n, n + a), this.pos), this.pos += a, n += a, this.pos === i && (this.process(t, 0), this.pos = 0);else {\n                const t = (0, o.createView)(e);\n                for (; i <= s - n; n += i) this.process(t, n);\n              }\n            }\n            return this.length += e.length, this.roundClean(), this;\n          }\n          digestInto(e) {\n            n.default.exists(this), n.default.output(e, this), this.finished = !0;\n            const {\n              buffer: t,\n              view: r,\n              blockLen: i,\n              isLE: s\n            } = this;\n            let {\n              pos: a\n            } = this;\n            t[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > i - a && (this.process(r, 0), a = 0);\n            for (let e = a; e < i; e++) t[e] = 0;\n            !function (e, t, r, n) {\n              if (\"function\" == typeof e.setBigUint64) return e.setBigUint64(t, r, n);\n              const o = BigInt(32),\n                i = BigInt(4294967295),\n                s = Number(r >> o & i),\n                a = Number(r & i),\n                c = n ? 4 : 0,\n                u = n ? 0 : 4;\n              e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);\n            }(r, i - 8, BigInt(8 * this.length), s), this.process(r, 0);\n            const c = (0, o.createView)(e),\n              u = this.outputLen;\n            if (u % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n            const d = u / 4,\n              l = this.get();\n            if (d > l.length) throw new Error(\"_sha2: outputLen bigger than state\");\n            for (let e = 0; e < d; e++) c.setUint32(4 * e, l[e], s);\n          }\n          digest() {\n            const {\n              buffer: e,\n              outputLen: t\n            } = this;\n            this.digestInto(e);\n            const r = e.slice(0, t);\n            return this.destroy(), r;\n          }\n          _cloneInto(e) {\n            e || (e = new this.constructor()), e.set(...this.get());\n            const {\n              blockLen: t,\n              buffer: r,\n              length: n,\n              finished: o,\n              destroyed: i,\n              pos: s\n            } = this;\n            return e.length = n, e.pos = s, e.finished = o, e.destroyed = i, n % t && e.buffer.set(r), e;\n          }\n        }\n        t.SHA2 = i;\n      },\n      9419: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.crypto = void 0, t.crypto = \"object\" == typeof globalThis && \"crypto\" in globalThis ? globalThis.crypto : void 0;\n      },\n      7493: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.hmac = void 0;\n        const n = r(1613),\n          o = r(488);\n        class i extends o.Hash {\n          constructor(e, t) {\n            super(), this.finished = !1, this.destroyed = !1, n.default.hash(e);\n            const r = (0, o.toBytes)(t);\n            if (this.iHash = e.create(), \"function\" != typeof this.iHash.update) throw new TypeError(\"Expected instance of class which extends utils.Hash\");\n            this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;\n            const i = this.blockLen,\n              s = new Uint8Array(i);\n            s.set(r.length > i ? e.create().update(r).digest() : r);\n            for (let e = 0; e < s.length; e++) s[e] ^= 54;\n            this.iHash.update(s), this.oHash = e.create();\n            for (let e = 0; e < s.length; e++) s[e] ^= 106;\n            this.oHash.update(s), s.fill(0);\n          }\n          update(e) {\n            return n.default.exists(this), this.iHash.update(e), this;\n          }\n          digestInto(e) {\n            n.default.exists(this), n.default.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();\n          }\n          digest() {\n            const e = new Uint8Array(this.oHash.outputLen);\n            return this.digestInto(e), e;\n          }\n          _cloneInto(e) {\n            e || (e = Object.create(Object.getPrototypeOf(this), {}));\n            const {\n              oHash: t,\n              iHash: r,\n              finished: n,\n              destroyed: o,\n              blockLen: i,\n              outputLen: s\n            } = this;\n            return e.finished = n, e.destroyed = o, e.blockLen = i, e.outputLen = s, e.oHash = t._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;\n          }\n          destroy() {\n            this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();\n          }\n        }\n        t.hmac = (e, t, r) => new i(e, t).update(r).digest(), t.hmac.create = (e, t) => new i(e, t);\n      },\n      7371: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.sha224 = t.sha256 = void 0;\n        const n = r(4490),\n          o = r(488),\n          i = (e, t, r) => e & t ^ e & r ^ t & r,\n          s = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),\n          a = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),\n          c = new Uint32Array(64);\n        class u extends n.SHA2 {\n          constructor() {\n            super(64, 32, 8, !1), this.A = 0 | a[0], this.B = 0 | a[1], this.C = 0 | a[2], this.D = 0 | a[3], this.E = 0 | a[4], this.F = 0 | a[5], this.G = 0 | a[6], this.H = 0 | a[7];\n          }\n          get() {\n            const {\n              A: e,\n              B: t,\n              C: r,\n              D: n,\n              E: o,\n              F: i,\n              G: s,\n              H: a\n            } = this;\n            return [e, t, r, n, o, i, s, a];\n          }\n          set(e, t, r, n, o, i, s, a) {\n            this.A = 0 | e, this.B = 0 | t, this.C = 0 | r, this.D = 0 | n, this.E = 0 | o, this.F = 0 | i, this.G = 0 | s, this.H = 0 | a;\n          }\n          process(e, t) {\n            for (let r = 0; r < 16; r++, t += 4) c[r] = e.getUint32(t, !1);\n            for (let e = 16; e < 64; e++) {\n              const t = c[e - 15],\n                r = c[e - 2],\n                n = (0, o.rotr)(t, 7) ^ (0, o.rotr)(t, 18) ^ t >>> 3,\n                i = (0, o.rotr)(r, 17) ^ (0, o.rotr)(r, 19) ^ r >>> 10;\n              c[e] = i + c[e - 7] + n + c[e - 16] | 0;\n            }\n            let {\n              A: r,\n              B: n,\n              C: a,\n              D: u,\n              E: d,\n              F: l,\n              G: h,\n              H: f\n            } = this;\n            for (let e = 0; e < 64; e++) {\n              const t = f + ((0, o.rotr)(d, 6) ^ (0, o.rotr)(d, 11) ^ (0, o.rotr)(d, 25)) + ((p = d) & l ^ ~p & h) + s[e] + c[e] | 0,\n                m = ((0, o.rotr)(r, 2) ^ (0, o.rotr)(r, 13) ^ (0, o.rotr)(r, 22)) + i(r, n, a) | 0;\n              f = h, h = l, l = d, d = u + t | 0, u = a, a = n, n = r, r = t + m | 0;\n            }\n            var p;\n            r = r + this.A | 0, n = n + this.B | 0, a = a + this.C | 0, u = u + this.D | 0, d = d + this.E | 0, l = l + this.F | 0, h = h + this.G | 0, f = f + this.H | 0, this.set(r, n, a, u, d, l, h, f);\n          }\n          roundClean() {\n            c.fill(0);\n          }\n          destroy() {\n            this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);\n          }\n        }\n        class d extends u {\n          constructor() {\n            super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;\n          }\n        }\n        t.sha256 = (0, o.wrapConstructor)(() => new u()), t.sha224 = (0, o.wrapConstructor)(() => new d());\n      },\n      488: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.randomBytes = t.wrapConstructorWithOpts = t.wrapConstructor = t.checkOpts = t.Hash = t.concatBytes = t.toBytes = t.utf8ToBytes = t.asyncLoop = t.nextTick = t.hexToBytes = t.bytesToHex = t.isLE = t.rotr = t.createView = t.u32 = t.u8 = void 0;\n        const n = r(9419);\n        if (t.u8 = e => new Uint8Array(e.buffer, e.byteOffset, e.byteLength), t.u32 = e => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), t.createView = e => new DataView(e.buffer, e.byteOffset, e.byteLength), t.rotr = (e, t) => e << 32 - t | e >>> t, t.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0], !t.isLE) throw new Error(\"Non little-endian hardware is not supported\");\n        const o = Array.from({\n          length: 256\n        }, (e, t) => t.toString(16).padStart(2, \"0\"));\n        function i(e) {\n          if (\"string\" != typeof e) throw new TypeError(\"utf8ToBytes expected string, got \" + typeof e);\n          return new TextEncoder().encode(e);\n        }\n        function s(e) {\n          if (\"string\" == typeof e && (e = i(e)), !(e instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);\n          return e;\n        }\n        t.bytesToHex = function (e) {\n          if (!(e instanceof Uint8Array)) throw new Error(\"Uint8Array expected\");\n          let t = \"\";\n          for (let r = 0; r < e.length; r++) t += o[e[r]];\n          return t;\n        }, t.hexToBytes = function (e) {\n          if (\"string\" != typeof e) throw new TypeError(\"hexToBytes: expected string, got \" + typeof e);\n          if (e.length % 2) throw new Error(\"hexToBytes: received invalid unpadded hex\");\n          const t = new Uint8Array(e.length / 2);\n          for (let r = 0; r < t.length; r++) {\n            const n = 2 * r,\n              o = e.slice(n, n + 2),\n              i = Number.parseInt(o, 16);\n            if (Number.isNaN(i) || i < 0) throw new Error(\"Invalid byte sequence\");\n            t[r] = i;\n          }\n          return t;\n        }, t.nextTick = async () => {}, t.asyncLoop = async function (e, r, n) {\n          let o = Date.now();\n          for (let i = 0; i < e; i++) {\n            n(i);\n            const e = Date.now() - o;\n            e >= 0 && e < r || (await (0, t.nextTick)(), o += e);\n          }\n        }, t.utf8ToBytes = i, t.toBytes = s, t.concatBytes = function (...e) {\n          if (!e.every(e => e instanceof Uint8Array)) throw new Error(\"Uint8Array list expected\");\n          if (1 === e.length) return e[0];\n          const t = e.reduce((e, t) => e + t.length, 0),\n            r = new Uint8Array(t);\n          for (let t = 0, n = 0; t < e.length; t++) {\n            const o = e[t];\n            r.set(o, n), n += o.length;\n          }\n          return r;\n        }, t.Hash = class {\n          clone() {\n            return this._cloneInto();\n          }\n        }, t.checkOpts = function (e, t) {\n          if (void 0 !== t && (\"object\" != typeof t || (r = t, \"[object Object]\" !== Object.prototype.toString.call(r) || r.constructor !== Object))) throw new TypeError(\"Options should be object or undefined\");\n          var r;\n          return Object.assign(e, t);\n        }, t.wrapConstructor = function (e) {\n          const t = t => e().update(s(t)).digest(),\n            r = e();\n          return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;\n        }, t.wrapConstructorWithOpts = function (e) {\n          const t = (t, r) => e(r).update(s(t)).digest(),\n            r = e({});\n          return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = t => e(t), t;\n        }, t.randomBytes = function (e = 32) {\n          if (n.crypto && \"function\" == typeof n.crypto.getRandomValues) return n.crypto.getRandomValues(new Uint8Array(e));\n          throw new Error(\"crypto.getRandomValues must be defined\");\n        };\n      },\n      8358: (e, t, r) => {\n        \"use strict\";\n\n        var n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.encodeToCurve = t.hashToCurve = t.schnorr = t.secp256k1 = void 0;\n        const o = r(7371),\n          i = r(488),\n          s = r(9530),\n          a = r(7851),\n          c = r(4323),\n          u = r(1322),\n          d = r(5887),\n          l = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\"),\n          h = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"),\n          f = BigInt(1),\n          p = BigInt(2),\n          m = (e, t) => (e + t / p) / t;\n        function g(e) {\n          const t = l,\n            r = BigInt(3),\n            n = BigInt(6),\n            o = BigInt(11),\n            i = BigInt(22),\n            a = BigInt(23),\n            c = BigInt(44),\n            u = BigInt(88),\n            d = e * e * e % t,\n            h = d * d * e % t,\n            f = (0, s.pow2)(h, r, t) * h % t,\n            m = (0, s.pow2)(f, r, t) * h % t,\n            g = (0, s.pow2)(m, p, t) * d % t,\n            v = (0, s.pow2)(g, o, t) * g % t,\n            b = (0, s.pow2)(v, i, t) * v % t,\n            E = (0, s.pow2)(b, c, t) * b % t,\n            _ = (0, s.pow2)(E, u, t) * E % t,\n            A = (0, s.pow2)(_, c, t) * b % t,\n            T = (0, s.pow2)(A, r, t) * h % t,\n            w = (0, s.pow2)(T, a, t) * v % t,\n            I = (0, s.pow2)(w, n, t) * d % t,\n            R = (0, s.pow2)(I, p, t);\n          if (!y.eql(y.sqr(R), e)) throw new Error(\"Cannot find square root\");\n          return R;\n        }\n        const y = (0, s.Field)(l, void 0, void 0, {\n          sqrt: g\n        });\n        t.secp256k1 = (0, d.createCurve)({\n          a: BigInt(0),\n          b: BigInt(7),\n          Fp: y,\n          n: h,\n          Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n          Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n          h: BigInt(1),\n          lowS: !0,\n          endo: {\n            beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n            splitScalar: e => {\n              const t = h,\n                r = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\"),\n                n = -f * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\"),\n                o = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\"),\n                i = r,\n                a = BigInt(\"0x100000000000000000000000000000000\"),\n                c = m(i * e, t),\n                u = m(-n * e, t);\n              let d = (0, s.mod)(e - c * r - u * o, t),\n                l = (0, s.mod)(-c * n - u * i, t);\n              const p = d > a,\n                g = l > a;\n              if (p && (d = t - d), g && (l = t - l), d > a || l > a) throw new Error(\"splitScalar: Endomorphism failed, k=\" + e);\n              return {\n                k1neg: p,\n                k1: d,\n                k2neg: g,\n                k2: l\n              };\n            }\n          }\n        }, o.sha256);\n        const v = BigInt(0),\n          b = e => \"bigint\" == typeof e && v < e && e < l,\n          E = {};\n        function _(e, ...t) {\n          let r = E[e];\n          if (void 0 === r) {\n            const t = (0, o.sha256)(Uint8Array.from(e, e => e.charCodeAt(0)));\n            r = (0, c.concatBytes)(t, t), E[e] = r;\n          }\n          return (0, o.sha256)((0, c.concatBytes)(r, ...t));\n        }\n        const A = e => e.toRawBytes(!0).slice(1),\n          T = e => (0, c.numberToBytesBE)(e, 32),\n          w = e => (0, s.mod)(e, l),\n          I = e => (0, s.mod)(e, h),\n          R = t.secp256k1.ProjectivePoint;\n        function P(e) {\n          let r = t.secp256k1.utils.normPrivateKeyToScalar(e),\n            n = R.fromPrivateKey(r);\n          return {\n            scalar: n.hasEvenY() ? r : I(-r),\n            bytes: A(n)\n          };\n        }\n        function x(e) {\n          if (!b(e)) throw new Error(\"bad x: need 0 < x < p\");\n          const t = w(e * e);\n          let r = g(w(t * e + BigInt(7)));\n          r % p !== v && (r = w(-r));\n          const n = new R(e, r, f);\n          return n.assertValidity(), n;\n        }\n        function O(...e) {\n          return I((0, c.bytesToNumberBE)(_(\"BIP0340/challenge\", ...e)));\n        }\n        function S(e, t, r) {\n          const n = (0, c.ensureBytes)(\"signature\", e, 64),\n            o = (0, c.ensureBytes)(\"message\", t),\n            i = (0, c.ensureBytes)(\"publicKey\", r, 32);\n          try {\n            const e = x((0, c.bytesToNumberBE)(i)),\n              t = (0, c.bytesToNumberBE)(n.subarray(0, 32));\n            if (!b(t)) return !1;\n            const r = (0, c.bytesToNumberBE)(n.subarray(32, 64));\n            if (!(\"bigint\" == typeof (d = r) && v < d && d < h)) return !1;\n            const l = O(T(t), A(e), o),\n              f = (s = e, a = r, u = I(-l), R.BASE.multiplyAndAddUnsafe(s, a, u));\n            return !(!f || !f.hasEvenY() || f.toAffine().x !== t);\n          } catch (e) {\n            return !1;\n          }\n          var s, a, u, d;\n        }\n        t.schnorr = {\n          getPublicKey: function (e) {\n            return P(e).bytes;\n          },\n          sign: function (e, t, r = (0, i.randomBytes)(32)) {\n            const n = (0, c.ensureBytes)(\"message\", e),\n              {\n                bytes: o,\n                scalar: s\n              } = P(t),\n              a = (0, c.ensureBytes)(\"auxRand\", r, 32),\n              u = T(s ^ (0, c.bytesToNumberBE)(_(\"BIP0340/aux\", a))),\n              d = _(\"BIP0340/nonce\", u, o, n),\n              l = I((0, c.bytesToNumberBE)(d));\n            if (l === v) throw new Error(\"sign failed: k is zero\");\n            const {\n                bytes: h,\n                scalar: f\n              } = P(l),\n              p = O(h, o, n),\n              m = new Uint8Array(64);\n            if (m.set(h, 0), m.set(T(I(f + p * s)), 32), !S(m, n, o)) throw new Error(\"sign: Invalid signature produced\");\n            return m;\n          },\n          verify: S,\n          utils: {\n            randomPrivateKey: t.secp256k1.utils.randomPrivateKey,\n            lift_x: x,\n            pointToBytes: A,\n            numberToBytesBE: c.numberToBytesBE,\n            bytesToNumberBE: c.bytesToNumberBE,\n            taggedHash: _,\n            mod: s.mod\n          }\n        };\n        const C = u.isogenyMap(y, [[\"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\", \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\", \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\", \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"], [\"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\", \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\", \"0x0000000000000000000000000000000000000000000000000000000000000001\"], [\"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\", \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\", \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\", \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"], [\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\", \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\", \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\", \"0x0000000000000000000000000000000000000000000000000000000000000001\"]].map(e => e.map(e => BigInt(e)))),\n          B = (0, a.mapToCurveSimpleSWU)(y, {\n            A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n            B: BigInt(\"1771\"),\n            Z: y.create(BigInt(\"-11\"))\n          });\n        n = u.createHasher(t.secp256k1.ProjectivePoint, e => {\n          const {\n            x: t,\n            y: r\n          } = B(y.create(e[0]));\n          return C(t, r);\n        }, {\n          DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n          encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n          p: y.ORDER,\n          m: 1,\n          k: 128,\n          expand: \"xmd\",\n          hash: o.sha256\n        }), t.hashToCurve = n.hashToCurve, t.encodeToCurve = n.encodeToCurve;\n      },\n      1238: (e, t) => {\n        var r;\n        r = function (e) {\n          e.version = \"1.2.2\";\n          var t = function () {\n              for (var e = 0, t = new Array(256), r = 0; 256 != r; ++r) e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = r) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1, t[r] = e;\n              return \"undefined\" != typeof Int32Array ? new Int32Array(t) : t;\n            }(),\n            r = function (e) {\n              var t = 0,\n                r = 0,\n                n = 0,\n                o = \"undefined\" != typeof Int32Array ? new Int32Array(4096) : new Array(4096);\n              for (n = 0; 256 != n; ++n) o[n] = e[n];\n              for (n = 0; 256 != n; ++n) for (r = e[n], t = 256 + n; t < 4096; t += 256) r = o[t] = r >>> 8 ^ e[255 & r];\n              var i = [];\n              for (n = 1; 16 != n; ++n) i[n - 1] = \"undefined\" != typeof Int32Array ? o.subarray(256 * n, 256 * n + 256) : o.slice(256 * n, 256 * n + 256);\n              return i;\n            }(t),\n            n = r[0],\n            o = r[1],\n            i = r[2],\n            s = r[3],\n            a = r[4],\n            c = r[5],\n            u = r[6],\n            d = r[7],\n            l = r[8],\n            h = r[9],\n            f = r[10],\n            p = r[11],\n            m = r[12],\n            g = r[13],\n            y = r[14];\n          e.table = t, e.bstr = function (e, r) {\n            for (var n = -1 ^ r, o = 0, i = e.length; o < i;) n = n >>> 8 ^ t[255 & (n ^ e.charCodeAt(o++))];\n            return ~n;\n          }, e.buf = function (e, r) {\n            for (var v = -1 ^ r, b = e.length - 15, E = 0; E < b;) v = y[e[E++] ^ 255 & v] ^ g[e[E++] ^ v >> 8 & 255] ^ m[e[E++] ^ v >> 16 & 255] ^ p[e[E++] ^ v >>> 24] ^ f[e[E++]] ^ h[e[E++]] ^ l[e[E++]] ^ d[e[E++]] ^ u[e[E++]] ^ c[e[E++]] ^ a[e[E++]] ^ s[e[E++]] ^ i[e[E++]] ^ o[e[E++]] ^ n[e[E++]] ^ t[e[E++]];\n            for (b += 15; E < b;) v = v >>> 8 ^ t[255 & (v ^ e[E++])];\n            return ~v;\n          }, e.str = function (e, r) {\n            for (var n = -1 ^ r, o = 0, i = e.length, s = 0, a = 0; o < i;) (s = e.charCodeAt(o++)) < 128 ? n = n >>> 8 ^ t[255 & (n ^ s)] : s < 2048 ? n = (n = n >>> 8 ^ t[255 & (n ^ (192 | s >> 6 & 31))]) >>> 8 ^ t[255 & (n ^ (128 | 63 & s))] : s >= 55296 && s < 57344 ? (s = 64 + (1023 & s), a = 1023 & e.charCodeAt(o++), n = (n = (n = (n = n >>> 8 ^ t[255 & (n ^ (240 | s >> 8 & 7))]) >>> 8 ^ t[255 & (n ^ (128 | s >> 2 & 63))]) >>> 8 ^ t[255 & (n ^ (128 | a >> 6 & 15 | (3 & s) << 4))]) >>> 8 ^ t[255 & (n ^ (128 | 63 & a))]) : n = (n = (n = n >>> 8 ^ t[255 & (n ^ (224 | s >> 12 & 15))]) >>> 8 ^ t[255 & (n ^ (128 | s >> 6 & 63))]) >>> 8 ^ t[255 & (n ^ (128 | 63 & s))];\n            return ~n;\n          };\n        }, \"undefined\" == typeof DO_NOT_EXPORT_CRC ? r(t) : r({});\n      },\n      6279: (e, t, r) => {\n        var n = \"undefined\" != typeof globalThis && globalThis || \"undefined\" != typeof self && self || void 0 !== r.g && r.g,\n          o = function () {\n            function e() {\n              this.fetch = !1, this.DOMException = n.DOMException;\n            }\n            return e.prototype = n, new e();\n          }();\n        !function (e) {\n          !function (t) {\n            var r = void 0 !== e && e || \"undefined\" != typeof self && self || void 0 !== r && r,\n              n = (\"URLSearchParams\" in r),\n              o = \"Symbol\" in r && \"iterator\" in Symbol,\n              i = \"FileReader\" in r && \"Blob\" in r && function () {\n                try {\n                  return new Blob(), !0;\n                } catch (e) {\n                  return !1;\n                }\n              }(),\n              s = (\"FormData\" in r),\n              a = (\"ArrayBuffer\" in r);\n            if (a) var c = [\"[object Int8Array]\", \"[object Uint8Array]\", \"[object Uint8ClampedArray]\", \"[object Int16Array]\", \"[object Uint16Array]\", \"[object Int32Array]\", \"[object Uint32Array]\", \"[object Float32Array]\", \"[object Float64Array]\"],\n              u = ArrayBuffer.isView || function (e) {\n                return e && c.indexOf(Object.prototype.toString.call(e)) > -1;\n              };\n            function d(e) {\n              if (\"string\" != typeof e && (e = String(e)), /[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(e) || \"\" === e) throw new TypeError('Invalid character in header field name: \"' + e + '\"');\n              return e.toLowerCase();\n            }\n            function l(e) {\n              return \"string\" != typeof e && (e = String(e)), e;\n            }\n            function h(e) {\n              var t = {\n                next: function () {\n                  var t = e.shift();\n                  return {\n                    done: void 0 === t,\n                    value: t\n                  };\n                }\n              };\n              return o && (t[Symbol.iterator] = function () {\n                return t;\n              }), t;\n            }\n            function f(e) {\n              this.map = {}, e instanceof f ? e.forEach(function (e, t) {\n                this.append(t, e);\n              }, this) : Array.isArray(e) ? e.forEach(function (e) {\n                this.append(e[0], e[1]);\n              }, this) : e && Object.getOwnPropertyNames(e).forEach(function (t) {\n                this.append(t, e[t]);\n              }, this);\n            }\n            function p(e) {\n              if (e.bodyUsed) return Promise.reject(new TypeError(\"Already read\"));\n              e.bodyUsed = !0;\n            }\n            function m(e) {\n              return new Promise(function (t, r) {\n                e.onload = function () {\n                  t(e.result);\n                }, e.onerror = function () {\n                  r(e.error);\n                };\n              });\n            }\n            function g(e) {\n              var t = new FileReader(),\n                r = m(t);\n              return t.readAsArrayBuffer(e), r;\n            }\n            function y(e) {\n              if (e.slice) return e.slice(0);\n              var t = new Uint8Array(e.byteLength);\n              return t.set(new Uint8Array(e)), t.buffer;\n            }\n            function v() {\n              return this.bodyUsed = !1, this._initBody = function (e) {\n                var t;\n                this.bodyUsed = this.bodyUsed, this._bodyInit = e, e ? \"string\" == typeof e ? this._bodyText = e : i && Blob.prototype.isPrototypeOf(e) ? this._bodyBlob = e : s && FormData.prototype.isPrototypeOf(e) ? this._bodyFormData = e : n && URLSearchParams.prototype.isPrototypeOf(e) ? this._bodyText = e.toString() : a && i && (t = e) && DataView.prototype.isPrototypeOf(t) ? (this._bodyArrayBuffer = y(e.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : a && (ArrayBuffer.prototype.isPrototypeOf(e) || u(e)) ? this._bodyArrayBuffer = y(e) : this._bodyText = e = Object.prototype.toString.call(e) : this._bodyText = \"\", this.headers.get(\"content-type\") || (\"string\" == typeof e ? this.headers.set(\"content-type\", \"text/plain;charset=UTF-8\") : this._bodyBlob && this._bodyBlob.type ? this.headers.set(\"content-type\", this._bodyBlob.type) : n && URLSearchParams.prototype.isPrototypeOf(e) && this.headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\"));\n              }, i && (this.blob = function () {\n                var e = p(this);\n                if (e) return e;\n                if (this._bodyBlob) return Promise.resolve(this._bodyBlob);\n                if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));\n                if (this._bodyFormData) throw new Error(\"could not read FormData body as blob\");\n                return Promise.resolve(new Blob([this._bodyText]));\n              }, this.arrayBuffer = function () {\n                return this._bodyArrayBuffer ? p(this) || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer)) : this.blob().then(g);\n              }), this.text = function () {\n                var e,\n                  t,\n                  r,\n                  n = p(this);\n                if (n) return n;\n                if (this._bodyBlob) return e = this._bodyBlob, r = m(t = new FileReader()), t.readAsText(e), r;\n                if (this._bodyArrayBuffer) return Promise.resolve(function (e) {\n                  for (var t = new Uint8Array(e), r = new Array(t.length), n = 0; n < t.length; n++) r[n] = String.fromCharCode(t[n]);\n                  return r.join(\"\");\n                }(this._bodyArrayBuffer));\n                if (this._bodyFormData) throw new Error(\"could not read FormData body as text\");\n                return Promise.resolve(this._bodyText);\n              }, s && (this.formData = function () {\n                return this.text().then(_);\n              }), this.json = function () {\n                return this.text().then(JSON.parse);\n              }, this;\n            }\n            f.prototype.append = function (e, t) {\n              e = d(e), t = l(t);\n              var r = this.map[e];\n              this.map[e] = r ? r + \", \" + t : t;\n            }, f.prototype.delete = function (e) {\n              delete this.map[d(e)];\n            }, f.prototype.get = function (e) {\n              return e = d(e), this.has(e) ? this.map[e] : null;\n            }, f.prototype.has = function (e) {\n              return this.map.hasOwnProperty(d(e));\n            }, f.prototype.set = function (e, t) {\n              this.map[d(e)] = l(t);\n            }, f.prototype.forEach = function (e, t) {\n              for (var r in this.map) this.map.hasOwnProperty(r) && e.call(t, this.map[r], r, this);\n            }, f.prototype.keys = function () {\n              var e = [];\n              return this.forEach(function (t, r) {\n                e.push(r);\n              }), h(e);\n            }, f.prototype.values = function () {\n              var e = [];\n              return this.forEach(function (t) {\n                e.push(t);\n              }), h(e);\n            }, f.prototype.entries = function () {\n              var e = [];\n              return this.forEach(function (t, r) {\n                e.push([r, t]);\n              }), h(e);\n            }, o && (f.prototype[Symbol.iterator] = f.prototype.entries);\n            var b = [\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"];\n            function E(e, t) {\n              if (!(this instanceof E)) throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.');\n              var r,\n                n,\n                o = (t = t || {}).body;\n              if (e instanceof E) {\n                if (e.bodyUsed) throw new TypeError(\"Already read\");\n                this.url = e.url, this.credentials = e.credentials, t.headers || (this.headers = new f(e.headers)), this.method = e.method, this.mode = e.mode, this.signal = e.signal, o || null == e._bodyInit || (o = e._bodyInit, e.bodyUsed = !0);\n              } else this.url = String(e);\n              if (this.credentials = t.credentials || this.credentials || \"same-origin\", !t.headers && this.headers || (this.headers = new f(t.headers)), this.method = (n = (r = t.method || this.method || \"GET\").toUpperCase(), b.indexOf(n) > -1 ? n : r), this.mode = t.mode || this.mode || null, this.signal = t.signal || this.signal, this.referrer = null, (\"GET\" === this.method || \"HEAD\" === this.method) && o) throw new TypeError(\"Body not allowed for GET or HEAD requests\");\n              if (this._initBody(o), !(\"GET\" !== this.method && \"HEAD\" !== this.method || \"no-store\" !== t.cache && \"no-cache\" !== t.cache)) {\n                var i = /([?&])_=[^&]*/;\n                i.test(this.url) ? this.url = this.url.replace(i, \"$1_=\" + new Date().getTime()) : this.url += (/\\?/.test(this.url) ? \"&\" : \"?\") + \"_=\" + new Date().getTime();\n              }\n            }\n            function _(e) {\n              var t = new FormData();\n              return e.trim().split(\"&\").forEach(function (e) {\n                if (e) {\n                  var r = e.split(\"=\"),\n                    n = r.shift().replace(/\\+/g, \" \"),\n                    o = r.join(\"=\").replace(/\\+/g, \" \");\n                  t.append(decodeURIComponent(n), decodeURIComponent(o));\n                }\n              }), t;\n            }\n            function A(e, t) {\n              if (!(this instanceof A)) throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.');\n              t || (t = {}), this.type = \"default\", this.status = void 0 === t.status ? 200 : t.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = void 0 === t.statusText ? \"\" : \"\" + t.statusText, this.headers = new f(t.headers), this.url = t.url || \"\", this._initBody(e);\n            }\n            E.prototype.clone = function () {\n              return new E(this, {\n                body: this._bodyInit\n              });\n            }, v.call(E.prototype), v.call(A.prototype), A.prototype.clone = function () {\n              return new A(this._bodyInit, {\n                status: this.status,\n                statusText: this.statusText,\n                headers: new f(this.headers),\n                url: this.url\n              });\n            }, A.error = function () {\n              var e = new A(null, {\n                status: 0,\n                statusText: \"\"\n              });\n              return e.type = \"error\", e;\n            };\n            var T = [301, 302, 303, 307, 308];\n            A.redirect = function (e, t) {\n              if (-1 === T.indexOf(t)) throw new RangeError(\"Invalid status code\");\n              return new A(null, {\n                status: t,\n                headers: {\n                  location: e\n                }\n              });\n            }, t.DOMException = r.DOMException;\n            try {\n              new t.DOMException();\n            } catch (e) {\n              t.DOMException = function (e, t) {\n                this.message = e, this.name = t;\n                var r = Error(e);\n                this.stack = r.stack;\n              }, t.DOMException.prototype = Object.create(Error.prototype), t.DOMException.prototype.constructor = t.DOMException;\n            }\n            function w(e, n) {\n              return new Promise(function (o, s) {\n                var c = new E(e, n);\n                if (c.signal && c.signal.aborted) return s(new t.DOMException(\"Aborted\", \"AbortError\"));\n                var u = new XMLHttpRequest();\n                function d() {\n                  u.abort();\n                }\n                u.onload = function () {\n                  var e,\n                    t,\n                    r = {\n                      status: u.status,\n                      statusText: u.statusText,\n                      headers: (e = u.getAllResponseHeaders() || \"\", t = new f(), e.replace(/\\r?\\n[\\t ]+/g, \" \").split(\"\\r\").map(function (e) {\n                        return 0 === e.indexOf(\"\\n\") ? e.substr(1, e.length) : e;\n                      }).forEach(function (e) {\n                        var r = e.split(\":\"),\n                          n = r.shift().trim();\n                        if (n) {\n                          var o = r.join(\":\").trim();\n                          t.append(n, o);\n                        }\n                      }), t)\n                    };\n                  r.url = \"responseURL\" in u ? u.responseURL : r.headers.get(\"X-Request-URL\");\n                  var n = \"response\" in u ? u.response : u.responseText;\n                  setTimeout(function () {\n                    o(new A(n, r));\n                  }, 0);\n                }, u.onerror = function () {\n                  setTimeout(function () {\n                    s(new TypeError(\"Network request failed\"));\n                  }, 0);\n                }, u.ontimeout = function () {\n                  setTimeout(function () {\n                    s(new TypeError(\"Network request failed\"));\n                  }, 0);\n                }, u.onabort = function () {\n                  setTimeout(function () {\n                    s(new t.DOMException(\"Aborted\", \"AbortError\"));\n                  }, 0);\n                }, u.open(c.method, function (e) {\n                  try {\n                    return \"\" === e && r.location.href ? r.location.href : e;\n                  } catch (t) {\n                    return e;\n                  }\n                }(c.url), !0), \"include\" === c.credentials ? u.withCredentials = !0 : \"omit\" === c.credentials && (u.withCredentials = !1), \"responseType\" in u && (i ? u.responseType = \"blob\" : a && c.headers.get(\"Content-Type\") && -1 !== c.headers.get(\"Content-Type\").indexOf(\"application/octet-stream\") && (u.responseType = \"arraybuffer\")), !n || \"object\" != typeof n.headers || n.headers instanceof f ? c.headers.forEach(function (e, t) {\n                  u.setRequestHeader(t, e);\n                }) : Object.getOwnPropertyNames(n.headers).forEach(function (e) {\n                  u.setRequestHeader(e, l(n.headers[e]));\n                }), c.signal && (c.signal.addEventListener(\"abort\", d), u.onreadystatechange = function () {\n                  4 === u.readyState && c.signal.removeEventListener(\"abort\", d);\n                }), u.send(void 0 === c._bodyInit ? null : c._bodyInit);\n              });\n            }\n            w.polyfill = !0, r.fetch || (r.fetch = w, r.Headers = f, r.Request = E, r.Response = A), t.Headers = f, t.Request = E, t.Response = A, t.fetch = w;\n          }({});\n        }(o), o.fetch.ponyfill = !0, delete o.fetch.polyfill;\n        var i = n.fetch ? n : o;\n        (t = i.fetch).default = i.fetch, t.fetch = i.fetch, t.Headers = i.Headers, t.Request = i.Request, t.Response = i.Response, e.exports = t;\n      },\n      7475: (e, t, r) => {\n        \"use strict\";\n\n        r.r(t), r.d(t, {\n          default: () => o\n        });\n        var n = null;\n        \"undefined\" != typeof WebSocket ? n = WebSocket : \"undefined\" != typeof MozWebSocket ? n = MozWebSocket : void 0 !== r.g ? n = r.g.WebSocket || r.g.MozWebSocket : \"undefined\" != typeof window ? n = window.WebSocket || window.MozWebSocket : \"undefined\" != typeof self && (n = self.WebSocket || self.MozWebSocket);\n        const o = n;\n      },\n      4406: e => {\n        var t,\n          r,\n          n = e.exports = {};\n        function o() {\n          throw new Error(\"setTimeout has not been defined\");\n        }\n        function i() {\n          throw new Error(\"clearTimeout has not been defined\");\n        }\n        function s(e) {\n          if (t === setTimeout) return setTimeout(e, 0);\n          if ((t === o || !t) && setTimeout) return t = setTimeout, setTimeout(e, 0);\n          try {\n            return t(e, 0);\n          } catch (r) {\n            try {\n              return t.call(null, e, 0);\n            } catch (r) {\n              return t.call(this, e, 0);\n            }\n          }\n        }\n        !function () {\n          try {\n            t = \"function\" == typeof setTimeout ? setTimeout : o;\n          } catch (e) {\n            t = o;\n          }\n          try {\n            r = \"function\" == typeof clearTimeout ? clearTimeout : i;\n          } catch (e) {\n            r = i;\n          }\n        }();\n        var a,\n          c = [],\n          u = !1,\n          d = -1;\n        function l() {\n          u && a && (u = !1, a.length ? c = a.concat(c) : d = -1, c.length && h());\n        }\n        function h() {\n          if (!u) {\n            var e = s(l);\n            u = !0;\n            for (var t = c.length; t;) {\n              for (a = c, c = []; ++d < t;) a && a[d].run();\n              d = -1, t = c.length;\n            }\n            a = null, u = !1, function (e) {\n              if (r === clearTimeout) return clearTimeout(e);\n              if ((r === i || !r) && clearTimeout) return r = clearTimeout, clearTimeout(e);\n              try {\n                r(e);\n              } catch (t) {\n                try {\n                  return r.call(null, e);\n                } catch (t) {\n                  return r.call(this, e);\n                }\n              }\n            }(e);\n          }\n        }\n        function f(e, t) {\n          this.fun = e, this.array = t;\n        }\n        function p() {}\n        n.nextTick = function (e) {\n          var t = new Array(arguments.length - 1);\n          if (arguments.length > 1) for (var r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];\n          c.push(new f(e, t)), 1 !== c.length || u || s(h);\n        }, f.prototype.run = function () {\n          this.fun.apply(null, this.array);\n        }, n.title = \"browser\", n.browser = !0, n.env = {}, n.argv = [], n.version = \"\", n.versions = {}, n.on = p, n.addListener = p, n.once = p, n.off = p, n.removeListener = p, n.removeAllListeners = p, n.emit = p, n.prependListener = p, n.prependOnceListener = p, n.listeners = function (e) {\n          return [];\n        }, n.binding = function (e) {\n          throw new Error(\"process.binding is not supported\");\n        }, n.cwd = function () {\n          return \"/\";\n        }, n.chdir = function (e) {\n          throw new Error(\"process.chdir is not supported\");\n        }, n.umask = function () {\n          return 0;\n        };\n      },\n      6985: function (e, t, r) {\n        var n = r(4406);\n        !function (e, t) {\n          \"use strict\";\n\n          if (!e.setImmediate) {\n            var r,\n              o,\n              i,\n              s,\n              a,\n              c = 1,\n              u = {},\n              d = !1,\n              l = e.document,\n              h = Object.getPrototypeOf && Object.getPrototypeOf(e);\n            h = h && h.setTimeout ? h : e, \"[object process]\" === {}.toString.call(e.process) ? r = function (e) {\n              n.nextTick(function () {\n                p(e);\n              });\n            } : function () {\n              if (e.postMessage && !e.importScripts) {\n                var t = !0,\n                  r = e.onmessage;\n                return e.onmessage = function () {\n                  t = !1;\n                }, e.postMessage(\"\", \"*\"), e.onmessage = r, t;\n              }\n            }() ? (s = \"setImmediate$\" + Math.random() + \"$\", a = function (t) {\n              t.source === e && \"string\" == typeof t.data && 0 === t.data.indexOf(s) && p(+t.data.slice(s.length));\n            }, e.addEventListener ? e.addEventListener(\"message\", a, !1) : e.attachEvent(\"onmessage\", a), r = function (t) {\n              e.postMessage(s + t, \"*\");\n            }) : e.MessageChannel ? ((i = new MessageChannel()).port1.onmessage = function (e) {\n              p(e.data);\n            }, r = function (e) {\n              i.port2.postMessage(e);\n            }) : l && \"onreadystatechange\" in l.createElement(\"script\") ? (o = l.documentElement, r = function (e) {\n              var t = l.createElement(\"script\");\n              t.onreadystatechange = function () {\n                p(e), t.onreadystatechange = null, o.removeChild(t), t = null;\n              }, o.appendChild(t);\n            }) : r = function (e) {\n              setTimeout(p, 0, e);\n            }, h.setImmediate = function (e) {\n              \"function\" != typeof e && (e = new Function(\"\" + e));\n              for (var t = new Array(arguments.length - 1), n = 0; n < t.length; n++) t[n] = arguments[n + 1];\n              var o = {\n                callback: e,\n                args: t\n              };\n              return u[c] = o, r(c), c++;\n            }, h.clearImmediate = f;\n          }\n          function f(e) {\n            delete u[e];\n          }\n          function p(e) {\n            if (d) setTimeout(p, 0, e);else {\n              var t = u[e];\n              if (t) {\n                d = !0;\n                try {\n                  !function (e) {\n                    var t = e.callback,\n                      r = e.args;\n                    switch (r.length) {\n                      case 0:\n                        t();\n                        break;\n                      case 1:\n                        t(r[0]);\n                        break;\n                      case 2:\n                        t(r[0], r[1]);\n                        break;\n                      case 3:\n                        t(r[0], r[1], r[2]);\n                        break;\n                      default:\n                        t.apply(void 0, r);\n                    }\n                  }(t);\n                } finally {\n                  f(e), d = !1;\n                }\n              }\n            }\n          }\n        }(\"undefined\" == typeof self ? void 0 === r.g ? this : r.g : self);\n      },\n      9937: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n        const n = r(8381);\n        t.default = {\n          encodeEventSignature: n.encodeEventSignature,\n          encodeFunctionCall: n.encodeFunctionCall,\n          encodeFunctionSignature: n.encodeFunctionSignature,\n          encodeParameter: n.encodeParameter,\n          encodeParameters: n.encodeParameters,\n          decodeParameter: n.decodeParameter,\n          decodeParameters: n.decodeParameters,\n          decodeLog: n.decodeLog\n        };\n      },\n      1186: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.initAccountsForContext = void 0;\n        const o = r(9970),\n          i = r(9634),\n          s = r(6637),\n          a = r(9247);\n        t.initAccountsForContext = e => {\n          const t = (t, r) => n(void 0, void 0, void 0, function* () {\n              const n = yield (0, s.prepareTransactionForSigning)(t, e),\n                c = (0, i.format)({\n                  format: \"bytes\"\n                }, r, o.ETH_DATA_FORMAT);\n              return (0, a.signTransaction)(n, c);\n            }),\n            r = e => {\n              const r = (0, a.privateKeyToAccount)(e);\n              return Object.assign(Object.assign({}, r), {\n                signTransaction: e => n(void 0, void 0, void 0, function* () {\n                  return t(e, r.privateKey);\n                })\n              });\n            },\n            c = (e, r, o) => n(void 0, void 0, void 0, function* () {\n              var i;\n              const s = yield (0, a.decrypt)(e, r, null === (i = null == o ? void 0 : o.nonStrict) || void 0 === i || i);\n              return Object.assign(Object.assign({}, s), {\n                signTransaction: e => n(void 0, void 0, void 0, function* () {\n                  return t(e, s.privateKey);\n                })\n              });\n            }),\n            u = () => {\n              const e = (0, a.create)();\n              return Object.assign(Object.assign({}, e), {\n                signTransaction: r => n(void 0, void 0, void 0, function* () {\n                  return t(r, e.privateKey);\n                })\n              });\n            },\n            d = new a.Wallet({\n              create: u,\n              privateKeyToAccount: r,\n              decrypt: c\n            });\n          return {\n            signTransaction: t,\n            create: u,\n            privateKeyToAccount: r,\n            decrypt: c,\n            recoverTransaction: a.recoverTransaction,\n            hashMessage: a.hashMessage,\n            sign: a.sign,\n            recover: a.recover,\n            encrypt: a.encrypt,\n            wallet: d,\n            privateKeyToAddress: a.privateKeyToAddress,\n            parseAndValidatePrivateKey: a.parseAndValidatePrivateKey,\n            privateKeyToPublicKey: a.privateKeyToPublicKey\n          };\n        };\n      },\n      9913: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3PkgInfo = void 0, t.Web3PkgInfo = {\n          version: \"4.10.0\"\n        };\n      },\n      9375: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          i = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return o(t, e), t;\n          },\n          s = this && this.__importDefault || function (e) {\n            return e && e.__esModule ? e : {\n              default: e\n            };\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3 = void 0;\n        const a = r(6527),\n          c = r(6637),\n          u = s(r(3211)),\n          d = r(1698),\n          l = r(9910),\n          h = r(9757),\n          f = r(9820),\n          p = i(r(9634)),\n          m = r(9634),\n          g = r(294),\n          y = r(5071),\n          v = s(r(9937)),\n          b = r(1186),\n          E = r(9913),\n          _ = r(7632);\n        class A extends a.Web3Context {\n          constructor(e = g.mainnet) {\n            var t;\n            ((0, m.isNullish)(e) || \"string\" == typeof e && \"\" === e.trim() || \"string\" != typeof e && !(0, a.isSupportedProvider)(e) && !e.provider) && console.warn(\"NOTE: web3.js is running without provider. You need to pass a provider in order to interact with the network!\");\n            let r = {};\n            \"string\" == typeof e || (0, a.isSupportedProvider)(e) ? r.provider = e : r = e || {}, r.registeredSubscriptions = Object.assign(Object.assign({}, c.registeredSubscriptions), null !== (t = r.registeredSubscriptions) && void 0 !== t ? t : {}), super(r);\n            const n = (0, b.initAccountsForContext)(this);\n            this._wallet = n.wallet, this._accountProvider = n, this.utils = p;\n            const o = this;\n            class i extends u.default {\n              constructor(e, t, r, n, i) {\n                if ((0, m.isContractInitOptions)(t) && (0, m.isContractInitOptions)(r)) throw new y.InvalidMethodParamsError(\"Should not provide options at both 2nd and 3rd parameters\");\n                let s,\n                  c,\n                  u,\n                  d = {};\n                if (!(0, m.isNullish)(t) && \"object\" != typeof t && \"string\" != typeof t) throw new y.InvalidMethodParamsError();\n                \"string\" == typeof t && (s = t), d = (0, m.isContractInitOptions)(t) ? t : (0, m.isContractInitOptions)(r) ? r : {}, c = t instanceof a.Web3Context ? t : r instanceof a.Web3Context ? r : n instanceof a.Web3Context ? n : o.getContextObject(), i ? u = i : (0, m.isDataFormat)(r) ? u = r : (0, m.isDataFormat)(n) && (u = n), super(e, s, d, c, u), super.subscribeToContextEvents(o);\n              }\n            }\n            const s = o.use(c.Web3Eth);\n            this.eth = Object.assign(s, {\n              ens: o.use(d.ENS, d.registryAddresses.main),\n              Iban: l.Iban,\n              net: o.use(f.Net),\n              personal: o.use(h.Personal),\n              Contract: i,\n              abi: v.default,\n              accounts: n\n            });\n          }\n        }\n        t.Web3 = A, A.version = E.Web3PkgInfo.version, A.utils = p, A.requestEIP6963Providers = _.requestEIP6963Providers, A.onNewProviderDiscovered = _.onNewProviderDiscovered, A.modules = {\n          Web3Eth: c.Web3Eth,\n          Iban: l.Iban,\n          Net: f.Net,\n          ENS: d.ENS,\n          Personal: h.Personal\n        }, t.default = A;\n      },\n      7632: function (e, t) {\n        \"use strict\";\n\n        var r,\n          n = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (o, i) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.onNewProviderDiscovered = t.requestEIP6963Providers = t.web3ProvidersMapUpdated = t.eip6963ProvidersMap = t.Eip6963EventName = void 0, function (e) {\n          e.eip6963announceProvider = \"eip6963:announceProvider\", e.eip6963requestProvider = \"eip6963:requestProvider\";\n        }(r = t.Eip6963EventName || (t.Eip6963EventName = {})), t.eip6963ProvidersMap = new Map(), t.web3ProvidersMapUpdated = \"web3:providersMapUpdated\", t.requestEIP6963Providers = () => n(void 0, void 0, void 0, function* () {\n          return new Promise((e, n) => {\n            \"undefined\" == typeof window && n(new Error(\"window object not available, EIP-6963 is intended to be used within a browser\")), window.addEventListener(r.eip6963announceProvider, r => {\n              t.eip6963ProvidersMap.set(r.detail.info.uuid, r.detail);\n              const n = new CustomEvent(t.web3ProvidersMapUpdated, {\n                detail: t.eip6963ProvidersMap\n              });\n              window.dispatchEvent(n), e(t.eip6963ProvidersMap);\n            }), window.dispatchEvent(new Event(r.eip6963requestProvider));\n          });\n        }), t.onNewProviderDiscovered = e => {\n          if (\"undefined\" == typeof window) throw new Error(\"window object not available, EIP-6963 is intended to be used within a browser\");\n          window.addEventListener(t.web3ProvidersMapUpdated, e);\n        };\n      },\n      5809: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ZodError = t.quotelessJson = t.ZodIssueCode = void 0;\n        const n = r(3133);\n        t.ZodIssueCode = n.util.arrayToEnum([\"invalid_type\", \"invalid_literal\", \"custom\", \"invalid_union\", \"invalid_union_discriminator\", \"invalid_enum_value\", \"unrecognized_keys\", \"invalid_arguments\", \"invalid_return_type\", \"invalid_date\", \"invalid_string\", \"too_small\", \"too_big\", \"invalid_intersection_types\", \"not_multiple_of\", \"not_finite\"]), t.quotelessJson = e => JSON.stringify(e, null, 2).replace(/\"([^\"]+)\":/g, \"$1:\");\n        class o extends Error {\n          constructor(e) {\n            super(), this.issues = [], this.addIssue = e => {\n              this.issues = [...this.issues, e];\n            }, this.addIssues = (e = []) => {\n              this.issues = [...this.issues, ...e];\n            };\n            const t = new.target.prototype;\n            Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = \"ZodError\", this.issues = e;\n          }\n          get errors() {\n            return this.issues;\n          }\n          format(e) {\n            const t = e || function (e) {\n                return e.message;\n              },\n              r = {\n                _errors: []\n              },\n              n = e => {\n                for (const o of e.issues) if (\"invalid_union\" === o.code) o.unionErrors.map(n);else if (\"invalid_return_type\" === o.code) n(o.returnTypeError);else if (\"invalid_arguments\" === o.code) n(o.argumentsError);else if (0 === o.path.length) r._errors.push(t(o));else {\n                  let e = r,\n                    n = 0;\n                  for (; n < o.path.length;) {\n                    const r = o.path[n];\n                    n === o.path.length - 1 ? (e[r] = e[r] || {\n                      _errors: []\n                    }, e[r]._errors.push(t(o))) : e[r] = e[r] || {\n                      _errors: []\n                    }, e = e[r], n++;\n                  }\n                }\n              };\n            return n(this), r;\n          }\n          toString() {\n            return this.message;\n          }\n          get message() {\n            return JSON.stringify(this.issues, n.util.jsonStringifyReplacer, 2);\n          }\n          get isEmpty() {\n            return 0 === this.issues.length;\n          }\n          flatten(e = e => e.message) {\n            const t = {},\n              r = [];\n            for (const n of this.issues) n.path.length > 0 ? (t[n.path[0]] = t[n.path[0]] || [], t[n.path[0]].push(e(n))) : r.push(e(n));\n            return {\n              formErrors: r,\n              fieldErrors: t\n            };\n          }\n          get formErrors() {\n            return this.flatten();\n          }\n        }\n        t.ZodError = o, o.create = e => new o(e);\n      },\n      1909: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getErrorMap = t.setErrorMap = t.defaultErrorMap = void 0;\n        const o = n(r(6013));\n        t.defaultErrorMap = o.default;\n        let i = o.default;\n        t.setErrorMap = function (e) {\n          i = e;\n        }, t.getErrorMap = function () {\n          return i;\n        };\n      },\n      4474: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r), Object.defineProperty(e, n, {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            });\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), o(r(1909), t), o(r(4735), t), o(r(1832), t), o(r(3133), t), o(r(1176), t), o(r(5809), t);\n      },\n      3682: (e, t) => {\n        \"use strict\";\n\n        var r;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.errorUtil = void 0, (r = t.errorUtil || (t.errorUtil = {})).errToObj = e => \"string\" == typeof e ? {\n          message: e\n        } : e || {}, r.toString = e => \"string\" == typeof e ? e : null == e ? void 0 : e.message;\n      },\n      4735: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isAsync = t.isValid = t.isDirty = t.isAborted = t.OK = t.DIRTY = t.INVALID = t.ParseStatus = t.addIssueToContext = t.EMPTY_PATH = t.makeIssue = void 0;\n        const o = r(1909),\n          i = n(r(6013));\n        t.makeIssue = e => {\n          const {\n              data: t,\n              path: r,\n              errorMaps: n,\n              issueData: o\n            } = e,\n            i = [...r, ...(o.path || [])],\n            s = {\n              ...o,\n              path: i\n            };\n          let a = \"\";\n          const c = n.filter(e => !!e).slice().reverse();\n          for (const e of c) a = e(s, {\n            data: t,\n            defaultError: a\n          }).message;\n          return {\n            ...o,\n            path: i,\n            message: o.message || a\n          };\n        }, t.EMPTY_PATH = [], t.addIssueToContext = function (e, r) {\n          const n = (0, t.makeIssue)({\n            issueData: r,\n            data: e.data,\n            path: e.path,\n            errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, (0, o.getErrorMap)(), i.default].filter(e => !!e)\n          });\n          e.common.issues.push(n);\n        };\n        class s {\n          constructor() {\n            this.value = \"valid\";\n          }\n          dirty() {\n            \"valid\" === this.value && (this.value = \"dirty\");\n          }\n          abort() {\n            \"aborted\" !== this.value && (this.value = \"aborted\");\n          }\n          static mergeArray(e, r) {\n            const n = [];\n            for (const o of r) {\n              if (\"aborted\" === o.status) return t.INVALID;\n              \"dirty\" === o.status && e.dirty(), n.push(o.value);\n            }\n            return {\n              status: e.value,\n              value: n\n            };\n          }\n          static async mergeObjectAsync(e, t) {\n            const r = [];\n            for (const e of t) r.push({\n              key: await e.key,\n              value: await e.value\n            });\n            return s.mergeObjectSync(e, r);\n          }\n          static mergeObjectSync(e, r) {\n            const n = {};\n            for (const o of r) {\n              const {\n                key: r,\n                value: i\n              } = o;\n              if (\"aborted\" === r.status) return t.INVALID;\n              if (\"aborted\" === i.status) return t.INVALID;\n              \"dirty\" === r.status && e.dirty(), \"dirty\" === i.status && e.dirty(), \"__proto__\" === r.value || void 0 === i.value && !o.alwaysSet || (n[r.value] = i.value);\n            }\n            return {\n              status: e.value,\n              value: n\n            };\n          }\n        }\n        t.ParseStatus = s, t.INVALID = Object.freeze({\n          status: \"aborted\"\n        }), t.DIRTY = e => ({\n          status: \"dirty\",\n          value: e\n        }), t.OK = e => ({\n          status: \"valid\",\n          value: e\n        }), t.isAborted = e => \"aborted\" === e.status, t.isDirty = e => \"dirty\" === e.status, t.isValid = e => \"valid\" === e.status, t.isAsync = e => \"undefined\" != typeof Promise && e instanceof Promise;\n      },\n      1832: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      3133: (e, t) => {\n        \"use strict\";\n\n        var r;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getParsedType = t.ZodParsedType = t.objectUtil = t.util = void 0, function (e) {\n          e.assertEqual = e => e, e.assertIs = function (e) {}, e.assertNever = function (e) {\n            throw new Error();\n          }, e.arrayToEnum = e => {\n            const t = {};\n            for (const r of e) t[r] = r;\n            return t;\n          }, e.getValidEnumValues = t => {\n            const r = e.objectKeys(t).filter(e => \"number\" != typeof t[t[e]]),\n              n = {};\n            for (const e of r) n[e] = t[e];\n            return e.objectValues(n);\n          }, e.objectValues = t => e.objectKeys(t).map(function (e) {\n            return t[e];\n          }), e.objectKeys = \"function\" == typeof Object.keys ? e => Object.keys(e) : e => {\n            const t = [];\n            for (const r in e) Object.prototype.hasOwnProperty.call(e, r) && t.push(r);\n            return t;\n          }, e.find = (e, t) => {\n            for (const r of e) if (t(r)) return r;\n          }, e.isInteger = \"function\" == typeof Number.isInteger ? e => Number.isInteger(e) : e => \"number\" == typeof e && isFinite(e) && Math.floor(e) === e, e.joinValues = function (e, t = \" | \") {\n            return e.map(e => \"string\" == typeof e ? `'${e}'` : e).join(t);\n          }, e.jsonStringifyReplacer = (e, t) => \"bigint\" == typeof t ? t.toString() : t;\n        }(r = t.util || (t.util = {})), (t.objectUtil || (t.objectUtil = {})).mergeShapes = (e, t) => ({\n          ...e,\n          ...t\n        }), t.ZodParsedType = r.arrayToEnum([\"string\", \"nan\", \"number\", \"integer\", \"float\", \"boolean\", \"date\", \"bigint\", \"symbol\", \"function\", \"undefined\", \"null\", \"array\", \"object\", \"unknown\", \"promise\", \"void\", \"never\", \"map\", \"set\"]), t.getParsedType = e => {\n          switch (typeof e) {\n            case \"undefined\":\n              return t.ZodParsedType.undefined;\n            case \"string\":\n              return t.ZodParsedType.string;\n            case \"number\":\n              return isNaN(e) ? t.ZodParsedType.nan : t.ZodParsedType.number;\n            case \"boolean\":\n              return t.ZodParsedType.boolean;\n            case \"function\":\n              return t.ZodParsedType.function;\n            case \"bigint\":\n              return t.ZodParsedType.bigint;\n            case \"symbol\":\n              return t.ZodParsedType.symbol;\n            case \"object\":\n              return Array.isArray(e) ? t.ZodParsedType.array : null === e ? t.ZodParsedType.null : e.then && \"function\" == typeof e.then && e.catch && \"function\" == typeof e.catch ? t.ZodParsedType.promise : \"undefined\" != typeof Map && e instanceof Map ? t.ZodParsedType.map : \"undefined\" != typeof Set && e instanceof Set ? t.ZodParsedType.set : \"undefined\" != typeof Date && e instanceof Date ? t.ZodParsedType.date : t.ZodParsedType.object;\n            default:\n              return t.ZodParsedType.unknown;\n          }\n        };\n      },\n      6750: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r), Object.defineProperty(e, n, {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            });\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          i = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return o(t, e), t;\n          },\n          s = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.z = void 0;\n        const a = i(r(4474));\n        t.z = a, s(r(4474), t), t.default = a;\n      },\n      6013: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n        const n = r(3133),\n          o = r(5809);\n        t.default = (e, t) => {\n          let r;\n          switch (e.code) {\n            case o.ZodIssueCode.invalid_type:\n              r = e.received === n.ZodParsedType.undefined ? \"Required\" : `Expected ${e.expected}, received ${e.received}`;\n              break;\n            case o.ZodIssueCode.invalid_literal:\n              r = `Invalid literal value, expected ${JSON.stringify(e.expected, n.util.jsonStringifyReplacer)}`;\n              break;\n            case o.ZodIssueCode.unrecognized_keys:\n              r = `Unrecognized key(s) in object: ${n.util.joinValues(e.keys, \", \")}`;\n              break;\n            case o.ZodIssueCode.invalid_union:\n              r = \"Invalid input\";\n              break;\n            case o.ZodIssueCode.invalid_union_discriminator:\n              r = `Invalid discriminator value. Expected ${n.util.joinValues(e.options)}`;\n              break;\n            case o.ZodIssueCode.invalid_enum_value:\n              r = `Invalid enum value. Expected ${n.util.joinValues(e.options)}, received '${e.received}'`;\n              break;\n            case o.ZodIssueCode.invalid_arguments:\n              r = \"Invalid function arguments\";\n              break;\n            case o.ZodIssueCode.invalid_return_type:\n              r = \"Invalid function return type\";\n              break;\n            case o.ZodIssueCode.invalid_date:\n              r = \"Invalid date\";\n              break;\n            case o.ZodIssueCode.invalid_string:\n              \"object\" == typeof e.validation ? \"includes\" in e.validation ? (r = `Invalid input: must include \"${e.validation.includes}\"`, \"number\" == typeof e.validation.position && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : \"startsWith\" in e.validation ? r = `Invalid input: must start with \"${e.validation.startsWith}\"` : \"endsWith\" in e.validation ? r = `Invalid input: must end with \"${e.validation.endsWith}\"` : n.util.assertNever(e.validation) : r = \"regex\" !== e.validation ? `Invalid ${e.validation}` : \"Invalid\";\n              break;\n            case o.ZodIssueCode.too_small:\n              r = \"array\" === e.type ? `Array must contain ${e.exact ? \"exactly\" : e.inclusive ? \"at least\" : \"more than\"} ${e.minimum} element(s)` : \"string\" === e.type ? `String must contain ${e.exact ? \"exactly\" : e.inclusive ? \"at least\" : \"over\"} ${e.minimum} character(s)` : \"number\" === e.type ? `Number must be ${e.exact ? \"exactly equal to \" : e.inclusive ? \"greater than or equal to \" : \"greater than \"}${e.minimum}` : \"date\" === e.type ? `Date must be ${e.exact ? \"exactly equal to \" : e.inclusive ? \"greater than or equal to \" : \"greater than \"}${new Date(Number(e.minimum))}` : \"Invalid input\";\n              break;\n            case o.ZodIssueCode.too_big:\n              r = \"array\" === e.type ? `Array must contain ${e.exact ? \"exactly\" : e.inclusive ? \"at most\" : \"less than\"} ${e.maximum} element(s)` : \"string\" === e.type ? `String must contain ${e.exact ? \"exactly\" : e.inclusive ? \"at most\" : \"under\"} ${e.maximum} character(s)` : \"number\" === e.type ? `Number must be ${e.exact ? \"exactly\" : e.inclusive ? \"less than or equal to\" : \"less than\"} ${e.maximum}` : \"bigint\" === e.type ? `BigInt must be ${e.exact ? \"exactly\" : e.inclusive ? \"less than or equal to\" : \"less than\"} ${e.maximum}` : \"date\" === e.type ? `Date must be ${e.exact ? \"exactly\" : e.inclusive ? \"smaller than or equal to\" : \"smaller than\"} ${new Date(Number(e.maximum))}` : \"Invalid input\";\n              break;\n            case o.ZodIssueCode.custom:\n              r = \"Invalid input\";\n              break;\n            case o.ZodIssueCode.invalid_intersection_types:\n              r = \"Intersection results could not be merged\";\n              break;\n            case o.ZodIssueCode.not_multiple_of:\n              r = `Number must be a multiple of ${e.multipleOf}`;\n              break;\n            case o.ZodIssueCode.not_finite:\n              r = \"Number must be finite\";\n              break;\n            default:\n              r = t.defaultError, n.util.assertNever(e);\n          }\n          return {\n            message: r\n          };\n        };\n      },\n      1176: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.date = t.boolean = t.bigint = t.array = t.any = t.coerce = t.ZodFirstPartyTypeKind = t.late = t.ZodSchema = t.Schema = t.custom = t.ZodReadonly = t.ZodPipeline = t.ZodBranded = t.BRAND = t.ZodNaN = t.ZodCatch = t.ZodDefault = t.ZodNullable = t.ZodOptional = t.ZodTransformer = t.ZodEffects = t.ZodPromise = t.ZodNativeEnum = t.ZodEnum = t.ZodLiteral = t.ZodLazy = t.ZodFunction = t.ZodSet = t.ZodMap = t.ZodRecord = t.ZodTuple = t.ZodIntersection = t.ZodDiscriminatedUnion = t.ZodUnion = t.ZodObject = t.ZodArray = t.ZodVoid = t.ZodNever = t.ZodUnknown = t.ZodAny = t.ZodNull = t.ZodUndefined = t.ZodSymbol = t.ZodDate = t.ZodBoolean = t.ZodBigInt = t.ZodNumber = t.ZodString = t.ZodType = void 0, t.NEVER = t.void = t.unknown = t.union = t.undefined = t.tuple = t.transformer = t.symbol = t.string = t.strictObject = t.set = t.record = t.promise = t.preprocess = t.pipeline = t.ostring = t.optional = t.onumber = t.oboolean = t.object = t.number = t.nullable = t.null = t.never = t.nativeEnum = t.nan = t.map = t.literal = t.lazy = t.intersection = t.instanceof = t.function = t.enum = t.effect = t.discriminatedUnion = void 0;\n        const n = r(1909),\n          o = r(3682),\n          i = r(4735),\n          s = r(3133),\n          a = r(5809);\n        class c {\n          constructor(e, t, r, n) {\n            this._cachedPath = [], this.parent = e, this.data = t, this._path = r, this._key = n;\n          }\n          get path() {\n            return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;\n          }\n        }\n        const u = (e, t) => {\n          if ((0, i.isValid)(t)) return {\n            success: !0,\n            data: t.value\n          };\n          if (!e.common.issues.length) throw new Error(\"Validation failed but no issues detected.\");\n          return {\n            success: !1,\n            get error() {\n              if (this._error) return this._error;\n              const t = new a.ZodError(e.common.issues);\n              return this._error = t, this._error;\n            }\n          };\n        };\n        function d(e) {\n          if (!e) return {};\n          const {\n            errorMap: t,\n            invalid_type_error: r,\n            required_error: n,\n            description: o\n          } = e;\n          if (t && (r || n)) throw new Error('Can\\'t use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.');\n          return t ? {\n            errorMap: t,\n            description: o\n          } : {\n            errorMap: (e, t) => \"invalid_type\" !== e.code ? {\n              message: t.defaultError\n            } : void 0 === t.data ? {\n              message: null != n ? n : t.defaultError\n            } : {\n              message: null != r ? r : t.defaultError\n            },\n            description: o\n          };\n        }\n        class l {\n          constructor(e) {\n            this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);\n          }\n          get description() {\n            return this._def.description;\n          }\n          _getType(e) {\n            return (0, s.getParsedType)(e.data);\n          }\n          _getOrReturnCtx(e, t) {\n            return t || {\n              common: e.parent.common,\n              data: e.data,\n              parsedType: (0, s.getParsedType)(e.data),\n              schemaErrorMap: this._def.errorMap,\n              path: e.path,\n              parent: e.parent\n            };\n          }\n          _processInputParams(e) {\n            return {\n              status: new i.ParseStatus(),\n              ctx: {\n                common: e.parent.common,\n                data: e.data,\n                parsedType: (0, s.getParsedType)(e.data),\n                schemaErrorMap: this._def.errorMap,\n                path: e.path,\n                parent: e.parent\n              }\n            };\n          }\n          _parseSync(e) {\n            const t = this._parse(e);\n            if ((0, i.isAsync)(t)) throw new Error(\"Synchronous parse encountered promise.\");\n            return t;\n          }\n          _parseAsync(e) {\n            const t = this._parse(e);\n            return Promise.resolve(t);\n          }\n          parse(e, t) {\n            const r = this.safeParse(e, t);\n            if (r.success) return r.data;\n            throw r.error;\n          }\n          safeParse(e, t) {\n            var r;\n            const n = {\n                common: {\n                  issues: [],\n                  async: null !== (r = null == t ? void 0 : t.async) && void 0 !== r && r,\n                  contextualErrorMap: null == t ? void 0 : t.errorMap\n                },\n                path: (null == t ? void 0 : t.path) || [],\n                schemaErrorMap: this._def.errorMap,\n                parent: null,\n                data: e,\n                parsedType: (0, s.getParsedType)(e)\n              },\n              o = this._parseSync({\n                data: e,\n                path: n.path,\n                parent: n\n              });\n            return u(n, o);\n          }\n          async parseAsync(e, t) {\n            const r = await this.safeParseAsync(e, t);\n            if (r.success) return r.data;\n            throw r.error;\n          }\n          async safeParseAsync(e, t) {\n            const r = {\n                common: {\n                  issues: [],\n                  contextualErrorMap: null == t ? void 0 : t.errorMap,\n                  async: !0\n                },\n                path: (null == t ? void 0 : t.path) || [],\n                schemaErrorMap: this._def.errorMap,\n                parent: null,\n                data: e,\n                parsedType: (0, s.getParsedType)(e)\n              },\n              n = this._parse({\n                data: e,\n                path: r.path,\n                parent: r\n              }),\n              o = await ((0, i.isAsync)(n) ? n : Promise.resolve(n));\n            return u(r, o);\n          }\n          refine(e, t) {\n            const r = e => \"string\" == typeof t || void 0 === t ? {\n              message: t\n            } : \"function\" == typeof t ? t(e) : t;\n            return this._refinement((t, n) => {\n              const o = e(t),\n                i = () => n.addIssue({\n                  code: a.ZodIssueCode.custom,\n                  ...r(t)\n                });\n              return \"undefined\" != typeof Promise && o instanceof Promise ? o.then(e => !!e || (i(), !1)) : !!o || (i(), !1);\n            });\n          }\n          refinement(e, t) {\n            return this._refinement((r, n) => !!e(r) || (n.addIssue(\"function\" == typeof t ? t(r, n) : t), !1));\n          }\n          _refinement(e) {\n            return new Y({\n              schema: this,\n              typeName: ae.ZodEffects,\n              effect: {\n                type: \"refinement\",\n                refinement: e\n              }\n            });\n          }\n          superRefine(e) {\n            return this._refinement(e);\n          }\n          optional() {\n            return $.create(this, this._def);\n          }\n          nullable() {\n            return ee.create(this, this._def);\n          }\n          nullish() {\n            return this.nullable().optional();\n          }\n          array() {\n            return k.create(this, this._def);\n          }\n          promise() {\n            return J.create(this, this._def);\n          }\n          or(e) {\n            return L.create([this, e], this._def);\n          }\n          and(e) {\n            return j.create(this, e, this._def);\n          }\n          transform(e) {\n            return new Y({\n              ...d(this._def),\n              schema: this,\n              typeName: ae.ZodEffects,\n              effect: {\n                type: \"transform\",\n                transform: e\n              }\n            });\n          }\n          default(e) {\n            const t = \"function\" == typeof e ? e : () => e;\n            return new te({\n              ...d(this._def),\n              innerType: this,\n              defaultValue: t,\n              typeName: ae.ZodDefault\n            });\n          }\n          brand() {\n            return new oe({\n              typeName: ae.ZodBranded,\n              type: this,\n              ...d(this._def)\n            });\n          }\n          catch(e) {\n            const t = \"function\" == typeof e ? e : () => e;\n            return new re({\n              ...d(this._def),\n              innerType: this,\n              catchValue: t,\n              typeName: ae.ZodCatch\n            });\n          }\n          describe(e) {\n            return new (0, this.constructor)({\n              ...this._def,\n              description: e\n            });\n          }\n          pipe(e) {\n            return ie.create(this, e);\n          }\n          readonly() {\n            return se.create(this);\n          }\n          isOptional() {\n            return this.safeParse(void 0).success;\n          }\n          isNullable() {\n            return this.safeParse(null).success;\n          }\n        }\n        t.ZodType = l, t.Schema = l, t.ZodSchema = l;\n        const h = /^c[^\\s-]{8,}$/i,\n          f = /^[a-z][a-z0-9]*$/,\n          p = /[0-9A-HJKMNP-TV-Z]{26}/,\n          m = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i,\n          g = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_+-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i,\n          y = /^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$/u,\n          v = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/,\n          b = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\n        class E extends l {\n          constructor() {\n            super(...arguments), this._regex = (e, t, r) => this.refinement(t => e.test(t), {\n              validation: t,\n              code: a.ZodIssueCode.invalid_string,\n              ...o.errorUtil.errToObj(r)\n            }), this.nonempty = e => this.min(1, o.errorUtil.errToObj(e)), this.trim = () => new E({\n              ...this._def,\n              checks: [...this._def.checks, {\n                kind: \"trim\"\n              }]\n            }), this.toLowerCase = () => new E({\n              ...this._def,\n              checks: [...this._def.checks, {\n                kind: \"toLowerCase\"\n              }]\n            }), this.toUpperCase = () => new E({\n              ...this._def,\n              checks: [...this._def.checks, {\n                kind: \"toUpperCase\"\n              }]\n            });\n          }\n          _parse(e) {\n            if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== s.ZodParsedType.string) {\n              const t = this._getOrReturnCtx(e);\n              return (0, i.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.string,\n                received: t.parsedType\n              }), i.INVALID;\n            }\n            const t = new i.ParseStatus();\n            let r;\n            for (const u of this._def.checks) if (\"min\" === u.kind) e.data.length < u.value && (r = this._getOrReturnCtx(e, r), (0, i.addIssueToContext)(r, {\n              code: a.ZodIssueCode.too_small,\n              minimum: u.value,\n              type: \"string\",\n              inclusive: !0,\n              exact: !1,\n              message: u.message\n            }), t.dirty());else if (\"max\" === u.kind) e.data.length > u.value && (r = this._getOrReturnCtx(e, r), (0, i.addIssueToContext)(r, {\n              code: a.ZodIssueCode.too_big,\n              maximum: u.value,\n              type: \"string\",\n              inclusive: !0,\n              exact: !1,\n              message: u.message\n            }), t.dirty());else if (\"length\" === u.kind) {\n              const n = e.data.length > u.value,\n                o = e.data.length < u.value;\n              (n || o) && (r = this._getOrReturnCtx(e, r), n ? (0, i.addIssueToContext)(r, {\n                code: a.ZodIssueCode.too_big,\n                maximum: u.value,\n                type: \"string\",\n                inclusive: !0,\n                exact: !0,\n                message: u.message\n              }) : o && (0, i.addIssueToContext)(r, {\n                code: a.ZodIssueCode.too_small,\n                minimum: u.value,\n                type: \"string\",\n                inclusive: !0,\n                exact: !0,\n                message: u.message\n              }), t.dirty());\n            } else if (\"email\" === u.kind) g.test(e.data) || (r = this._getOrReturnCtx(e, r), (0, i.addIssueToContext)(r, {\n              validation: \"email\",\n              code: a.ZodIssueCode.invalid_string,\n              message: u.message\n            }), t.dirty());else if (\"emoji\" === u.kind) y.test(e.data) || (r = this._getOrReturnCtx(e, r), (0, i.addIssueToContext)(r, {\n              validation: \"emoji\",\n              code: a.ZodIssueCode.invalid_string,\n              message: u.message\n            }), t.dirty());else if (\"uuid\" === u.kind) m.test(e.data) || (r = this._getOrReturnCtx(e, r), (0, i.addIssueToContext)(r, {\n              validation: \"uuid\",\n              code: a.ZodIssueCode.invalid_string,\n              message: u.message\n            }), t.dirty());else if (\"cuid\" === u.kind) h.test(e.data) || (r = this._getOrReturnCtx(e, r), (0, i.addIssueToContext)(r, {\n              validation: \"cuid\",\n              code: a.ZodIssueCode.invalid_string,\n              message: u.message\n            }), t.dirty());else if (\"cuid2\" === u.kind) f.test(e.data) || (r = this._getOrReturnCtx(e, r), (0, i.addIssueToContext)(r, {\n              validation: \"cuid2\",\n              code: a.ZodIssueCode.invalid_string,\n              message: u.message\n            }), t.dirty());else if (\"ulid\" === u.kind) p.test(e.data) || (r = this._getOrReturnCtx(e, r), (0, i.addIssueToContext)(r, {\n              validation: \"ulid\",\n              code: a.ZodIssueCode.invalid_string,\n              message: u.message\n            }), t.dirty());else if (\"url\" === u.kind) try {\n              new URL(e.data);\n            } catch (n) {\n              r = this._getOrReturnCtx(e, r), (0, i.addIssueToContext)(r, {\n                validation: \"url\",\n                code: a.ZodIssueCode.invalid_string,\n                message: u.message\n              }), t.dirty();\n            } else \"regex\" === u.kind ? (u.regex.lastIndex = 0, u.regex.test(e.data) || (r = this._getOrReturnCtx(e, r), (0, i.addIssueToContext)(r, {\n              validation: \"regex\",\n              code: a.ZodIssueCode.invalid_string,\n              message: u.message\n            }), t.dirty())) : \"trim\" === u.kind ? e.data = e.data.trim() : \"includes\" === u.kind ? e.data.includes(u.value, u.position) || (r = this._getOrReturnCtx(e, r), (0, i.addIssueToContext)(r, {\n              code: a.ZodIssueCode.invalid_string,\n              validation: {\n                includes: u.value,\n                position: u.position\n              },\n              message: u.message\n            }), t.dirty()) : \"toLowerCase\" === u.kind ? e.data = e.data.toLowerCase() : \"toUpperCase\" === u.kind ? e.data = e.data.toUpperCase() : \"startsWith\" === u.kind ? e.data.startsWith(u.value) || (r = this._getOrReturnCtx(e, r), (0, i.addIssueToContext)(r, {\n              code: a.ZodIssueCode.invalid_string,\n              validation: {\n                startsWith: u.value\n              },\n              message: u.message\n            }), t.dirty()) : \"endsWith\" === u.kind ? e.data.endsWith(u.value) || (r = this._getOrReturnCtx(e, r), (0, i.addIssueToContext)(r, {\n              code: a.ZodIssueCode.invalid_string,\n              validation: {\n                endsWith: u.value\n              },\n              message: u.message\n            }), t.dirty()) : \"datetime\" === u.kind ? ((c = u).precision ? c.offset ? new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${c.precision}}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`) : new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${c.precision}}Z$`) : 0 === c.precision ? c.offset ? new RegExp(\"^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$\") : new RegExp(\"^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}Z$\") : c.offset ? new RegExp(\"^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$\") : new RegExp(\"^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?Z$\")).test(e.data) || (r = this._getOrReturnCtx(e, r), (0, i.addIssueToContext)(r, {\n              code: a.ZodIssueCode.invalid_string,\n              validation: \"datetime\",\n              message: u.message\n            }), t.dirty()) : \"ip\" === u.kind ? (n = e.data, (\"v4\" !== (o = u.version) && o || !v.test(n)) && (\"v6\" !== o && o || !b.test(n)) && (r = this._getOrReturnCtx(e, r), (0, i.addIssueToContext)(r, {\n              validation: \"ip\",\n              code: a.ZodIssueCode.invalid_string,\n              message: u.message\n            }), t.dirty())) : s.util.assertNever(u);\n            var n, o, c;\n            return {\n              status: t.value,\n              value: e.data\n            };\n          }\n          _addCheck(e) {\n            return new E({\n              ...this._def,\n              checks: [...this._def.checks, e]\n            });\n          }\n          email(e) {\n            return this._addCheck({\n              kind: \"email\",\n              ...o.errorUtil.errToObj(e)\n            });\n          }\n          url(e) {\n            return this._addCheck({\n              kind: \"url\",\n              ...o.errorUtil.errToObj(e)\n            });\n          }\n          emoji(e) {\n            return this._addCheck({\n              kind: \"emoji\",\n              ...o.errorUtil.errToObj(e)\n            });\n          }\n          uuid(e) {\n            return this._addCheck({\n              kind: \"uuid\",\n              ...o.errorUtil.errToObj(e)\n            });\n          }\n          cuid(e) {\n            return this._addCheck({\n              kind: \"cuid\",\n              ...o.errorUtil.errToObj(e)\n            });\n          }\n          cuid2(e) {\n            return this._addCheck({\n              kind: \"cuid2\",\n              ...o.errorUtil.errToObj(e)\n            });\n          }\n          ulid(e) {\n            return this._addCheck({\n              kind: \"ulid\",\n              ...o.errorUtil.errToObj(e)\n            });\n          }\n          ip(e) {\n            return this._addCheck({\n              kind: \"ip\",\n              ...o.errorUtil.errToObj(e)\n            });\n          }\n          datetime(e) {\n            var t;\n            return \"string\" == typeof e ? this._addCheck({\n              kind: \"datetime\",\n              precision: null,\n              offset: !1,\n              message: e\n            }) : this._addCheck({\n              kind: \"datetime\",\n              precision: void 0 === (null == e ? void 0 : e.precision) ? null : null == e ? void 0 : e.precision,\n              offset: null !== (t = null == e ? void 0 : e.offset) && void 0 !== t && t,\n              ...o.errorUtil.errToObj(null == e ? void 0 : e.message)\n            });\n          }\n          regex(e, t) {\n            return this._addCheck({\n              kind: \"regex\",\n              regex: e,\n              ...o.errorUtil.errToObj(t)\n            });\n          }\n          includes(e, t) {\n            return this._addCheck({\n              kind: \"includes\",\n              value: e,\n              position: null == t ? void 0 : t.position,\n              ...o.errorUtil.errToObj(null == t ? void 0 : t.message)\n            });\n          }\n          startsWith(e, t) {\n            return this._addCheck({\n              kind: \"startsWith\",\n              value: e,\n              ...o.errorUtil.errToObj(t)\n            });\n          }\n          endsWith(e, t) {\n            return this._addCheck({\n              kind: \"endsWith\",\n              value: e,\n              ...o.errorUtil.errToObj(t)\n            });\n          }\n          min(e, t) {\n            return this._addCheck({\n              kind: \"min\",\n              value: e,\n              ...o.errorUtil.errToObj(t)\n            });\n          }\n          max(e, t) {\n            return this._addCheck({\n              kind: \"max\",\n              value: e,\n              ...o.errorUtil.errToObj(t)\n            });\n          }\n          length(e, t) {\n            return this._addCheck({\n              kind: \"length\",\n              value: e,\n              ...o.errorUtil.errToObj(t)\n            });\n          }\n          get isDatetime() {\n            return !!this._def.checks.find(e => \"datetime\" === e.kind);\n          }\n          get isEmail() {\n            return !!this._def.checks.find(e => \"email\" === e.kind);\n          }\n          get isURL() {\n            return !!this._def.checks.find(e => \"url\" === e.kind);\n          }\n          get isEmoji() {\n            return !!this._def.checks.find(e => \"emoji\" === e.kind);\n          }\n          get isUUID() {\n            return !!this._def.checks.find(e => \"uuid\" === e.kind);\n          }\n          get isCUID() {\n            return !!this._def.checks.find(e => \"cuid\" === e.kind);\n          }\n          get isCUID2() {\n            return !!this._def.checks.find(e => \"cuid2\" === e.kind);\n          }\n          get isULID() {\n            return !!this._def.checks.find(e => \"ulid\" === e.kind);\n          }\n          get isIP() {\n            return !!this._def.checks.find(e => \"ip\" === e.kind);\n          }\n          get minLength() {\n            let e = null;\n            for (const t of this._def.checks) \"min\" === t.kind && (null === e || t.value > e) && (e = t.value);\n            return e;\n          }\n          get maxLength() {\n            let e = null;\n            for (const t of this._def.checks) \"max\" === t.kind && (null === e || t.value < e) && (e = t.value);\n            return e;\n          }\n        }\n        function _(e, t) {\n          const r = (e.toString().split(\".\")[1] || \"\").length,\n            n = (t.toString().split(\".\")[1] || \"\").length,\n            o = r > n ? r : n;\n          return parseInt(e.toFixed(o).replace(\".\", \"\")) % parseInt(t.toFixed(o).replace(\".\", \"\")) / Math.pow(10, o);\n        }\n        t.ZodString = E, E.create = e => {\n          var t;\n          return new E({\n            checks: [],\n            typeName: ae.ZodString,\n            coerce: null !== (t = null == e ? void 0 : e.coerce) && void 0 !== t && t,\n            ...d(e)\n          });\n        };\n        class A extends l {\n          constructor() {\n            super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;\n          }\n          _parse(e) {\n            if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== s.ZodParsedType.number) {\n              const t = this._getOrReturnCtx(e);\n              return (0, i.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.number,\n                received: t.parsedType\n              }), i.INVALID;\n            }\n            let t;\n            const r = new i.ParseStatus();\n            for (const n of this._def.checks) \"int\" === n.kind ? s.util.isInteger(e.data) || (t = this._getOrReturnCtx(e, t), (0, i.addIssueToContext)(t, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: \"integer\",\n              received: \"float\",\n              message: n.message\n            }), r.dirty()) : \"min\" === n.kind ? (n.inclusive ? e.data < n.value : e.data <= n.value) && (t = this._getOrReturnCtx(e, t), (0, i.addIssueToContext)(t, {\n              code: a.ZodIssueCode.too_small,\n              minimum: n.value,\n              type: \"number\",\n              inclusive: n.inclusive,\n              exact: !1,\n              message: n.message\n            }), r.dirty()) : \"max\" === n.kind ? (n.inclusive ? e.data > n.value : e.data >= n.value) && (t = this._getOrReturnCtx(e, t), (0, i.addIssueToContext)(t, {\n              code: a.ZodIssueCode.too_big,\n              maximum: n.value,\n              type: \"number\",\n              inclusive: n.inclusive,\n              exact: !1,\n              message: n.message\n            }), r.dirty()) : \"multipleOf\" === n.kind ? 0 !== _(e.data, n.value) && (t = this._getOrReturnCtx(e, t), (0, i.addIssueToContext)(t, {\n              code: a.ZodIssueCode.not_multiple_of,\n              multipleOf: n.value,\n              message: n.message\n            }), r.dirty()) : \"finite\" === n.kind ? Number.isFinite(e.data) || (t = this._getOrReturnCtx(e, t), (0, i.addIssueToContext)(t, {\n              code: a.ZodIssueCode.not_finite,\n              message: n.message\n            }), r.dirty()) : s.util.assertNever(n);\n            return {\n              status: r.value,\n              value: e.data\n            };\n          }\n          gte(e, t) {\n            return this.setLimit(\"min\", e, !0, o.errorUtil.toString(t));\n          }\n          gt(e, t) {\n            return this.setLimit(\"min\", e, !1, o.errorUtil.toString(t));\n          }\n          lte(e, t) {\n            return this.setLimit(\"max\", e, !0, o.errorUtil.toString(t));\n          }\n          lt(e, t) {\n            return this.setLimit(\"max\", e, !1, o.errorUtil.toString(t));\n          }\n          setLimit(e, t, r, n) {\n            return new A({\n              ...this._def,\n              checks: [...this._def.checks, {\n                kind: e,\n                value: t,\n                inclusive: r,\n                message: o.errorUtil.toString(n)\n              }]\n            });\n          }\n          _addCheck(e) {\n            return new A({\n              ...this._def,\n              checks: [...this._def.checks, e]\n            });\n          }\n          int(e) {\n            return this._addCheck({\n              kind: \"int\",\n              message: o.errorUtil.toString(e)\n            });\n          }\n          positive(e) {\n            return this._addCheck({\n              kind: \"min\",\n              value: 0,\n              inclusive: !1,\n              message: o.errorUtil.toString(e)\n            });\n          }\n          negative(e) {\n            return this._addCheck({\n              kind: \"max\",\n              value: 0,\n              inclusive: !1,\n              message: o.errorUtil.toString(e)\n            });\n          }\n          nonpositive(e) {\n            return this._addCheck({\n              kind: \"max\",\n              value: 0,\n              inclusive: !0,\n              message: o.errorUtil.toString(e)\n            });\n          }\n          nonnegative(e) {\n            return this._addCheck({\n              kind: \"min\",\n              value: 0,\n              inclusive: !0,\n              message: o.errorUtil.toString(e)\n            });\n          }\n          multipleOf(e, t) {\n            return this._addCheck({\n              kind: \"multipleOf\",\n              value: e,\n              message: o.errorUtil.toString(t)\n            });\n          }\n          finite(e) {\n            return this._addCheck({\n              kind: \"finite\",\n              message: o.errorUtil.toString(e)\n            });\n          }\n          safe(e) {\n            return this._addCheck({\n              kind: \"min\",\n              inclusive: !0,\n              value: Number.MIN_SAFE_INTEGER,\n              message: o.errorUtil.toString(e)\n            })._addCheck({\n              kind: \"max\",\n              inclusive: !0,\n              value: Number.MAX_SAFE_INTEGER,\n              message: o.errorUtil.toString(e)\n            });\n          }\n          get minValue() {\n            let e = null;\n            for (const t of this._def.checks) \"min\" === t.kind && (null === e || t.value > e) && (e = t.value);\n            return e;\n          }\n          get maxValue() {\n            let e = null;\n            for (const t of this._def.checks) \"max\" === t.kind && (null === e || t.value < e) && (e = t.value);\n            return e;\n          }\n          get isInt() {\n            return !!this._def.checks.find(e => \"int\" === e.kind || \"multipleOf\" === e.kind && s.util.isInteger(e.value));\n          }\n          get isFinite() {\n            let e = null,\n              t = null;\n            for (const r of this._def.checks) {\n              if (\"finite\" === r.kind || \"int\" === r.kind || \"multipleOf\" === r.kind) return !0;\n              \"min\" === r.kind ? (null === t || r.value > t) && (t = r.value) : \"max\" === r.kind && (null === e || r.value < e) && (e = r.value);\n            }\n            return Number.isFinite(t) && Number.isFinite(e);\n          }\n        }\n        t.ZodNumber = A, A.create = e => new A({\n          checks: [],\n          typeName: ae.ZodNumber,\n          coerce: (null == e ? void 0 : e.coerce) || !1,\n          ...d(e)\n        });\n        class T extends l {\n          constructor() {\n            super(...arguments), this.min = this.gte, this.max = this.lte;\n          }\n          _parse(e) {\n            if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== s.ZodParsedType.bigint) {\n              const t = this._getOrReturnCtx(e);\n              return (0, i.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.bigint,\n                received: t.parsedType\n              }), i.INVALID;\n            }\n            let t;\n            const r = new i.ParseStatus();\n            for (const n of this._def.checks) \"min\" === n.kind ? (n.inclusive ? e.data < n.value : e.data <= n.value) && (t = this._getOrReturnCtx(e, t), (0, i.addIssueToContext)(t, {\n              code: a.ZodIssueCode.too_small,\n              type: \"bigint\",\n              minimum: n.value,\n              inclusive: n.inclusive,\n              message: n.message\n            }), r.dirty()) : \"max\" === n.kind ? (n.inclusive ? e.data > n.value : e.data >= n.value) && (t = this._getOrReturnCtx(e, t), (0, i.addIssueToContext)(t, {\n              code: a.ZodIssueCode.too_big,\n              type: \"bigint\",\n              maximum: n.value,\n              inclusive: n.inclusive,\n              message: n.message\n            }), r.dirty()) : \"multipleOf\" === n.kind ? e.data % n.value !== BigInt(0) && (t = this._getOrReturnCtx(e, t), (0, i.addIssueToContext)(t, {\n              code: a.ZodIssueCode.not_multiple_of,\n              multipleOf: n.value,\n              message: n.message\n            }), r.dirty()) : s.util.assertNever(n);\n            return {\n              status: r.value,\n              value: e.data\n            };\n          }\n          gte(e, t) {\n            return this.setLimit(\"min\", e, !0, o.errorUtil.toString(t));\n          }\n          gt(e, t) {\n            return this.setLimit(\"min\", e, !1, o.errorUtil.toString(t));\n          }\n          lte(e, t) {\n            return this.setLimit(\"max\", e, !0, o.errorUtil.toString(t));\n          }\n          lt(e, t) {\n            return this.setLimit(\"max\", e, !1, o.errorUtil.toString(t));\n          }\n          setLimit(e, t, r, n) {\n            return new T({\n              ...this._def,\n              checks: [...this._def.checks, {\n                kind: e,\n                value: t,\n                inclusive: r,\n                message: o.errorUtil.toString(n)\n              }]\n            });\n          }\n          _addCheck(e) {\n            return new T({\n              ...this._def,\n              checks: [...this._def.checks, e]\n            });\n          }\n          positive(e) {\n            return this._addCheck({\n              kind: \"min\",\n              value: BigInt(0),\n              inclusive: !1,\n              message: o.errorUtil.toString(e)\n            });\n          }\n          negative(e) {\n            return this._addCheck({\n              kind: \"max\",\n              value: BigInt(0),\n              inclusive: !1,\n              message: o.errorUtil.toString(e)\n            });\n          }\n          nonpositive(e) {\n            return this._addCheck({\n              kind: \"max\",\n              value: BigInt(0),\n              inclusive: !0,\n              message: o.errorUtil.toString(e)\n            });\n          }\n          nonnegative(e) {\n            return this._addCheck({\n              kind: \"min\",\n              value: BigInt(0),\n              inclusive: !0,\n              message: o.errorUtil.toString(e)\n            });\n          }\n          multipleOf(e, t) {\n            return this._addCheck({\n              kind: \"multipleOf\",\n              value: e,\n              message: o.errorUtil.toString(t)\n            });\n          }\n          get minValue() {\n            let e = null;\n            for (const t of this._def.checks) \"min\" === t.kind && (null === e || t.value > e) && (e = t.value);\n            return e;\n          }\n          get maxValue() {\n            let e = null;\n            for (const t of this._def.checks) \"max\" === t.kind && (null === e || t.value < e) && (e = t.value);\n            return e;\n          }\n        }\n        t.ZodBigInt = T, T.create = e => {\n          var t;\n          return new T({\n            checks: [],\n            typeName: ae.ZodBigInt,\n            coerce: null !== (t = null == e ? void 0 : e.coerce) && void 0 !== t && t,\n            ...d(e)\n          });\n        };\n        class w extends l {\n          _parse(e) {\n            if (this._def.coerce && (e.data = Boolean(e.data)), this._getType(e) !== s.ZodParsedType.boolean) {\n              const t = this._getOrReturnCtx(e);\n              return (0, i.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.boolean,\n                received: t.parsedType\n              }), i.INVALID;\n            }\n            return (0, i.OK)(e.data);\n          }\n        }\n        t.ZodBoolean = w, w.create = e => new w({\n          typeName: ae.ZodBoolean,\n          coerce: (null == e ? void 0 : e.coerce) || !1,\n          ...d(e)\n        });\n        class I extends l {\n          _parse(e) {\n            if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== s.ZodParsedType.date) {\n              const t = this._getOrReturnCtx(e);\n              return (0, i.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.date,\n                received: t.parsedType\n              }), i.INVALID;\n            }\n            if (isNaN(e.data.getTime())) {\n              const t = this._getOrReturnCtx(e);\n              return (0, i.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_date\n              }), i.INVALID;\n            }\n            const t = new i.ParseStatus();\n            let r;\n            for (const n of this._def.checks) \"min\" === n.kind ? e.data.getTime() < n.value && (r = this._getOrReturnCtx(e, r), (0, i.addIssueToContext)(r, {\n              code: a.ZodIssueCode.too_small,\n              message: n.message,\n              inclusive: !0,\n              exact: !1,\n              minimum: n.value,\n              type: \"date\"\n            }), t.dirty()) : \"max\" === n.kind ? e.data.getTime() > n.value && (r = this._getOrReturnCtx(e, r), (0, i.addIssueToContext)(r, {\n              code: a.ZodIssueCode.too_big,\n              message: n.message,\n              inclusive: !0,\n              exact: !1,\n              maximum: n.value,\n              type: \"date\"\n            }), t.dirty()) : s.util.assertNever(n);\n            return {\n              status: t.value,\n              value: new Date(e.data.getTime())\n            };\n          }\n          _addCheck(e) {\n            return new I({\n              ...this._def,\n              checks: [...this._def.checks, e]\n            });\n          }\n          min(e, t) {\n            return this._addCheck({\n              kind: \"min\",\n              value: e.getTime(),\n              message: o.errorUtil.toString(t)\n            });\n          }\n          max(e, t) {\n            return this._addCheck({\n              kind: \"max\",\n              value: e.getTime(),\n              message: o.errorUtil.toString(t)\n            });\n          }\n          get minDate() {\n            let e = null;\n            for (const t of this._def.checks) \"min\" === t.kind && (null === e || t.value > e) && (e = t.value);\n            return null != e ? new Date(e) : null;\n          }\n          get maxDate() {\n            let e = null;\n            for (const t of this._def.checks) \"max\" === t.kind && (null === e || t.value < e) && (e = t.value);\n            return null != e ? new Date(e) : null;\n          }\n        }\n        t.ZodDate = I, I.create = e => new I({\n          checks: [],\n          coerce: (null == e ? void 0 : e.coerce) || !1,\n          typeName: ae.ZodDate,\n          ...d(e)\n        });\n        class R extends l {\n          _parse(e) {\n            if (this._getType(e) !== s.ZodParsedType.symbol) {\n              const t = this._getOrReturnCtx(e);\n              return (0, i.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.symbol,\n                received: t.parsedType\n              }), i.INVALID;\n            }\n            return (0, i.OK)(e.data);\n          }\n        }\n        t.ZodSymbol = R, R.create = e => new R({\n          typeName: ae.ZodSymbol,\n          ...d(e)\n        });\n        class P extends l {\n          _parse(e) {\n            if (this._getType(e) !== s.ZodParsedType.undefined) {\n              const t = this._getOrReturnCtx(e);\n              return (0, i.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.undefined,\n                received: t.parsedType\n              }), i.INVALID;\n            }\n            return (0, i.OK)(e.data);\n          }\n        }\n        t.ZodUndefined = P, P.create = e => new P({\n          typeName: ae.ZodUndefined,\n          ...d(e)\n        });\n        class x extends l {\n          _parse(e) {\n            if (this._getType(e) !== s.ZodParsedType.null) {\n              const t = this._getOrReturnCtx(e);\n              return (0, i.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.null,\n                received: t.parsedType\n              }), i.INVALID;\n            }\n            return (0, i.OK)(e.data);\n          }\n        }\n        t.ZodNull = x, x.create = e => new x({\n          typeName: ae.ZodNull,\n          ...d(e)\n        });\n        class O extends l {\n          constructor() {\n            super(...arguments), this._any = !0;\n          }\n          _parse(e) {\n            return (0, i.OK)(e.data);\n          }\n        }\n        t.ZodAny = O, O.create = e => new O({\n          typeName: ae.ZodAny,\n          ...d(e)\n        });\n        class S extends l {\n          constructor() {\n            super(...arguments), this._unknown = !0;\n          }\n          _parse(e) {\n            return (0, i.OK)(e.data);\n          }\n        }\n        t.ZodUnknown = S, S.create = e => new S({\n          typeName: ae.ZodUnknown,\n          ...d(e)\n        });\n        class C extends l {\n          _parse(e) {\n            const t = this._getOrReturnCtx(e);\n            return (0, i.addIssueToContext)(t, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: s.ZodParsedType.never,\n              received: t.parsedType\n            }), i.INVALID;\n          }\n        }\n        t.ZodNever = C, C.create = e => new C({\n          typeName: ae.ZodNever,\n          ...d(e)\n        });\n        class B extends l {\n          _parse(e) {\n            if (this._getType(e) !== s.ZodParsedType.undefined) {\n              const t = this._getOrReturnCtx(e);\n              return (0, i.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.void,\n                received: t.parsedType\n              }), i.INVALID;\n            }\n            return (0, i.OK)(e.data);\n          }\n        }\n        t.ZodVoid = B, B.create = e => new B({\n          typeName: ae.ZodVoid,\n          ...d(e)\n        });\n        class k extends l {\n          _parse(e) {\n            const {\n                ctx: t,\n                status: r\n              } = this._processInputParams(e),\n              n = this._def;\n            if (t.parsedType !== s.ZodParsedType.array) return (0, i.addIssueToContext)(t, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: s.ZodParsedType.array,\n              received: t.parsedType\n            }), i.INVALID;\n            if (null !== n.exactLength) {\n              const e = t.data.length > n.exactLength.value,\n                o = t.data.length < n.exactLength.value;\n              (e || o) && ((0, i.addIssueToContext)(t, {\n                code: e ? a.ZodIssueCode.too_big : a.ZodIssueCode.too_small,\n                minimum: o ? n.exactLength.value : void 0,\n                maximum: e ? n.exactLength.value : void 0,\n                type: \"array\",\n                inclusive: !0,\n                exact: !0,\n                message: n.exactLength.message\n              }), r.dirty());\n            }\n            if (null !== n.minLength && t.data.length < n.minLength.value && ((0, i.addIssueToContext)(t, {\n              code: a.ZodIssueCode.too_small,\n              minimum: n.minLength.value,\n              type: \"array\",\n              inclusive: !0,\n              exact: !1,\n              message: n.minLength.message\n            }), r.dirty()), null !== n.maxLength && t.data.length > n.maxLength.value && ((0, i.addIssueToContext)(t, {\n              code: a.ZodIssueCode.too_big,\n              maximum: n.maxLength.value,\n              type: \"array\",\n              inclusive: !0,\n              exact: !1,\n              message: n.maxLength.message\n            }), r.dirty()), t.common.async) return Promise.all([...t.data].map((e, r) => n.type._parseAsync(new c(t, e, t.path, r)))).then(e => i.ParseStatus.mergeArray(r, e));\n            const o = [...t.data].map((e, r) => n.type._parseSync(new c(t, e, t.path, r)));\n            return i.ParseStatus.mergeArray(r, o);\n          }\n          get element() {\n            return this._def.type;\n          }\n          min(e, t) {\n            return new k({\n              ...this._def,\n              minLength: {\n                value: e,\n                message: o.errorUtil.toString(t)\n              }\n            });\n          }\n          max(e, t) {\n            return new k({\n              ...this._def,\n              maxLength: {\n                value: e,\n                message: o.errorUtil.toString(t)\n              }\n            });\n          }\n          length(e, t) {\n            return new k({\n              ...this._def,\n              exactLength: {\n                value: e,\n                message: o.errorUtil.toString(t)\n              }\n            });\n          }\n          nonempty(e) {\n            return this.min(1, e);\n          }\n        }\n        function N(e) {\n          if (e instanceof M) {\n            const t = {};\n            for (const r in e.shape) {\n              const n = e.shape[r];\n              t[r] = $.create(N(n));\n            }\n            return new M({\n              ...e._def,\n              shape: () => t\n            });\n          }\n          return e instanceof k ? new k({\n            ...e._def,\n            type: N(e.element)\n          }) : e instanceof $ ? $.create(N(e.unwrap())) : e instanceof ee ? ee.create(N(e.unwrap())) : e instanceof U ? U.create(e.items.map(e => N(e))) : e;\n        }\n        t.ZodArray = k, k.create = (e, t) => new k({\n          type: e,\n          minLength: null,\n          maxLength: null,\n          exactLength: null,\n          typeName: ae.ZodArray,\n          ...d(t)\n        });\n        class M extends l {\n          constructor() {\n            super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;\n          }\n          _getCached() {\n            if (null !== this._cached) return this._cached;\n            const e = this._def.shape(),\n              t = s.util.objectKeys(e);\n            return this._cached = {\n              shape: e,\n              keys: t\n            };\n          }\n          _parse(e) {\n            if (this._getType(e) !== s.ZodParsedType.object) {\n              const t = this._getOrReturnCtx(e);\n              return (0, i.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.object,\n                received: t.parsedType\n              }), i.INVALID;\n            }\n            const {\n                status: t,\n                ctx: r\n              } = this._processInputParams(e),\n              {\n                shape: n,\n                keys: o\n              } = this._getCached(),\n              u = [];\n            if (!(this._def.catchall instanceof C && \"strip\" === this._def.unknownKeys)) for (const e in r.data) o.includes(e) || u.push(e);\n            const d = [];\n            for (const e of o) {\n              const t = n[e],\n                o = r.data[e];\n              d.push({\n                key: {\n                  status: \"valid\",\n                  value: e\n                },\n                value: t._parse(new c(r, o, r.path, e)),\n                alwaysSet: e in r.data\n              });\n            }\n            if (this._def.catchall instanceof C) {\n              const e = this._def.unknownKeys;\n              if (\"passthrough\" === e) for (const e of u) d.push({\n                key: {\n                  status: \"valid\",\n                  value: e\n                },\n                value: {\n                  status: \"valid\",\n                  value: r.data[e]\n                }\n              });else if (\"strict\" === e) u.length > 0 && ((0, i.addIssueToContext)(r, {\n                code: a.ZodIssueCode.unrecognized_keys,\n                keys: u\n              }), t.dirty());else if (\"strip\" !== e) throw new Error(\"Internal ZodObject error: invalid unknownKeys value.\");\n            } else {\n              const e = this._def.catchall;\n              for (const t of u) {\n                const n = r.data[t];\n                d.push({\n                  key: {\n                    status: \"valid\",\n                    value: t\n                  },\n                  value: e._parse(new c(r, n, r.path, t)),\n                  alwaysSet: t in r.data\n                });\n              }\n            }\n            return r.common.async ? Promise.resolve().then(async () => {\n              const e = [];\n              for (const t of d) {\n                const r = await t.key;\n                e.push({\n                  key: r,\n                  value: await t.value,\n                  alwaysSet: t.alwaysSet\n                });\n              }\n              return e;\n            }).then(e => i.ParseStatus.mergeObjectSync(t, e)) : i.ParseStatus.mergeObjectSync(t, d);\n          }\n          get shape() {\n            return this._def.shape();\n          }\n          strict(e) {\n            return o.errorUtil.errToObj, new M({\n              ...this._def,\n              unknownKeys: \"strict\",\n              ...(void 0 !== e ? {\n                errorMap: (t, r) => {\n                  var n, i, s, a;\n                  const c = null !== (s = null === (i = (n = this._def).errorMap) || void 0 === i ? void 0 : i.call(n, t, r).message) && void 0 !== s ? s : r.defaultError;\n                  return \"unrecognized_keys\" === t.code ? {\n                    message: null !== (a = o.errorUtil.errToObj(e).message) && void 0 !== a ? a : c\n                  } : {\n                    message: c\n                  };\n                }\n              } : {})\n            });\n          }\n          strip() {\n            return new M({\n              ...this._def,\n              unknownKeys: \"strip\"\n            });\n          }\n          passthrough() {\n            return new M({\n              ...this._def,\n              unknownKeys: \"passthrough\"\n            });\n          }\n          extend(e) {\n            return new M({\n              ...this._def,\n              shape: () => ({\n                ...this._def.shape(),\n                ...e\n              })\n            });\n          }\n          merge(e) {\n            return new M({\n              unknownKeys: e._def.unknownKeys,\n              catchall: e._def.catchall,\n              shape: () => ({\n                ...this._def.shape(),\n                ...e._def.shape()\n              }),\n              typeName: ae.ZodObject\n            });\n          }\n          setKey(e, t) {\n            return this.augment({\n              [e]: t\n            });\n          }\n          catchall(e) {\n            return new M({\n              ...this._def,\n              catchall: e\n            });\n          }\n          pick(e) {\n            const t = {};\n            return s.util.objectKeys(e).forEach(r => {\n              e[r] && this.shape[r] && (t[r] = this.shape[r]);\n            }), new M({\n              ...this._def,\n              shape: () => t\n            });\n          }\n          omit(e) {\n            const t = {};\n            return s.util.objectKeys(this.shape).forEach(r => {\n              e[r] || (t[r] = this.shape[r]);\n            }), new M({\n              ...this._def,\n              shape: () => t\n            });\n          }\n          deepPartial() {\n            return N(this);\n          }\n          partial(e) {\n            const t = {};\n            return s.util.objectKeys(this.shape).forEach(r => {\n              const n = this.shape[r];\n              e && !e[r] ? t[r] = n : t[r] = n.optional();\n            }), new M({\n              ...this._def,\n              shape: () => t\n            });\n          }\n          required(e) {\n            const t = {};\n            return s.util.objectKeys(this.shape).forEach(r => {\n              if (e && !e[r]) t[r] = this.shape[r];else {\n                let e = this.shape[r];\n                for (; e instanceof $;) e = e._def.innerType;\n                t[r] = e;\n              }\n            }), new M({\n              ...this._def,\n              shape: () => t\n            });\n          }\n          keyof() {\n            return K(s.util.objectKeys(this.shape));\n          }\n        }\n        t.ZodObject = M, M.create = (e, t) => new M({\n          shape: () => e,\n          unknownKeys: \"strip\",\n          catchall: C.create(),\n          typeName: ae.ZodObject,\n          ...d(t)\n        }), M.strictCreate = (e, t) => new M({\n          shape: () => e,\n          unknownKeys: \"strict\",\n          catchall: C.create(),\n          typeName: ae.ZodObject,\n          ...d(t)\n        }), M.lazycreate = (e, t) => new M({\n          shape: e,\n          unknownKeys: \"strip\",\n          catchall: C.create(),\n          typeName: ae.ZodObject,\n          ...d(t)\n        });\n        class L extends l {\n          _parse(e) {\n            const {\n                ctx: t\n              } = this._processInputParams(e),\n              r = this._def.options;\n            if (t.common.async) return Promise.all(r.map(async e => {\n              const r = {\n                ...t,\n                common: {\n                  ...t.common,\n                  issues: []\n                },\n                parent: null\n              };\n              return {\n                result: await e._parseAsync({\n                  data: t.data,\n                  path: t.path,\n                  parent: r\n                }),\n                ctx: r\n              };\n            })).then(function (e) {\n              for (const t of e) if (\"valid\" === t.result.status) return t.result;\n              for (const r of e) if (\"dirty\" === r.result.status) return t.common.issues.push(...r.ctx.common.issues), r.result;\n              const r = e.map(e => new a.ZodError(e.ctx.common.issues));\n              return (0, i.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_union,\n                unionErrors: r\n              }), i.INVALID;\n            });\n            {\n              let e;\n              const n = [];\n              for (const o of r) {\n                const r = {\n                    ...t,\n                    common: {\n                      ...t.common,\n                      issues: []\n                    },\n                    parent: null\n                  },\n                  i = o._parseSync({\n                    data: t.data,\n                    path: t.path,\n                    parent: r\n                  });\n                if (\"valid\" === i.status) return i;\n                \"dirty\" !== i.status || e || (e = {\n                  result: i,\n                  ctx: r\n                }), r.common.issues.length && n.push(r.common.issues);\n              }\n              if (e) return t.common.issues.push(...e.ctx.common.issues), e.result;\n              const o = n.map(e => new a.ZodError(e));\n              return (0, i.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_union,\n                unionErrors: o\n              }), i.INVALID;\n            }\n          }\n          get options() {\n            return this._def.options;\n          }\n        }\n        t.ZodUnion = L, L.create = (e, t) => new L({\n          options: e,\n          typeName: ae.ZodUnion,\n          ...d(t)\n        });\n        const D = e => e instanceof q ? D(e.schema) : e instanceof Y ? D(e.innerType()) : e instanceof z ? [e.value] : e instanceof Q ? e.options : e instanceof X ? Object.keys(e.enum) : e instanceof te ? D(e._def.innerType) : e instanceof P ? [void 0] : e instanceof x ? [null] : null;\n        class F extends l {\n          _parse(e) {\n            const {\n              ctx: t\n            } = this._processInputParams(e);\n            if (t.parsedType !== s.ZodParsedType.object) return (0, i.addIssueToContext)(t, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: s.ZodParsedType.object,\n              received: t.parsedType\n            }), i.INVALID;\n            const r = this.discriminator,\n              n = t.data[r],\n              o = this.optionsMap.get(n);\n            return o ? t.common.async ? o._parseAsync({\n              data: t.data,\n              path: t.path,\n              parent: t\n            }) : o._parseSync({\n              data: t.data,\n              path: t.path,\n              parent: t\n            }) : ((0, i.addIssueToContext)(t, {\n              code: a.ZodIssueCode.invalid_union_discriminator,\n              options: Array.from(this.optionsMap.keys()),\n              path: [r]\n            }), i.INVALID);\n          }\n          get discriminator() {\n            return this._def.discriminator;\n          }\n          get options() {\n            return this._def.options;\n          }\n          get optionsMap() {\n            return this._def.optionsMap;\n          }\n          static create(e, t, r) {\n            const n = new Map();\n            for (const r of t) {\n              const t = D(r.shape[e]);\n              if (!t) throw new Error(`A discriminator value for key \\`${e}\\` could not be extracted from all schema options`);\n              for (const o of t) {\n                if (n.has(o)) throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(o)}`);\n                n.set(o, r);\n              }\n            }\n            return new F({\n              typeName: ae.ZodDiscriminatedUnion,\n              discriminator: e,\n              options: t,\n              optionsMap: n,\n              ...d(r)\n            });\n          }\n        }\n        function H(e, t) {\n          const r = (0, s.getParsedType)(e),\n            n = (0, s.getParsedType)(t);\n          if (e === t) return {\n            valid: !0,\n            data: e\n          };\n          if (r === s.ZodParsedType.object && n === s.ZodParsedType.object) {\n            const r = s.util.objectKeys(t),\n              n = s.util.objectKeys(e).filter(e => -1 !== r.indexOf(e)),\n              o = {\n                ...e,\n                ...t\n              };\n            for (const r of n) {\n              const n = H(e[r], t[r]);\n              if (!n.valid) return {\n                valid: !1\n              };\n              o[r] = n.data;\n            }\n            return {\n              valid: !0,\n              data: o\n            };\n          }\n          if (r === s.ZodParsedType.array && n === s.ZodParsedType.array) {\n            if (e.length !== t.length) return {\n              valid: !1\n            };\n            const r = [];\n            for (let n = 0; n < e.length; n++) {\n              const o = H(e[n], t[n]);\n              if (!o.valid) return {\n                valid: !1\n              };\n              r.push(o.data);\n            }\n            return {\n              valid: !0,\n              data: r\n            };\n          }\n          return r === s.ZodParsedType.date && n === s.ZodParsedType.date && +e == +t ? {\n            valid: !0,\n            data: e\n          } : {\n            valid: !1\n          };\n        }\n        t.ZodDiscriminatedUnion = F;\n        class j extends l {\n          _parse(e) {\n            const {\n                status: t,\n                ctx: r\n              } = this._processInputParams(e),\n              n = (e, n) => {\n                if ((0, i.isAborted)(e) || (0, i.isAborted)(n)) return i.INVALID;\n                const o = H(e.value, n.value);\n                return o.valid ? (((0, i.isDirty)(e) || (0, i.isDirty)(n)) && t.dirty(), {\n                  status: t.value,\n                  value: o.data\n                }) : ((0, i.addIssueToContext)(r, {\n                  code: a.ZodIssueCode.invalid_intersection_types\n                }), i.INVALID);\n              };\n            return r.common.async ? Promise.all([this._def.left._parseAsync({\n              data: r.data,\n              path: r.path,\n              parent: r\n            }), this._def.right._parseAsync({\n              data: r.data,\n              path: r.path,\n              parent: r\n            })]).then(([e, t]) => n(e, t)) : n(this._def.left._parseSync({\n              data: r.data,\n              path: r.path,\n              parent: r\n            }), this._def.right._parseSync({\n              data: r.data,\n              path: r.path,\n              parent: r\n            }));\n          }\n        }\n        t.ZodIntersection = j, j.create = (e, t, r) => new j({\n          left: e,\n          right: t,\n          typeName: ae.ZodIntersection,\n          ...d(r)\n        });\n        class U extends l {\n          _parse(e) {\n            const {\n              status: t,\n              ctx: r\n            } = this._processInputParams(e);\n            if (r.parsedType !== s.ZodParsedType.array) return (0, i.addIssueToContext)(r, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: s.ZodParsedType.array,\n              received: r.parsedType\n            }), i.INVALID;\n            if (r.data.length < this._def.items.length) return (0, i.addIssueToContext)(r, {\n              code: a.ZodIssueCode.too_small,\n              minimum: this._def.items.length,\n              inclusive: !0,\n              exact: !1,\n              type: \"array\"\n            }), i.INVALID;\n            !this._def.rest && r.data.length > this._def.items.length && ((0, i.addIssueToContext)(r, {\n              code: a.ZodIssueCode.too_big,\n              maximum: this._def.items.length,\n              inclusive: !0,\n              exact: !1,\n              type: \"array\"\n            }), t.dirty());\n            const n = [...r.data].map((e, t) => {\n              const n = this._def.items[t] || this._def.rest;\n              return n ? n._parse(new c(r, e, r.path, t)) : null;\n            }).filter(e => !!e);\n            return r.common.async ? Promise.all(n).then(e => i.ParseStatus.mergeArray(t, e)) : i.ParseStatus.mergeArray(t, n);\n          }\n          get items() {\n            return this._def.items;\n          }\n          rest(e) {\n            return new U({\n              ...this._def,\n              rest: e\n            });\n          }\n        }\n        t.ZodTuple = U, U.create = (e, t) => {\n          if (!Array.isArray(e)) throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n          return new U({\n            items: e,\n            typeName: ae.ZodTuple,\n            rest: null,\n            ...d(t)\n          });\n        };\n        class G extends l {\n          get keySchema() {\n            return this._def.keyType;\n          }\n          get valueSchema() {\n            return this._def.valueType;\n          }\n          _parse(e) {\n            const {\n              status: t,\n              ctx: r\n            } = this._processInputParams(e);\n            if (r.parsedType !== s.ZodParsedType.object) return (0, i.addIssueToContext)(r, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: s.ZodParsedType.object,\n              received: r.parsedType\n            }), i.INVALID;\n            const n = [],\n              o = this._def.keyType,\n              u = this._def.valueType;\n            for (const e in r.data) n.push({\n              key: o._parse(new c(r, e, r.path, e)),\n              value: u._parse(new c(r, r.data[e], r.path, e))\n            });\n            return r.common.async ? i.ParseStatus.mergeObjectAsync(t, n) : i.ParseStatus.mergeObjectSync(t, n);\n          }\n          get element() {\n            return this._def.valueType;\n          }\n          static create(e, t, r) {\n            return new G(t instanceof l ? {\n              keyType: e,\n              valueType: t,\n              typeName: ae.ZodRecord,\n              ...d(r)\n            } : {\n              keyType: E.create(),\n              valueType: e,\n              typeName: ae.ZodRecord,\n              ...d(t)\n            });\n          }\n        }\n        t.ZodRecord = G;\n        class V extends l {\n          get keySchema() {\n            return this._def.keyType;\n          }\n          get valueSchema() {\n            return this._def.valueType;\n          }\n          _parse(e) {\n            const {\n              status: t,\n              ctx: r\n            } = this._processInputParams(e);\n            if (r.parsedType !== s.ZodParsedType.map) return (0, i.addIssueToContext)(r, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: s.ZodParsedType.map,\n              received: r.parsedType\n            }), i.INVALID;\n            const n = this._def.keyType,\n              o = this._def.valueType,\n              u = [...r.data.entries()].map(([e, t], i) => ({\n                key: n._parse(new c(r, e, r.path, [i, \"key\"])),\n                value: o._parse(new c(r, t, r.path, [i, \"value\"]))\n              }));\n            if (r.common.async) {\n              const e = new Map();\n              return Promise.resolve().then(async () => {\n                for (const r of u) {\n                  const n = await r.key,\n                    o = await r.value;\n                  if (\"aborted\" === n.status || \"aborted\" === o.status) return i.INVALID;\n                  \"dirty\" !== n.status && \"dirty\" !== o.status || t.dirty(), e.set(n.value, o.value);\n                }\n                return {\n                  status: t.value,\n                  value: e\n                };\n              });\n            }\n            {\n              const e = new Map();\n              for (const r of u) {\n                const n = r.key,\n                  o = r.value;\n                if (\"aborted\" === n.status || \"aborted\" === o.status) return i.INVALID;\n                \"dirty\" !== n.status && \"dirty\" !== o.status || t.dirty(), e.set(n.value, o.value);\n              }\n              return {\n                status: t.value,\n                value: e\n              };\n            }\n          }\n        }\n        t.ZodMap = V, V.create = (e, t, r) => new V({\n          valueType: t,\n          keyType: e,\n          typeName: ae.ZodMap,\n          ...d(r)\n        });\n        class W extends l {\n          _parse(e) {\n            const {\n              status: t,\n              ctx: r\n            } = this._processInputParams(e);\n            if (r.parsedType !== s.ZodParsedType.set) return (0, i.addIssueToContext)(r, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: s.ZodParsedType.set,\n              received: r.parsedType\n            }), i.INVALID;\n            const n = this._def;\n            null !== n.minSize && r.data.size < n.minSize.value && ((0, i.addIssueToContext)(r, {\n              code: a.ZodIssueCode.too_small,\n              minimum: n.minSize.value,\n              type: \"set\",\n              inclusive: !0,\n              exact: !1,\n              message: n.minSize.message\n            }), t.dirty()), null !== n.maxSize && r.data.size > n.maxSize.value && ((0, i.addIssueToContext)(r, {\n              code: a.ZodIssueCode.too_big,\n              maximum: n.maxSize.value,\n              type: \"set\",\n              inclusive: !0,\n              exact: !1,\n              message: n.maxSize.message\n            }), t.dirty());\n            const o = this._def.valueType;\n            function u(e) {\n              const r = new Set();\n              for (const n of e) {\n                if (\"aborted\" === n.status) return i.INVALID;\n                \"dirty\" === n.status && t.dirty(), r.add(n.value);\n              }\n              return {\n                status: t.value,\n                value: r\n              };\n            }\n            const d = [...r.data.values()].map((e, t) => o._parse(new c(r, e, r.path, t)));\n            return r.common.async ? Promise.all(d).then(e => u(e)) : u(d);\n          }\n          min(e, t) {\n            return new W({\n              ...this._def,\n              minSize: {\n                value: e,\n                message: o.errorUtil.toString(t)\n              }\n            });\n          }\n          max(e, t) {\n            return new W({\n              ...this._def,\n              maxSize: {\n                value: e,\n                message: o.errorUtil.toString(t)\n              }\n            });\n          }\n          size(e, t) {\n            return this.min(e, t).max(e, t);\n          }\n          nonempty(e) {\n            return this.min(1, e);\n          }\n        }\n        t.ZodSet = W, W.create = (e, t) => new W({\n          valueType: e,\n          minSize: null,\n          maxSize: null,\n          typeName: ae.ZodSet,\n          ...d(t)\n        });\n        class Z extends l {\n          constructor() {\n            super(...arguments), this.validate = this.implement;\n          }\n          _parse(e) {\n            const {\n              ctx: t\n            } = this._processInputParams(e);\n            if (t.parsedType !== s.ZodParsedType.function) return (0, i.addIssueToContext)(t, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: s.ZodParsedType.function,\n              received: t.parsedType\n            }), i.INVALID;\n            function r(e, r) {\n              return (0, i.makeIssue)({\n                data: e,\n                path: t.path,\n                errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, (0, n.getErrorMap)(), n.defaultErrorMap].filter(e => !!e),\n                issueData: {\n                  code: a.ZodIssueCode.invalid_arguments,\n                  argumentsError: r\n                }\n              });\n            }\n            function o(e, r) {\n              return (0, i.makeIssue)({\n                data: e,\n                path: t.path,\n                errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, (0, n.getErrorMap)(), n.defaultErrorMap].filter(e => !!e),\n                issueData: {\n                  code: a.ZodIssueCode.invalid_return_type,\n                  returnTypeError: r\n                }\n              });\n            }\n            const c = {\n                errorMap: t.common.contextualErrorMap\n              },\n              u = t.data;\n            if (this._def.returns instanceof J) {\n              const e = this;\n              return (0, i.OK)(async function (...t) {\n                const n = new a.ZodError([]),\n                  i = await e._def.args.parseAsync(t, c).catch(e => {\n                    throw n.addIssue(r(t, e)), n;\n                  }),\n                  s = await Reflect.apply(u, this, i);\n                return await e._def.returns._def.type.parseAsync(s, c).catch(e => {\n                  throw n.addIssue(o(s, e)), n;\n                });\n              });\n            }\n            {\n              const e = this;\n              return (0, i.OK)(function (...t) {\n                const n = e._def.args.safeParse(t, c);\n                if (!n.success) throw new a.ZodError([r(t, n.error)]);\n                const i = Reflect.apply(u, this, n.data),\n                  s = e._def.returns.safeParse(i, c);\n                if (!s.success) throw new a.ZodError([o(i, s.error)]);\n                return s.data;\n              });\n            }\n          }\n          parameters() {\n            return this._def.args;\n          }\n          returnType() {\n            return this._def.returns;\n          }\n          args(...e) {\n            return new Z({\n              ...this._def,\n              args: U.create(e).rest(S.create())\n            });\n          }\n          returns(e) {\n            return new Z({\n              ...this._def,\n              returns: e\n            });\n          }\n          implement(e) {\n            return this.parse(e);\n          }\n          strictImplement(e) {\n            return this.parse(e);\n          }\n          static create(e, t, r) {\n            return new Z({\n              args: e || U.create([]).rest(S.create()),\n              returns: t || S.create(),\n              typeName: ae.ZodFunction,\n              ...d(r)\n            });\n          }\n        }\n        t.ZodFunction = Z;\n        class q extends l {\n          get schema() {\n            return this._def.getter();\n          }\n          _parse(e) {\n            const {\n              ctx: t\n            } = this._processInputParams(e);\n            return this._def.getter()._parse({\n              data: t.data,\n              path: t.path,\n              parent: t\n            });\n          }\n        }\n        t.ZodLazy = q, q.create = (e, t) => new q({\n          getter: e,\n          typeName: ae.ZodLazy,\n          ...d(t)\n        });\n        class z extends l {\n          _parse(e) {\n            if (e.data !== this._def.value) {\n              const t = this._getOrReturnCtx(e);\n              return (0, i.addIssueToContext)(t, {\n                received: t.data,\n                code: a.ZodIssueCode.invalid_literal,\n                expected: this._def.value\n              }), i.INVALID;\n            }\n            return {\n              status: \"valid\",\n              value: e.data\n            };\n          }\n          get value() {\n            return this._def.value;\n          }\n        }\n        function K(e, t) {\n          return new Q({\n            values: e,\n            typeName: ae.ZodEnum,\n            ...d(t)\n          });\n        }\n        t.ZodLiteral = z, z.create = (e, t) => new z({\n          value: e,\n          typeName: ae.ZodLiteral,\n          ...d(t)\n        });\n        class Q extends l {\n          _parse(e) {\n            if (\"string\" != typeof e.data) {\n              const t = this._getOrReturnCtx(e),\n                r = this._def.values;\n              return (0, i.addIssueToContext)(t, {\n                expected: s.util.joinValues(r),\n                received: t.parsedType,\n                code: a.ZodIssueCode.invalid_type\n              }), i.INVALID;\n            }\n            if (-1 === this._def.values.indexOf(e.data)) {\n              const t = this._getOrReturnCtx(e),\n                r = this._def.values;\n              return (0, i.addIssueToContext)(t, {\n                received: t.data,\n                code: a.ZodIssueCode.invalid_enum_value,\n                options: r\n              }), i.INVALID;\n            }\n            return (0, i.OK)(e.data);\n          }\n          get options() {\n            return this._def.values;\n          }\n          get enum() {\n            const e = {};\n            for (const t of this._def.values) e[t] = t;\n            return e;\n          }\n          get Values() {\n            const e = {};\n            for (const t of this._def.values) e[t] = t;\n            return e;\n          }\n          get Enum() {\n            const e = {};\n            for (const t of this._def.values) e[t] = t;\n            return e;\n          }\n          extract(e) {\n            return Q.create(e);\n          }\n          exclude(e) {\n            return Q.create(this.options.filter(t => !e.includes(t)));\n          }\n        }\n        t.ZodEnum = Q, Q.create = K;\n        class X extends l {\n          _parse(e) {\n            const t = s.util.getValidEnumValues(this._def.values),\n              r = this._getOrReturnCtx(e);\n            if (r.parsedType !== s.ZodParsedType.string && r.parsedType !== s.ZodParsedType.number) {\n              const e = s.util.objectValues(t);\n              return (0, i.addIssueToContext)(r, {\n                expected: s.util.joinValues(e),\n                received: r.parsedType,\n                code: a.ZodIssueCode.invalid_type\n              }), i.INVALID;\n            }\n            if (-1 === t.indexOf(e.data)) {\n              const e = s.util.objectValues(t);\n              return (0, i.addIssueToContext)(r, {\n                received: r.data,\n                code: a.ZodIssueCode.invalid_enum_value,\n                options: e\n              }), i.INVALID;\n            }\n            return (0, i.OK)(e.data);\n          }\n          get enum() {\n            return this._def.values;\n          }\n        }\n        t.ZodNativeEnum = X, X.create = (e, t) => new X({\n          values: e,\n          typeName: ae.ZodNativeEnum,\n          ...d(t)\n        });\n        class J extends l {\n          unwrap() {\n            return this._def.type;\n          }\n          _parse(e) {\n            const {\n              ctx: t\n            } = this._processInputParams(e);\n            if (t.parsedType !== s.ZodParsedType.promise && !1 === t.common.async) return (0, i.addIssueToContext)(t, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: s.ZodParsedType.promise,\n              received: t.parsedType\n            }), i.INVALID;\n            const r = t.parsedType === s.ZodParsedType.promise ? t.data : Promise.resolve(t.data);\n            return (0, i.OK)(r.then(e => this._def.type.parseAsync(e, {\n              path: t.path,\n              errorMap: t.common.contextualErrorMap\n            })));\n          }\n        }\n        t.ZodPromise = J, J.create = (e, t) => new J({\n          type: e,\n          typeName: ae.ZodPromise,\n          ...d(t)\n        });\n        class Y extends l {\n          innerType() {\n            return this._def.schema;\n          }\n          sourceType() {\n            return this._def.schema._def.typeName === ae.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n          }\n          _parse(e) {\n            const {\n                status: t,\n                ctx: r\n              } = this._processInputParams(e),\n              n = this._def.effect || null,\n              o = {\n                addIssue: e => {\n                  (0, i.addIssueToContext)(r, e), e.fatal ? t.abort() : t.dirty();\n                },\n                get path() {\n                  return r.path;\n                }\n              };\n            if (o.addIssue = o.addIssue.bind(o), \"preprocess\" === n.type) {\n              const e = n.transform(r.data, o);\n              return r.common.issues.length ? {\n                status: \"dirty\",\n                value: r.data\n              } : r.common.async ? Promise.resolve(e).then(e => this._def.schema._parseAsync({\n                data: e,\n                path: r.path,\n                parent: r\n              })) : this._def.schema._parseSync({\n                data: e,\n                path: r.path,\n                parent: r\n              });\n            }\n            if (\"refinement\" === n.type) {\n              const e = e => {\n                const t = n.refinement(e, o);\n                if (r.common.async) return Promise.resolve(t);\n                if (t instanceof Promise) throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                return e;\n              };\n              if (!1 === r.common.async) {\n                const n = this._def.schema._parseSync({\n                  data: r.data,\n                  path: r.path,\n                  parent: r\n                });\n                return \"aborted\" === n.status ? i.INVALID : (\"dirty\" === n.status && t.dirty(), e(n.value), {\n                  status: t.value,\n                  value: n.value\n                });\n              }\n              return this._def.schema._parseAsync({\n                data: r.data,\n                path: r.path,\n                parent: r\n              }).then(r => \"aborted\" === r.status ? i.INVALID : (\"dirty\" === r.status && t.dirty(), e(r.value).then(() => ({\n                status: t.value,\n                value: r.value\n              }))));\n            }\n            if (\"transform\" === n.type) {\n              if (!1 === r.common.async) {\n                const e = this._def.schema._parseSync({\n                  data: r.data,\n                  path: r.path,\n                  parent: r\n                });\n                if (!(0, i.isValid)(e)) return e;\n                const s = n.transform(e.value, o);\n                if (s instanceof Promise) throw new Error(\"Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.\");\n                return {\n                  status: t.value,\n                  value: s\n                };\n              }\n              return this._def.schema._parseAsync({\n                data: r.data,\n                path: r.path,\n                parent: r\n              }).then(e => (0, i.isValid)(e) ? Promise.resolve(n.transform(e.value, o)).then(e => ({\n                status: t.value,\n                value: e\n              })) : e);\n            }\n            s.util.assertNever(n);\n          }\n        }\n        t.ZodEffects = Y, t.ZodTransformer = Y, Y.create = (e, t, r) => new Y({\n          schema: e,\n          typeName: ae.ZodEffects,\n          effect: t,\n          ...d(r)\n        }), Y.createWithPreprocess = (e, t, r) => new Y({\n          schema: t,\n          effect: {\n            type: \"preprocess\",\n            transform: e\n          },\n          typeName: ae.ZodEffects,\n          ...d(r)\n        });\n        class $ extends l {\n          _parse(e) {\n            return this._getType(e) === s.ZodParsedType.undefined ? (0, i.OK)(void 0) : this._def.innerType._parse(e);\n          }\n          unwrap() {\n            return this._def.innerType;\n          }\n        }\n        t.ZodOptional = $, $.create = (e, t) => new $({\n          innerType: e,\n          typeName: ae.ZodOptional,\n          ...d(t)\n        });\n        class ee extends l {\n          _parse(e) {\n            return this._getType(e) === s.ZodParsedType.null ? (0, i.OK)(null) : this._def.innerType._parse(e);\n          }\n          unwrap() {\n            return this._def.innerType;\n          }\n        }\n        t.ZodNullable = ee, ee.create = (e, t) => new ee({\n          innerType: e,\n          typeName: ae.ZodNullable,\n          ...d(t)\n        });\n        class te extends l {\n          _parse(e) {\n            const {\n              ctx: t\n            } = this._processInputParams(e);\n            let r = t.data;\n            return t.parsedType === s.ZodParsedType.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({\n              data: r,\n              path: t.path,\n              parent: t\n            });\n          }\n          removeDefault() {\n            return this._def.innerType;\n          }\n        }\n        t.ZodDefault = te, te.create = (e, t) => new te({\n          innerType: e,\n          typeName: ae.ZodDefault,\n          defaultValue: \"function\" == typeof t.default ? t.default : () => t.default,\n          ...d(t)\n        });\n        class re extends l {\n          _parse(e) {\n            const {\n                ctx: t\n              } = this._processInputParams(e),\n              r = {\n                ...t,\n                common: {\n                  ...t.common,\n                  issues: []\n                }\n              },\n              n = this._def.innerType._parse({\n                data: r.data,\n                path: r.path,\n                parent: {\n                  ...r\n                }\n              });\n            return (0, i.isAsync)(n) ? n.then(e => ({\n              status: \"valid\",\n              value: \"valid\" === e.status ? e.value : this._def.catchValue({\n                get error() {\n                  return new a.ZodError(r.common.issues);\n                },\n                input: r.data\n              })\n            })) : {\n              status: \"valid\",\n              value: \"valid\" === n.status ? n.value : this._def.catchValue({\n                get error() {\n                  return new a.ZodError(r.common.issues);\n                },\n                input: r.data\n              })\n            };\n          }\n          removeCatch() {\n            return this._def.innerType;\n          }\n        }\n        t.ZodCatch = re, re.create = (e, t) => new re({\n          innerType: e,\n          typeName: ae.ZodCatch,\n          catchValue: \"function\" == typeof t.catch ? t.catch : () => t.catch,\n          ...d(t)\n        });\n        class ne extends l {\n          _parse(e) {\n            if (this._getType(e) !== s.ZodParsedType.nan) {\n              const t = this._getOrReturnCtx(e);\n              return (0, i.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.nan,\n                received: t.parsedType\n              }), i.INVALID;\n            }\n            return {\n              status: \"valid\",\n              value: e.data\n            };\n          }\n        }\n        t.ZodNaN = ne, ne.create = e => new ne({\n          typeName: ae.ZodNaN,\n          ...d(e)\n        }), t.BRAND = Symbol(\"zod_brand\");\n        class oe extends l {\n          _parse(e) {\n            const {\n                ctx: t\n              } = this._processInputParams(e),\n              r = t.data;\n            return this._def.type._parse({\n              data: r,\n              path: t.path,\n              parent: t\n            });\n          }\n          unwrap() {\n            return this._def.type;\n          }\n        }\n        t.ZodBranded = oe;\n        class ie extends l {\n          _parse(e) {\n            const {\n              status: t,\n              ctx: r\n            } = this._processInputParams(e);\n            if (r.common.async) return (async () => {\n              const e = await this._def.in._parseAsync({\n                data: r.data,\n                path: r.path,\n                parent: r\n              });\n              return \"aborted\" === e.status ? i.INVALID : \"dirty\" === e.status ? (t.dirty(), (0, i.DIRTY)(e.value)) : this._def.out._parseAsync({\n                data: e.value,\n                path: r.path,\n                parent: r\n              });\n            })();\n            {\n              const e = this._def.in._parseSync({\n                data: r.data,\n                path: r.path,\n                parent: r\n              });\n              return \"aborted\" === e.status ? i.INVALID : \"dirty\" === e.status ? (t.dirty(), {\n                status: \"dirty\",\n                value: e.value\n              }) : this._def.out._parseSync({\n                data: e.value,\n                path: r.path,\n                parent: r\n              });\n            }\n          }\n          static create(e, t) {\n            return new ie({\n              in: e,\n              out: t,\n              typeName: ae.ZodPipeline\n            });\n          }\n        }\n        t.ZodPipeline = ie;\n        class se extends l {\n          _parse(e) {\n            const t = this._def.innerType._parse(e);\n            return (0, i.isValid)(t) && (t.value = Object.freeze(t.value)), t;\n          }\n        }\n        var ae;\n        t.ZodReadonly = se, se.create = (e, t) => new se({\n          innerType: e,\n          typeName: ae.ZodReadonly,\n          ...d(t)\n        }), t.custom = (e, t = {}, r) => e ? O.create().superRefine((n, o) => {\n          var i, s;\n          if (!e(n)) {\n            const e = \"function\" == typeof t ? t(n) : \"string\" == typeof t ? {\n                message: t\n              } : t,\n              a = null === (s = null !== (i = e.fatal) && void 0 !== i ? i : r) || void 0 === s || s,\n              c = \"string\" == typeof e ? {\n                message: e\n              } : e;\n            o.addIssue({\n              code: \"custom\",\n              ...c,\n              fatal: a\n            });\n          }\n        }) : O.create(), t.late = {\n          object: M.lazycreate\n        }, function (e) {\n          e.ZodString = \"ZodString\", e.ZodNumber = \"ZodNumber\", e.ZodNaN = \"ZodNaN\", e.ZodBigInt = \"ZodBigInt\", e.ZodBoolean = \"ZodBoolean\", e.ZodDate = \"ZodDate\", e.ZodSymbol = \"ZodSymbol\", e.ZodUndefined = \"ZodUndefined\", e.ZodNull = \"ZodNull\", e.ZodAny = \"ZodAny\", e.ZodUnknown = \"ZodUnknown\", e.ZodNever = \"ZodNever\", e.ZodVoid = \"ZodVoid\", e.ZodArray = \"ZodArray\", e.ZodObject = \"ZodObject\", e.ZodUnion = \"ZodUnion\", e.ZodDiscriminatedUnion = \"ZodDiscriminatedUnion\", e.ZodIntersection = \"ZodIntersection\", e.ZodTuple = \"ZodTuple\", e.ZodRecord = \"ZodRecord\", e.ZodMap = \"ZodMap\", e.ZodSet = \"ZodSet\", e.ZodFunction = \"ZodFunction\", e.ZodLazy = \"ZodLazy\", e.ZodLiteral = \"ZodLiteral\", e.ZodEnum = \"ZodEnum\", e.ZodEffects = \"ZodEffects\", e.ZodNativeEnum = \"ZodNativeEnum\", e.ZodOptional = \"ZodOptional\", e.ZodNullable = \"ZodNullable\", e.ZodDefault = \"ZodDefault\", e.ZodCatch = \"ZodCatch\", e.ZodPromise = \"ZodPromise\", e.ZodBranded = \"ZodBranded\", e.ZodPipeline = \"ZodPipeline\", e.ZodReadonly = \"ZodReadonly\";\n        }(ae = t.ZodFirstPartyTypeKind || (t.ZodFirstPartyTypeKind = {})), t.instanceof = (e, r = {\n          message: `Input not instance of ${e.name}`\n        }) => (0, t.custom)(t => t instanceof e, r);\n        const ce = E.create;\n        t.string = ce;\n        const ue = A.create;\n        t.number = ue;\n        const de = ne.create;\n        t.nan = de;\n        const le = T.create;\n        t.bigint = le;\n        const he = w.create;\n        t.boolean = he;\n        const fe = I.create;\n        t.date = fe;\n        const pe = R.create;\n        t.symbol = pe;\n        const me = P.create;\n        t.undefined = me;\n        const ge = x.create;\n        t.null = ge;\n        const ye = O.create;\n        t.any = ye;\n        const ve = S.create;\n        t.unknown = ve;\n        const be = C.create;\n        t.never = be;\n        const Ee = B.create;\n        t.void = Ee;\n        const _e = k.create;\n        t.array = _e;\n        const Ae = M.create;\n        t.object = Ae;\n        const Te = M.strictCreate;\n        t.strictObject = Te;\n        const we = L.create;\n        t.union = we;\n        const Ie = F.create;\n        t.discriminatedUnion = Ie;\n        const Re = j.create;\n        t.intersection = Re;\n        const Pe = U.create;\n        t.tuple = Pe;\n        const xe = G.create;\n        t.record = xe;\n        const Oe = V.create;\n        t.map = Oe;\n        const Se = W.create;\n        t.set = Se;\n        const Ce = Z.create;\n        t.function = Ce;\n        const Be = q.create;\n        t.lazy = Be;\n        const ke = z.create;\n        t.literal = ke;\n        const Ne = Q.create;\n        t.enum = Ne;\n        const Me = X.create;\n        t.nativeEnum = Me;\n        const Le = J.create;\n        t.promise = Le;\n        const De = Y.create;\n        t.effect = De, t.transformer = De;\n        const Fe = $.create;\n        t.optional = Fe;\n        const He = ee.create;\n        t.nullable = He;\n        const je = Y.createWithPreprocess;\n        t.preprocess = je;\n        const Ue = ie.create;\n        t.pipeline = Ue, t.ostring = () => ce().optional(), t.onumber = () => ue().optional(), t.oboolean = () => he().optional(), t.coerce = {\n          string: e => E.create({\n            ...e,\n            coerce: !0\n          }),\n          number: e => A.create({\n            ...e,\n            coerce: !0\n          }),\n          boolean: e => w.create({\n            ...e,\n            coerce: !0\n          }),\n          bigint: e => T.create({\n            ...e,\n            coerce: !0\n          }),\n          date: e => I.create({\n            ...e,\n            coerce: !0\n          })\n        }, t.NEVER = i.INVALID;\n      },\n      4530: (e, t) => {\n        \"use strict\";\n\n        function r(e) {\n          if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);\n        }\n        function n(e) {\n          if (\"boolean\" != typeof e) throw new Error(`Expected boolean, not ${e}`);\n        }\n        function o(e, ...t) {\n          if (!(e instanceof Uint8Array)) throw new TypeError(\"Expected Uint8Array\");\n          if (t.length > 0 && !t.includes(e.length)) throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);\n        }\n        function i(e) {\n          if (\"function\" != typeof e || \"function\" != typeof e.create) throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n          r(e.outputLen), r(e.blockLen);\n        }\n        function s(e, t = !0) {\n          if (e.destroyed) throw new Error(\"Hash instance has been destroyed\");\n          if (t && e.finished) throw new Error(\"Hash#digest() has already been called\");\n        }\n        function a(e, t) {\n          o(e);\n          const r = t.outputLen;\n          if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);\n        }\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.output = t.exists = t.hash = t.bytes = t.bool = t.number = void 0, t.number = r, t.bool = n, t.bytes = o, t.hash = i, t.exists = s, t.output = a;\n        const c = {\n          number: r,\n          bool: n,\n          bytes: o,\n          hash: i,\n          exists: s,\n          output: a\n        };\n        t.default = c;\n      },\n      2023: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SHA2 = void 0;\n        const n = r(4530),\n          o = r(2071);\n        class i extends o.Hash {\n          constructor(e, t, r, n) {\n            super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = (0, o.createView)(this.buffer);\n          }\n          update(e) {\n            n.default.exists(this);\n            const {\n                view: t,\n                buffer: r,\n                blockLen: i\n              } = this,\n              s = (e = (0, o.toBytes)(e)).length;\n            for (let n = 0; n < s;) {\n              const a = Math.min(i - this.pos, s - n);\n              if (a !== i) r.set(e.subarray(n, n + a), this.pos), this.pos += a, n += a, this.pos === i && (this.process(t, 0), this.pos = 0);else {\n                const t = (0, o.createView)(e);\n                for (; i <= s - n; n += i) this.process(t, n);\n              }\n            }\n            return this.length += e.length, this.roundClean(), this;\n          }\n          digestInto(e) {\n            n.default.exists(this), n.default.output(e, this), this.finished = !0;\n            const {\n              buffer: t,\n              view: r,\n              blockLen: i,\n              isLE: s\n            } = this;\n            let {\n              pos: a\n            } = this;\n            t[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > i - a && (this.process(r, 0), a = 0);\n            for (let e = a; e < i; e++) t[e] = 0;\n            !function (e, t, r, n) {\n              if (\"function\" == typeof e.setBigUint64) return e.setBigUint64(t, r, n);\n              const o = BigInt(32),\n                i = BigInt(4294967295),\n                s = Number(r >> o & i),\n                a = Number(r & i),\n                c = n ? 4 : 0,\n                u = n ? 0 : 4;\n              e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);\n            }(r, i - 8, BigInt(8 * this.length), s), this.process(r, 0);\n            const c = (0, o.createView)(e),\n              u = this.outputLen;\n            if (u % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n            const d = u / 4,\n              l = this.get();\n            if (d > l.length) throw new Error(\"_sha2: outputLen bigger than state\");\n            for (let e = 0; e < d; e++) c.setUint32(4 * e, l[e], s);\n          }\n          digest() {\n            const {\n              buffer: e,\n              outputLen: t\n            } = this;\n            this.digestInto(e);\n            const r = e.slice(0, t);\n            return this.destroy(), r;\n          }\n          _cloneInto(e) {\n            e || (e = new this.constructor()), e.set(...this.get());\n            const {\n              blockLen: t,\n              buffer: r,\n              length: n,\n              finished: o,\n              destroyed: i,\n              pos: s\n            } = this;\n            return e.length = n, e.pos = s, e.finished = o, e.destroyed = i, n % t && e.buffer.set(r), e;\n          }\n        }\n        t.SHA2 = i;\n      },\n      2286: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.add = t.toBig = t.split = t.fromBig = void 0;\n        const r = BigInt(2 ** 32 - 1),\n          n = BigInt(32);\n        function o(e, t = !1) {\n          return t ? {\n            h: Number(e & r),\n            l: Number(e >> n & r)\n          } : {\n            h: 0 | Number(e >> n & r),\n            l: 0 | Number(e & r)\n          };\n        }\n        function i(e, t = !1) {\n          let r = new Uint32Array(e.length),\n            n = new Uint32Array(e.length);\n          for (let i = 0; i < e.length; i++) {\n            const {\n              h: s,\n              l: a\n            } = o(e[i], t);\n            [r[i], n[i]] = [s, a];\n          }\n          return [r, n];\n        }\n        function s(e, t, r, n) {\n          const o = (t >>> 0) + (n >>> 0);\n          return {\n            h: e + r + (o / 2 ** 32 | 0) | 0,\n            l: 0 | o\n          };\n        }\n        t.fromBig = o, t.split = i, t.toBig = (e, t) => BigInt(e >>> 0) << n | BigInt(t >>> 0), t.add = s;\n        const a = {\n          fromBig: o,\n          split: i,\n          toBig: t.toBig,\n          shrSH: (e, t, r) => e >>> r,\n          shrSL: (e, t, r) => e << 32 - r | t >>> r,\n          rotrSH: (e, t, r) => e >>> r | t << 32 - r,\n          rotrSL: (e, t, r) => e << 32 - r | t >>> r,\n          rotrBH: (e, t, r) => e << 64 - r | t >>> r - 32,\n          rotrBL: (e, t, r) => e >>> r - 32 | t << 64 - r,\n          rotr32H: (e, t) => t,\n          rotr32L: (e, t) => e,\n          rotlSH: (e, t, r) => e << r | t >>> 32 - r,\n          rotlSL: (e, t, r) => t << r | e >>> 32 - r,\n          rotlBH: (e, t, r) => t << r - 32 | e >>> 64 - r,\n          rotlBL: (e, t, r) => e << r - 32 | t >>> 64 - r,\n          add: s,\n          add3L: (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0),\n          add3H: (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0,\n          add4L: (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0),\n          add4H: (e, t, r, n, o) => t + r + n + o + (e / 2 ** 32 | 0) | 0,\n          add5H: (e, t, r, n, o, i) => t + r + n + o + i + (e / 2 ** 32 | 0) | 0,\n          add5L: (e, t, r, n, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0)\n        };\n        t.default = a;\n      },\n      9043: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.crypto = void 0, t.crypto = \"object\" == typeof globalThis && \"crypto\" in globalThis ? globalThis.crypto : void 0;\n      },\n      4302: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.hmac = void 0;\n        const n = r(4530),\n          o = r(2071);\n        class i extends o.Hash {\n          constructor(e, t) {\n            super(), this.finished = !1, this.destroyed = !1, n.default.hash(e);\n            const r = (0, o.toBytes)(t);\n            if (this.iHash = e.create(), \"function\" != typeof this.iHash.update) throw new TypeError(\"Expected instance of class which extends utils.Hash\");\n            this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;\n            const i = this.blockLen,\n              s = new Uint8Array(i);\n            s.set(r.length > i ? e.create().update(r).digest() : r);\n            for (let e = 0; e < s.length; e++) s[e] ^= 54;\n            this.iHash.update(s), this.oHash = e.create();\n            for (let e = 0; e < s.length; e++) s[e] ^= 106;\n            this.oHash.update(s), s.fill(0);\n          }\n          update(e) {\n            return n.default.exists(this), this.iHash.update(e), this;\n          }\n          digestInto(e) {\n            n.default.exists(this), n.default.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();\n          }\n          digest() {\n            const e = new Uint8Array(this.oHash.outputLen);\n            return this.digestInto(e), e;\n          }\n          _cloneInto(e) {\n            e || (e = Object.create(Object.getPrototypeOf(this), {}));\n            const {\n              oHash: t,\n              iHash: r,\n              finished: n,\n              destroyed: o,\n              blockLen: i,\n              outputLen: s\n            } = this;\n            return e.finished = n, e.destroyed = o, e.blockLen = i, e.outputLen = s, e.oHash = t._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;\n          }\n          destroy() {\n            this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();\n          }\n        }\n        t.hmac = (e, t, r) => new i(e, t).update(r).digest(), t.hmac.create = (e, t) => new i(e, t);\n      },\n      8797: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.pbkdf2Async = t.pbkdf2 = void 0;\n        const n = r(4530),\n          o = r(4302),\n          i = r(2071);\n        function s(e, t, r, s) {\n          n.default.hash(e);\n          const a = (0, i.checkOpts)({\n              dkLen: 32,\n              asyncTick: 10\n            }, s),\n            {\n              c,\n              dkLen: u,\n              asyncTick: d\n            } = a;\n          if (n.default.number(c), n.default.number(u), n.default.number(d), c < 1) throw new Error(\"PBKDF2: iterations (c) should be >= 1\");\n          const l = (0, i.toBytes)(t),\n            h = (0, i.toBytes)(r),\n            f = new Uint8Array(u),\n            p = o.hmac.create(e, l),\n            m = p._cloneInto().update(h);\n          return {\n            c,\n            dkLen: u,\n            asyncTick: d,\n            DK: f,\n            PRF: p,\n            PRFSalt: m\n          };\n        }\n        function a(e, t, r, n, o) {\n          return e.destroy(), t.destroy(), n && n.destroy(), o.fill(0), r;\n        }\n        t.pbkdf2 = function (e, t, r, n) {\n          const {\n            c: o,\n            dkLen: c,\n            DK: u,\n            PRF: d,\n            PRFSalt: l\n          } = s(e, t, r, n);\n          let h;\n          const f = new Uint8Array(4),\n            p = (0, i.createView)(f),\n            m = new Uint8Array(d.outputLen);\n          for (let e = 1, t = 0; t < c; e++, t += d.outputLen) {\n            const r = u.subarray(t, t + d.outputLen);\n            p.setInt32(0, e, !1), (h = l._cloneInto(h)).update(f).digestInto(m), r.set(m.subarray(0, r.length));\n            for (let e = 1; e < o; e++) {\n              d._cloneInto(h).update(m).digestInto(m);\n              for (let e = 0; e < r.length; e++) r[e] ^= m[e];\n            }\n          }\n          return a(d, l, u, h, m);\n        }, t.pbkdf2Async = async function (e, t, r, n) {\n          const {\n            c: o,\n            dkLen: c,\n            asyncTick: u,\n            DK: d,\n            PRF: l,\n            PRFSalt: h\n          } = s(e, t, r, n);\n          let f;\n          const p = new Uint8Array(4),\n            m = (0, i.createView)(p),\n            g = new Uint8Array(l.outputLen);\n          for (let e = 1, t = 0; t < c; e++, t += l.outputLen) {\n            const r = d.subarray(t, t + l.outputLen);\n            m.setInt32(0, e, !1), (f = h._cloneInto(f)).update(p).digestInto(g), r.set(g.subarray(0, r.length)), await (0, i.asyncLoop)(o - 1, u, e => {\n              l._cloneInto(f).update(g).digestInto(g);\n              for (let e = 0; e < r.length; e++) r[e] ^= g[e];\n            });\n          }\n          return a(l, h, d, f, g);\n        };\n      },\n      217: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.scryptAsync = t.scrypt = void 0;\n        const n = r(4530),\n          o = r(8091),\n          i = r(8797),\n          s = r(2071),\n          a = (e, t) => e << t | e >>> 32 - t;\n        function c(e, t, r, n, o, i) {\n          let s = e[t++] ^ r[n++],\n            c = e[t++] ^ r[n++],\n            u = e[t++] ^ r[n++],\n            d = e[t++] ^ r[n++],\n            l = e[t++] ^ r[n++],\n            h = e[t++] ^ r[n++],\n            f = e[t++] ^ r[n++],\n            p = e[t++] ^ r[n++],\n            m = e[t++] ^ r[n++],\n            g = e[t++] ^ r[n++],\n            y = e[t++] ^ r[n++],\n            v = e[t++] ^ r[n++],\n            b = e[t++] ^ r[n++],\n            E = e[t++] ^ r[n++],\n            _ = e[t++] ^ r[n++],\n            A = e[t++] ^ r[n++],\n            T = s,\n            w = c,\n            I = u,\n            R = d,\n            P = l,\n            x = h,\n            O = f,\n            S = p,\n            C = m,\n            B = g,\n            k = y,\n            N = v,\n            M = b,\n            L = E,\n            D = _,\n            F = A;\n          for (let e = 0; e < 8; e += 2) P ^= a(T + M | 0, 7), C ^= a(P + T | 0, 9), M ^= a(C + P | 0, 13), T ^= a(M + C | 0, 18), B ^= a(x + w | 0, 7), L ^= a(B + x | 0, 9), w ^= a(L + B | 0, 13), x ^= a(w + L | 0, 18), D ^= a(k + O | 0, 7), I ^= a(D + k | 0, 9), O ^= a(I + D | 0, 13), k ^= a(O + I | 0, 18), R ^= a(F + N | 0, 7), S ^= a(R + F | 0, 9), N ^= a(S + R | 0, 13), F ^= a(N + S | 0, 18), w ^= a(T + R | 0, 7), I ^= a(w + T | 0, 9), R ^= a(I + w | 0, 13), T ^= a(R + I | 0, 18), O ^= a(x + P | 0, 7), S ^= a(O + x | 0, 9), P ^= a(S + O | 0, 13), x ^= a(P + S | 0, 18), N ^= a(k + B | 0, 7), C ^= a(N + k | 0, 9), B ^= a(C + N | 0, 13), k ^= a(B + C | 0, 18), M ^= a(F + D | 0, 7), L ^= a(M + F | 0, 9), D ^= a(L + M | 0, 13), F ^= a(D + L | 0, 18);\n          o[i++] = s + T | 0, o[i++] = c + w | 0, o[i++] = u + I | 0, o[i++] = d + R | 0, o[i++] = l + P | 0, o[i++] = h + x | 0, o[i++] = f + O | 0, o[i++] = p + S | 0, o[i++] = m + C | 0, o[i++] = g + B | 0, o[i++] = y + k | 0, o[i++] = v + N | 0, o[i++] = b + M | 0, o[i++] = E + L | 0, o[i++] = _ + D | 0, o[i++] = A + F | 0;\n        }\n        function u(e, t, r, n, o) {\n          let i = n + 0,\n            s = n + 16 * o;\n          for (let n = 0; n < 16; n++) r[s + n] = e[t + 16 * (2 * o - 1) + n];\n          for (let n = 0; n < o; n++, i += 16, t += 16) c(r, s, e, t, r, i), n > 0 && (s += 16), c(r, i, e, t += 16, r, s);\n        }\n        function d(e, t, r) {\n          const a = (0, s.checkOpts)({\n              dkLen: 32,\n              asyncTick: 10,\n              maxmem: 1073742848\n            }, r),\n            {\n              N: c,\n              r: u,\n              p: d,\n              dkLen: l,\n              asyncTick: h,\n              maxmem: f,\n              onProgress: p\n            } = a;\n          if (n.default.number(c), n.default.number(u), n.default.number(d), n.default.number(l), n.default.number(h), n.default.number(f), void 0 !== p && \"function\" != typeof p) throw new Error(\"progressCb should be function\");\n          const m = 128 * u,\n            g = m / 4;\n          if (c <= 1 || 0 != (c & c - 1) || c >= 2 ** (m / 8) || c > 2 ** 32) throw new Error(\"Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32\");\n          if (d < 0 || d > 137438953440 / m) throw new Error(\"Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)\");\n          if (l < 0 || l > 137438953440) throw new Error(\"Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32\");\n          const y = m * (c + d);\n          if (y > f) throw new Error(`Scrypt: parameters too large, ${y} (128 * r * (N + p)) > ${f} (maxmem)`);\n          const v = (0, i.pbkdf2)(o.sha256, e, t, {\n              c: 1,\n              dkLen: m * d\n            }),\n            b = (0, s.u32)(v),\n            E = (0, s.u32)(new Uint8Array(m * c)),\n            _ = (0, s.u32)(new Uint8Array(m));\n          let A = () => {};\n          if (p) {\n            const e = 2 * c * d,\n              t = Math.max(Math.floor(e / 1e4), 1);\n            let r = 0;\n            A = () => {\n              r++, !p || r % t && r !== e || p(r / e);\n            };\n          }\n          return {\n            N: c,\n            r: u,\n            p: d,\n            dkLen: l,\n            blockSize32: g,\n            V: E,\n            B32: b,\n            B: v,\n            tmp: _,\n            blockMixCb: A,\n            asyncTick: h\n          };\n        }\n        function l(e, t, r, n, s) {\n          const a = (0, i.pbkdf2)(o.sha256, e, r, {\n            c: 1,\n            dkLen: t\n          });\n          return r.fill(0), n.fill(0), s.fill(0), a;\n        }\n        t.scrypt = function (e, t, r) {\n          const {\n            N: n,\n            r: o,\n            p: i,\n            dkLen: s,\n            blockSize32: a,\n            V: c,\n            B32: h,\n            B: f,\n            tmp: p,\n            blockMixCb: m\n          } = d(e, t, r);\n          for (let e = 0; e < i; e++) {\n            const t = a * e;\n            for (let e = 0; e < a; e++) c[e] = h[t + e];\n            for (let e = 0, t = 0; e < n - 1; e++) u(c, t, c, t += a, o), m();\n            u(c, (n - 1) * a, h, t, o), m();\n            for (let e = 0; e < n; e++) {\n              const e = h[t + a - 16] % n;\n              for (let r = 0; r < a; r++) p[r] = h[t + r] ^ c[e * a + r];\n              u(p, 0, h, t, o), m();\n            }\n          }\n          return l(e, s, f, c, p);\n        }, t.scryptAsync = async function (e, t, r) {\n          const {\n            N: n,\n            r: o,\n            p: i,\n            dkLen: a,\n            blockSize32: c,\n            V: h,\n            B32: f,\n            B: p,\n            tmp: m,\n            blockMixCb: g,\n            asyncTick: y\n          } = d(e, t, r);\n          for (let e = 0; e < i; e++) {\n            const t = c * e;\n            for (let e = 0; e < c; e++) h[e] = f[t + e];\n            let r = 0;\n            await (0, s.asyncLoop)(n - 1, y, e => {\n              u(h, r, h, r += c, o), g();\n            }), u(h, (n - 1) * c, f, t, o), g(), await (0, s.asyncLoop)(n, y, e => {\n              const r = f[t + c - 16] % n;\n              for (let e = 0; e < c; e++) m[e] = f[t + e] ^ h[r * c + e];\n              u(m, 0, f, t, o), g();\n            });\n          }\n          return l(e, a, p, h, m);\n        };\n      },\n      8091: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.sha224 = t.sha256 = void 0;\n        const n = r(2023),\n          o = r(2071),\n          i = (e, t, r) => e & t ^ e & r ^ t & r,\n          s = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),\n          a = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),\n          c = new Uint32Array(64);\n        class u extends n.SHA2 {\n          constructor() {\n            super(64, 32, 8, !1), this.A = 0 | a[0], this.B = 0 | a[1], this.C = 0 | a[2], this.D = 0 | a[3], this.E = 0 | a[4], this.F = 0 | a[5], this.G = 0 | a[6], this.H = 0 | a[7];\n          }\n          get() {\n            const {\n              A: e,\n              B: t,\n              C: r,\n              D: n,\n              E: o,\n              F: i,\n              G: s,\n              H: a\n            } = this;\n            return [e, t, r, n, o, i, s, a];\n          }\n          set(e, t, r, n, o, i, s, a) {\n            this.A = 0 | e, this.B = 0 | t, this.C = 0 | r, this.D = 0 | n, this.E = 0 | o, this.F = 0 | i, this.G = 0 | s, this.H = 0 | a;\n          }\n          process(e, t) {\n            for (let r = 0; r < 16; r++, t += 4) c[r] = e.getUint32(t, !1);\n            for (let e = 16; e < 64; e++) {\n              const t = c[e - 15],\n                r = c[e - 2],\n                n = (0, o.rotr)(t, 7) ^ (0, o.rotr)(t, 18) ^ t >>> 3,\n                i = (0, o.rotr)(r, 17) ^ (0, o.rotr)(r, 19) ^ r >>> 10;\n              c[e] = i + c[e - 7] + n + c[e - 16] | 0;\n            }\n            let {\n              A: r,\n              B: n,\n              C: a,\n              D: u,\n              E: d,\n              F: l,\n              G: h,\n              H: f\n            } = this;\n            for (let e = 0; e < 64; e++) {\n              const t = f + ((0, o.rotr)(d, 6) ^ (0, o.rotr)(d, 11) ^ (0, o.rotr)(d, 25)) + ((p = d) & l ^ ~p & h) + s[e] + c[e] | 0,\n                m = ((0, o.rotr)(r, 2) ^ (0, o.rotr)(r, 13) ^ (0, o.rotr)(r, 22)) + i(r, n, a) | 0;\n              f = h, h = l, l = d, d = u + t | 0, u = a, a = n, n = r, r = t + m | 0;\n            }\n            var p;\n            r = r + this.A | 0, n = n + this.B | 0, a = a + this.C | 0, u = u + this.D | 0, d = d + this.E | 0, l = l + this.F | 0, h = h + this.G | 0, f = f + this.H | 0, this.set(r, n, a, u, d, l, h, f);\n          }\n          roundClean() {\n            c.fill(0);\n          }\n          destroy() {\n            this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);\n          }\n        }\n        class d extends u {\n          constructor() {\n            super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;\n          }\n        }\n        t.sha256 = (0, o.wrapConstructor)(() => new u()), t.sha224 = (0, o.wrapConstructor)(() => new d());\n      },\n      1366: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.shake256 = t.shake128 = t.keccak_512 = t.keccak_384 = t.keccak_256 = t.keccak_224 = t.sha3_512 = t.sha3_384 = t.sha3_256 = t.sha3_224 = t.Keccak = t.keccakP = void 0;\n        const n = r(4530),\n          o = r(2286),\n          i = r(2071),\n          [s, a, c] = [[], [], []],\n          u = BigInt(0),\n          d = BigInt(1),\n          l = BigInt(2),\n          h = BigInt(7),\n          f = BigInt(256),\n          p = BigInt(113);\n        for (let e = 0, t = d, r = 1, n = 0; e < 24; e++) {\n          [r, n] = [n, (2 * r + 3 * n) % 5], s.push(2 * (5 * n + r)), a.push((e + 1) * (e + 2) / 2 % 64);\n          let o = u;\n          for (let e = 0; e < 7; e++) t = (t << d ^ (t >> h) * p) % f, t & l && (o ^= d << (d << BigInt(e)) - d);\n          c.push(o);\n        }\n        const [m, g] = o.default.split(c, !0),\n          y = (e, t, r) => r > 32 ? o.default.rotlBH(e, t, r) : o.default.rotlSH(e, t, r),\n          v = (e, t, r) => r > 32 ? o.default.rotlBL(e, t, r) : o.default.rotlSL(e, t, r);\n        function b(e, t = 24) {\n          const r = new Uint32Array(10);\n          for (let n = 24 - t; n < 24; n++) {\n            for (let t = 0; t < 10; t++) r[t] = e[t] ^ e[t + 10] ^ e[t + 20] ^ e[t + 30] ^ e[t + 40];\n            for (let t = 0; t < 10; t += 2) {\n              const n = (t + 8) % 10,\n                o = (t + 2) % 10,\n                i = r[o],\n                s = r[o + 1],\n                a = y(i, s, 1) ^ r[n],\n                c = v(i, s, 1) ^ r[n + 1];\n              for (let r = 0; r < 50; r += 10) e[t + r] ^= a, e[t + r + 1] ^= c;\n            }\n            let t = e[2],\n              o = e[3];\n            for (let r = 0; r < 24; r++) {\n              const n = a[r],\n                i = y(t, o, n),\n                c = v(t, o, n),\n                u = s[r];\n              t = e[u], o = e[u + 1], e[u] = i, e[u + 1] = c;\n            }\n            for (let t = 0; t < 50; t += 10) {\n              for (let n = 0; n < 10; n++) r[n] = e[t + n];\n              for (let n = 0; n < 10; n++) e[t + n] ^= ~r[(n + 2) % 10] & r[(n + 4) % 10];\n            }\n            e[0] ^= m[n], e[1] ^= g[n];\n          }\n          r.fill(0);\n        }\n        t.keccakP = b;\n        class E extends i.Hash {\n          constructor(e, t, r, o = !1, s = 24) {\n            if (super(), this.blockLen = e, this.suffix = t, this.outputLen = r, this.enableXOF = o, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, n.default.number(r), 0 >= this.blockLen || this.blockLen >= 200) throw new Error(\"Sha3 supports only keccak-f1600 function\");\n            this.state = new Uint8Array(200), this.state32 = (0, i.u32)(this.state);\n          }\n          keccak() {\n            b(this.state32, this.rounds), this.posOut = 0, this.pos = 0;\n          }\n          update(e) {\n            n.default.exists(this);\n            const {\n                blockLen: t,\n                state: r\n              } = this,\n              o = (e = (0, i.toBytes)(e)).length;\n            for (let n = 0; n < o;) {\n              const i = Math.min(t - this.pos, o - n);\n              for (let t = 0; t < i; t++) r[this.pos++] ^= e[n++];\n              this.pos === t && this.keccak();\n            }\n            return this;\n          }\n          finish() {\n            if (this.finished) return;\n            this.finished = !0;\n            const {\n              state: e,\n              suffix: t,\n              pos: r,\n              blockLen: n\n            } = this;\n            e[r] ^= t, 0 != (128 & t) && r === n - 1 && this.keccak(), e[n - 1] ^= 128, this.keccak();\n          }\n          writeInto(e) {\n            n.default.exists(this, !1), n.default.bytes(e), this.finish();\n            const t = this.state,\n              {\n                blockLen: r\n              } = this;\n            for (let n = 0, o = e.length; n < o;) {\n              this.posOut >= r && this.keccak();\n              const i = Math.min(r - this.posOut, o - n);\n              e.set(t.subarray(this.posOut, this.posOut + i), n), this.posOut += i, n += i;\n            }\n            return e;\n          }\n          xofInto(e) {\n            if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n            return this.writeInto(e);\n          }\n          xof(e) {\n            return n.default.number(e), this.xofInto(new Uint8Array(e));\n          }\n          digestInto(e) {\n            if (n.default.output(e, this), this.finished) throw new Error(\"digest() was already called\");\n            return this.writeInto(e), this.destroy(), e;\n          }\n          digest() {\n            return this.digestInto(new Uint8Array(this.outputLen));\n          }\n          destroy() {\n            this.destroyed = !0, this.state.fill(0);\n          }\n          _cloneInto(e) {\n            const {\n              blockLen: t,\n              suffix: r,\n              outputLen: n,\n              rounds: o,\n              enableXOF: i\n            } = this;\n            return e || (e = new E(t, r, n, i, o)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = o, e.suffix = r, e.outputLen = n, e.enableXOF = i, e.destroyed = this.destroyed, e;\n          }\n        }\n        t.Keccak = E;\n        const _ = (e, t, r) => (0, i.wrapConstructor)(() => new E(t, e, r));\n        t.sha3_224 = _(6, 144, 28), t.sha3_256 = _(6, 136, 32), t.sha3_384 = _(6, 104, 48), t.sha3_512 = _(6, 72, 64), t.keccak_224 = _(1, 144, 28), t.keccak_256 = _(1, 136, 32), t.keccak_384 = _(1, 104, 48), t.keccak_512 = _(1, 72, 64);\n        const A = (e, t, r) => (0, i.wrapConstructorWithOpts)((n = {}) => new E(t, e, void 0 === n.dkLen ? r : n.dkLen, !0));\n        t.shake128 = A(31, 168, 16), t.shake256 = A(31, 136, 32);\n      },\n      8578: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.sha384 = t.sha512_256 = t.sha512_224 = t.sha512 = t.SHA512 = void 0;\n        const n = r(2023),\n          o = r(2286),\n          i = r(2071),\n          [s, a] = o.default.split([\"0x428a2f98d728ae22\", \"0x7137449123ef65cd\", \"0xb5c0fbcfec4d3b2f\", \"0xe9b5dba58189dbbc\", \"0x3956c25bf348b538\", \"0x59f111f1b605d019\", \"0x923f82a4af194f9b\", \"0xab1c5ed5da6d8118\", \"0xd807aa98a3030242\", \"0x12835b0145706fbe\", \"0x243185be4ee4b28c\", \"0x550c7dc3d5ffb4e2\", \"0x72be5d74f27b896f\", \"0x80deb1fe3b1696b1\", \"0x9bdc06a725c71235\", \"0xc19bf174cf692694\", \"0xe49b69c19ef14ad2\", \"0xefbe4786384f25e3\", \"0x0fc19dc68b8cd5b5\", \"0x240ca1cc77ac9c65\", \"0x2de92c6f592b0275\", \"0x4a7484aa6ea6e483\", \"0x5cb0a9dcbd41fbd4\", \"0x76f988da831153b5\", \"0x983e5152ee66dfab\", \"0xa831c66d2db43210\", \"0xb00327c898fb213f\", \"0xbf597fc7beef0ee4\", \"0xc6e00bf33da88fc2\", \"0xd5a79147930aa725\", \"0x06ca6351e003826f\", \"0x142929670a0e6e70\", \"0x27b70a8546d22ffc\", \"0x2e1b21385c26c926\", \"0x4d2c6dfc5ac42aed\", \"0x53380d139d95b3df\", \"0x650a73548baf63de\", \"0x766a0abb3c77b2a8\", \"0x81c2c92e47edaee6\", \"0x92722c851482353b\", \"0xa2bfe8a14cf10364\", \"0xa81a664bbc423001\", \"0xc24b8b70d0f89791\", \"0xc76c51a30654be30\", \"0xd192e819d6ef5218\", \"0xd69906245565a910\", \"0xf40e35855771202a\", \"0x106aa07032bbd1b8\", \"0x19a4c116b8d2d0c8\", \"0x1e376c085141ab53\", \"0x2748774cdf8eeb99\", \"0x34b0bcb5e19b48a8\", \"0x391c0cb3c5c95a63\", \"0x4ed8aa4ae3418acb\", \"0x5b9cca4f7763e373\", \"0x682e6ff3d6b2b8a3\", \"0x748f82ee5defb2fc\", \"0x78a5636f43172f60\", \"0x84c87814a1f0ab72\", \"0x8cc702081a6439ec\", \"0x90befffa23631e28\", \"0xa4506cebde82bde9\", \"0xbef9a3f7b2c67915\", \"0xc67178f2e372532b\", \"0xca273eceea26619c\", \"0xd186b8c721c0c207\", \"0xeada7dd6cde0eb1e\", \"0xf57d4f7fee6ed178\", \"0x06f067aa72176fba\", \"0x0a637dc5a2c898a6\", \"0x113f9804bef90dae\", \"0x1b710b35131c471b\", \"0x28db77f523047d84\", \"0x32caab7b40c72493\", \"0x3c9ebe0a15c9bebc\", \"0x431d67c49c100d4c\", \"0x4cc5d4becb3e42b6\", \"0x597f299cfc657e2a\", \"0x5fcb6fab3ad6faec\", \"0x6c44198c4a475817\"].map(e => BigInt(e))),\n          c = new Uint32Array(80),\n          u = new Uint32Array(80);\n        class d extends n.SHA2 {\n          constructor() {\n            super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;\n          }\n          get() {\n            const {\n              Ah: e,\n              Al: t,\n              Bh: r,\n              Bl: n,\n              Ch: o,\n              Cl: i,\n              Dh: s,\n              Dl: a,\n              Eh: c,\n              El: u,\n              Fh: d,\n              Fl: l,\n              Gh: h,\n              Gl: f,\n              Hh: p,\n              Hl: m\n            } = this;\n            return [e, t, r, n, o, i, s, a, c, u, d, l, h, f, p, m];\n          }\n          set(e, t, r, n, o, i, s, a, c, u, d, l, h, f, p, m) {\n            this.Ah = 0 | e, this.Al = 0 | t, this.Bh = 0 | r, this.Bl = 0 | n, this.Ch = 0 | o, this.Cl = 0 | i, this.Dh = 0 | s, this.Dl = 0 | a, this.Eh = 0 | c, this.El = 0 | u, this.Fh = 0 | d, this.Fl = 0 | l, this.Gh = 0 | h, this.Gl = 0 | f, this.Hh = 0 | p, this.Hl = 0 | m;\n          }\n          process(e, t) {\n            for (let r = 0; r < 16; r++, t += 4) c[r] = e.getUint32(t), u[r] = e.getUint32(t += 4);\n            for (let e = 16; e < 80; e++) {\n              const t = 0 | c[e - 15],\n                r = 0 | u[e - 15],\n                n = o.default.rotrSH(t, r, 1) ^ o.default.rotrSH(t, r, 8) ^ o.default.shrSH(t, r, 7),\n                i = o.default.rotrSL(t, r, 1) ^ o.default.rotrSL(t, r, 8) ^ o.default.shrSL(t, r, 7),\n                s = 0 | c[e - 2],\n                a = 0 | u[e - 2],\n                d = o.default.rotrSH(s, a, 19) ^ o.default.rotrBH(s, a, 61) ^ o.default.shrSH(s, a, 6),\n                l = o.default.rotrSL(s, a, 19) ^ o.default.rotrBL(s, a, 61) ^ o.default.shrSL(s, a, 6),\n                h = o.default.add4L(i, l, u[e - 7], u[e - 16]),\n                f = o.default.add4H(h, n, d, c[e - 7], c[e - 16]);\n              c[e] = 0 | f, u[e] = 0 | h;\n            }\n            let {\n              Ah: r,\n              Al: n,\n              Bh: i,\n              Bl: d,\n              Ch: l,\n              Cl: h,\n              Dh: f,\n              Dl: p,\n              Eh: m,\n              El: g,\n              Fh: y,\n              Fl: v,\n              Gh: b,\n              Gl: E,\n              Hh: _,\n              Hl: A\n            } = this;\n            for (let e = 0; e < 80; e++) {\n              const t = o.default.rotrSH(m, g, 14) ^ o.default.rotrSH(m, g, 18) ^ o.default.rotrBH(m, g, 41),\n                T = o.default.rotrSL(m, g, 14) ^ o.default.rotrSL(m, g, 18) ^ o.default.rotrBL(m, g, 41),\n                w = m & y ^ ~m & b,\n                I = g & v ^ ~g & E,\n                R = o.default.add5L(A, T, I, a[e], u[e]),\n                P = o.default.add5H(R, _, t, w, s[e], c[e]),\n                x = 0 | R,\n                O = o.default.rotrSH(r, n, 28) ^ o.default.rotrBH(r, n, 34) ^ o.default.rotrBH(r, n, 39),\n                S = o.default.rotrSL(r, n, 28) ^ o.default.rotrBL(r, n, 34) ^ o.default.rotrBL(r, n, 39),\n                C = r & i ^ r & l ^ i & l,\n                B = n & d ^ n & h ^ d & h;\n              _ = 0 | b, A = 0 | E, b = 0 | y, E = 0 | v, y = 0 | m, v = 0 | g, ({\n                h: m,\n                l: g\n              } = o.default.add(0 | f, 0 | p, 0 | P, 0 | x)), f = 0 | l, p = 0 | h, l = 0 | i, h = 0 | d, i = 0 | r, d = 0 | n;\n              const k = o.default.add3L(x, S, B);\n              r = o.default.add3H(k, P, O, C), n = 0 | k;\n            }\n            ({\n              h: r,\n              l: n\n            } = o.default.add(0 | this.Ah, 0 | this.Al, 0 | r, 0 | n)), ({\n              h: i,\n              l: d\n            } = o.default.add(0 | this.Bh, 0 | this.Bl, 0 | i, 0 | d)), ({\n              h: l,\n              l: h\n            } = o.default.add(0 | this.Ch, 0 | this.Cl, 0 | l, 0 | h)), ({\n              h: f,\n              l: p\n            } = o.default.add(0 | this.Dh, 0 | this.Dl, 0 | f, 0 | p)), ({\n              h: m,\n              l: g\n            } = o.default.add(0 | this.Eh, 0 | this.El, 0 | m, 0 | g)), ({\n              h: y,\n              l: v\n            } = o.default.add(0 | this.Fh, 0 | this.Fl, 0 | y, 0 | v)), ({\n              h: b,\n              l: E\n            } = o.default.add(0 | this.Gh, 0 | this.Gl, 0 | b, 0 | E)), ({\n              h: _,\n              l: A\n            } = o.default.add(0 | this.Hh, 0 | this.Hl, 0 | _, 0 | A)), this.set(r, n, i, d, l, h, f, p, m, g, y, v, b, E, _, A);\n          }\n          roundClean() {\n            c.fill(0), u.fill(0);\n          }\n          destroy() {\n            this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n          }\n        }\n        t.SHA512 = d;\n        class l extends d {\n          constructor() {\n            super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;\n          }\n        }\n        class h extends d {\n          constructor() {\n            super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;\n          }\n        }\n        class f extends d {\n          constructor() {\n            super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;\n          }\n        }\n        t.sha512 = (0, i.wrapConstructor)(() => new d()), t.sha512_224 = (0, i.wrapConstructor)(() => new l()), t.sha512_256 = (0, i.wrapConstructor)(() => new h()), t.sha384 = (0, i.wrapConstructor)(() => new f());\n      },\n      2071: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.randomBytes = t.wrapConstructorWithOpts = t.wrapConstructor = t.checkOpts = t.Hash = t.concatBytes = t.toBytes = t.utf8ToBytes = t.asyncLoop = t.nextTick = t.hexToBytes = t.bytesToHex = t.isLE = t.rotr = t.createView = t.u32 = t.u8 = void 0;\n        const n = r(9043);\n        if (t.u8 = e => new Uint8Array(e.buffer, e.byteOffset, e.byteLength), t.u32 = e => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), t.createView = e => new DataView(e.buffer, e.byteOffset, e.byteLength), t.rotr = (e, t) => e << 32 - t | e >>> t, t.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0], !t.isLE) throw new Error(\"Non little-endian hardware is not supported\");\n        const o = Array.from({\n          length: 256\n        }, (e, t) => t.toString(16).padStart(2, \"0\"));\n        function i(e) {\n          if (\"string\" != typeof e) throw new TypeError(\"utf8ToBytes expected string, got \" + typeof e);\n          return new TextEncoder().encode(e);\n        }\n        function s(e) {\n          if (\"string\" == typeof e && (e = i(e)), !(e instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);\n          return e;\n        }\n        t.bytesToHex = function (e) {\n          if (!(e instanceof Uint8Array)) throw new Error(\"Uint8Array expected\");\n          let t = \"\";\n          for (let r = 0; r < e.length; r++) t += o[e[r]];\n          return t;\n        }, t.hexToBytes = function (e) {\n          if (\"string\" != typeof e) throw new TypeError(\"hexToBytes: expected string, got \" + typeof e);\n          if (e.length % 2) throw new Error(\"hexToBytes: received invalid unpadded hex\");\n          const t = new Uint8Array(e.length / 2);\n          for (let r = 0; r < t.length; r++) {\n            const n = 2 * r,\n              o = e.slice(n, n + 2),\n              i = Number.parseInt(o, 16);\n            if (Number.isNaN(i) || i < 0) throw new Error(\"Invalid byte sequence\");\n            t[r] = i;\n          }\n          return t;\n        }, t.nextTick = async () => {}, t.asyncLoop = async function (e, r, n) {\n          let o = Date.now();\n          for (let i = 0; i < e; i++) {\n            n(i);\n            const e = Date.now() - o;\n            e >= 0 && e < r || (await (0, t.nextTick)(), o += e);\n          }\n        }, t.utf8ToBytes = i, t.toBytes = s, t.concatBytes = function (...e) {\n          if (!e.every(e => e instanceof Uint8Array)) throw new Error(\"Uint8Array list expected\");\n          if (1 === e.length) return e[0];\n          const t = e.reduce((e, t) => e + t.length, 0),\n            r = new Uint8Array(t);\n          for (let t = 0, n = 0; t < e.length; t++) {\n            const o = e[t];\n            r.set(o, n), n += o.length;\n          }\n          return r;\n        }, t.Hash = class {\n          clone() {\n            return this._cloneInto();\n          }\n        }, t.checkOpts = function (e, t) {\n          if (void 0 !== t && (\"object\" != typeof t || (r = t, \"[object Object]\" !== Object.prototype.toString.call(r) || r.constructor !== Object))) throw new TypeError(\"Options should be object or undefined\");\n          var r;\n          return Object.assign(e, t);\n        }, t.wrapConstructor = function (e) {\n          const t = t => e().update(s(t)).digest(),\n            r = e();\n          return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;\n        }, t.wrapConstructorWithOpts = function (e) {\n          const t = (t, r) => e(r).update(s(t)).digest(),\n            r = e({});\n          return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = t => e(t), t;\n        }, t.randomBytes = function (e = 32) {\n          if (n.crypto && \"function\" == typeof n.crypto.getRandomValues) return n.crypto.getRandomValues(new Uint8Array(e));\n          throw new Error(\"crypto.getRandomValues must be defined\");\n        };\n      },\n      3072: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decrypt = t.encrypt = void 0;\n        const n = r(9043),\n          o = r(6540),\n          i = {\n            web: n.crypto\n          };\n        function s(e, t, r) {\n          if (!r.startsWith(\"aes-\")) throw new Error(`AES submodule doesn't support mode ${r}`);\n          if (16 !== t.length) throw new Error(\"AES: wrong IV length\");\n          if (r.startsWith(\"aes-128\") && 16 !== e.length || r.startsWith(\"aes-256\") && 32 !== e.length) throw new Error(\"AES: wrong key length\");\n        }\n        async function a(e, t, r) {\n          if (!i.web) throw new Error(\"Browser crypto not available.\");\n          let n;\n          if ([\"aes-128-cbc\", \"aes-256-cbc\"].includes(e) && (n = \"cbc\"), [\"aes-128-ctr\", \"aes-256-ctr\"].includes(e) && (n = \"ctr\"), !n) throw new Error(\"AES: unsupported mode\");\n          return [await i.web.subtle.importKey(\"raw\", t, {\n            name: `AES-${n.toUpperCase()}`,\n            length: 8 * t.length\n          }, !0, [\"encrypt\", \"decrypt\"]), {\n            name: `aes-${n}`,\n            iv: r,\n            counter: r,\n            length: 128\n          }];\n        }\n        async function c(e, t, r, n = \"aes-128-ctr\", c = !0) {\n          if (s(t, r, n), i.web) {\n            const [o, s] = await a(n, t, r),\n              u = await i.web.subtle.encrypt(s, o, e);\n            let d = new Uint8Array(u);\n            return c || \"aes-cbc\" !== s.name || e.length % 16 || (d = d.slice(0, -16)), d;\n          }\n          if (i.node) {\n            const s = i.node.createCipheriv(n, t, r);\n            return s.setAutoPadding(c), (0, o.concatBytes)(s.update(e), s.final());\n          }\n          throw new Error(\"The environment doesn't have AES module\");\n        }\n        t.encrypt = c, t.decrypt = async function (e, t, r, n = \"aes-128-ctr\", u = !0) {\n          if (s(t, r, n), i.web) {\n            const [s, d] = await a(n, t, r);\n            if (!u && \"aes-cbc\" === d.name) {\n              const i = await async function (e, t, r, n) {\n                const o = e.slice(-16);\n                for (let e = 0; e < 16; e++) o[e] ^= 16 ^ r[e];\n                return (await c(o, t, r, n)).slice(0, 16);\n              }(e, t, r, n);\n              e = (0, o.concatBytes)(e, i);\n            }\n            const l = await i.web.subtle.decrypt(d, s, e),\n              h = new Uint8Array(l);\n            if (\"aes-cbc\" === d.name) {\n              const i = await c(h, t, r, n);\n              if (!(0, o.equalsBytes)(i, e)) throw new Error(\"AES: wrong padding\");\n            }\n            return h;\n          }\n          if (i.node) {\n            const s = i.node.createDecipheriv(n, t, r);\n            return s.setAutoPadding(u), (0, o.concatBytes)(s.update(e), s.final());\n          }\n          throw new Error(\"The environment doesn't have AES module\");\n        };\n      },\n      7423: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.keccak512 = t.keccak384 = t.keccak256 = t.keccak224 = void 0;\n        const n = r(1366),\n          o = r(6540);\n        t.keccak224 = (0, o.wrapHash)(n.keccak_224), t.keccak256 = (() => {\n          const e = (0, o.wrapHash)(n.keccak_256);\n          return e.create = n.keccak_256.create, e;\n        })(), t.keccak384 = (0, o.wrapHash)(n.keccak_384), t.keccak512 = (0, o.wrapHash)(n.keccak_512);\n      },\n      8109: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.pbkdf2Sync = t.pbkdf2 = void 0;\n        const n = r(8797),\n          o = r(8091),\n          i = r(8578),\n          s = r(6540);\n        t.pbkdf2 = async function (e, t, r, a, c) {\n          if (![\"sha256\", \"sha512\"].includes(c)) throw new Error(\"Only sha256 and sha512 are supported\");\n          return (0, s.assertBytes)(e), (0, s.assertBytes)(t), (0, n.pbkdf2Async)(\"sha256\" === c ? o.sha256 : i.sha512, e, t, {\n            c: r,\n            dkLen: a\n          });\n        }, t.pbkdf2Sync = function (e, t, r, a, c) {\n          if (![\"sha256\", \"sha512\"].includes(c)) throw new Error(\"Only sha256 and sha512 are supported\");\n          return (0, s.assertBytes)(e), (0, s.assertBytes)(t), (0, n.pbkdf2)(\"sha256\" === c ? o.sha256 : i.sha512, e, t, {\n            c: r,\n            dkLen: a\n          });\n        };\n      },\n      7002: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.scryptSync = t.scrypt = void 0;\n        const n = r(217),\n          o = r(6540);\n        t.scrypt = async function (e, t, r, i, s, a, c) {\n          return (0, o.assertBytes)(e), (0, o.assertBytes)(t), (0, n.scryptAsync)(e, t, {\n            N: r,\n            r: s,\n            p: i,\n            dkLen: a,\n            onProgress: c\n          });\n        }, t.scryptSync = function (e, t, r, i, s, a, c) {\n          return (0, o.assertBytes)(e), (0, o.assertBytes)(t), (0, n.scrypt)(e, t, {\n            N: r,\n            r: s,\n            p: i,\n            dkLen: a,\n            onProgress: c\n          });\n        };\n      },\n      5473: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.secp256k1 = void 0;\n        var n = r(8358);\n        Object.defineProperty(t, \"secp256k1\", {\n          enumerable: !0,\n          get: function () {\n            return n.secp256k1;\n          }\n        });\n      },\n      6540: function (e, t, r) {\n        \"use strict\";\n\n        e = r.nmd(e);\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.crypto = t.wrapHash = t.equalsBytes = t.hexToBytes = t.bytesToUtf8 = t.utf8ToBytes = t.createView = t.concatBytes = t.toHex = t.bytesToHex = t.assertBytes = t.assertBool = void 0;\n        const o = n(r(4530)),\n          i = r(2071),\n          s = o.default.bool;\n        t.assertBool = s;\n        const a = o.default.bytes;\n        t.assertBytes = a;\n        var c = r(2071);\n        Object.defineProperty(t, \"bytesToHex\", {\n          enumerable: !0,\n          get: function () {\n            return c.bytesToHex;\n          }\n        }), Object.defineProperty(t, \"toHex\", {\n          enumerable: !0,\n          get: function () {\n            return c.bytesToHex;\n          }\n        }), Object.defineProperty(t, \"concatBytes\", {\n          enumerable: !0,\n          get: function () {\n            return c.concatBytes;\n          }\n        }), Object.defineProperty(t, \"createView\", {\n          enumerable: !0,\n          get: function () {\n            return c.createView;\n          }\n        }), Object.defineProperty(t, \"utf8ToBytes\", {\n          enumerable: !0,\n          get: function () {\n            return c.utf8ToBytes;\n          }\n        }), t.bytesToUtf8 = function (e) {\n          if (!(e instanceof Uint8Array)) throw new TypeError(\"bytesToUtf8 expected Uint8Array, got \" + typeof e);\n          return new TextDecoder().decode(e);\n        }, t.hexToBytes = function (e) {\n          const t = e.startsWith(\"0x\") ? e.substring(2) : e;\n          return (0, i.hexToBytes)(t);\n        }, t.equalsBytes = function (e, t) {\n          if (e.length !== t.length) return !1;\n          for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1;\n          return !0;\n        }, t.wrapHash = function (e) {\n          return t => (o.default.bytes(t), e(t));\n        }, t.crypto = (() => {\n          const t = \"object\" == typeof self && \"crypto\" in self ? self.crypto : void 0,\n            r = \"function\" == typeof e.require && e.require.bind(e);\n          return {\n            node: r && !t ? r(\"crypto\") : void 0,\n            web: t\n          };\n        })();\n      },\n      8989: (e, t) => {\n        \"use strict\";\n\n        function r(e) {\n          if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);\n        }\n        function n(e) {\n          if (\"boolean\" != typeof e) throw new Error(`Expected boolean, not ${e}`);\n        }\n        function o(e, ...t) {\n          if (!(e instanceof Uint8Array)) throw new TypeError(\"Expected Uint8Array\");\n          if (t.length > 0 && !t.includes(e.length)) throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);\n        }\n        function i(e) {\n          if (\"function\" != typeof e || \"function\" != typeof e.create) throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n          r(e.outputLen), r(e.blockLen);\n        }\n        function s(e, t = !0) {\n          if (e.destroyed) throw new Error(\"Hash instance has been destroyed\");\n          if (t && e.finished) throw new Error(\"Hash#digest() has already been called\");\n        }\n        function a(e, t) {\n          o(e);\n          const r = t.outputLen;\n          if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);\n        }\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.output = t.exists = t.hash = t.bytes = t.bool = t.number = void 0, t.number = r, t.bool = n, t.bytes = o, t.hash = i, t.exists = s, t.output = a;\n        const c = {\n          number: r,\n          bool: n,\n          bytes: o,\n          hash: i,\n          exists: s,\n          output: a\n        };\n        t.default = c;\n      },\n      7889: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.add = t.toBig = t.split = t.fromBig = void 0;\n        const r = BigInt(2 ** 32 - 1),\n          n = BigInt(32);\n        function o(e, t = !1) {\n          return t ? {\n            h: Number(e & r),\n            l: Number(e >> n & r)\n          } : {\n            h: 0 | Number(e >> n & r),\n            l: 0 | Number(e & r)\n          };\n        }\n        function i(e, t = !1) {\n          let r = new Uint32Array(e.length),\n            n = new Uint32Array(e.length);\n          for (let i = 0; i < e.length; i++) {\n            const {\n              h: s,\n              l: a\n            } = o(e[i], t);\n            [r[i], n[i]] = [s, a];\n          }\n          return [r, n];\n        }\n        function s(e, t, r, n) {\n          const o = (t >>> 0) + (n >>> 0);\n          return {\n            h: e + r + (o / 2 ** 32 | 0) | 0,\n            l: 0 | o\n          };\n        }\n        t.fromBig = o, t.split = i, t.toBig = (e, t) => BigInt(e >>> 0) << n | BigInt(t >>> 0), t.add = s;\n        const a = {\n          fromBig: o,\n          split: i,\n          toBig: t.toBig,\n          shrSH: (e, t, r) => e >>> r,\n          shrSL: (e, t, r) => e << 32 - r | t >>> r,\n          rotrSH: (e, t, r) => e >>> r | t << 32 - r,\n          rotrSL: (e, t, r) => e << 32 - r | t >>> r,\n          rotrBH: (e, t, r) => e << 64 - r | t >>> r - 32,\n          rotrBL: (e, t, r) => e >>> r - 32 | t << 64 - r,\n          rotr32H: (e, t) => t,\n          rotr32L: (e, t) => e,\n          rotlSH: (e, t, r) => e << r | t >>> 32 - r,\n          rotlSL: (e, t, r) => t << r | e >>> 32 - r,\n          rotlBH: (e, t, r) => t << r - 32 | e >>> 64 - r,\n          rotlBL: (e, t, r) => e << r - 32 | t >>> 64 - r,\n          add: s,\n          add3L: (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0),\n          add3H: (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0,\n          add4L: (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0),\n          add4H: (e, t, r, n, o) => t + r + n + o + (e / 2 ** 32 | 0) | 0,\n          add5H: (e, t, r, n, o, i) => t + r + n + o + i + (e / 2 ** 32 | 0) | 0,\n          add5L: (e, t, r, n, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0)\n        };\n        t.default = a;\n      },\n      4318: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.crypto = void 0, t.crypto = \"object\" == typeof globalThis && \"crypto\" in globalThis ? globalThis.crypto : void 0;\n      },\n      5179: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.shake256 = t.shake128 = t.keccak_512 = t.keccak_384 = t.keccak_256 = t.keccak_224 = t.sha3_512 = t.sha3_384 = t.sha3_256 = t.sha3_224 = t.Keccak = t.keccakP = void 0;\n        const n = r(8989),\n          o = r(7889),\n          i = r(2263),\n          [s, a, c] = [[], [], []],\n          u = BigInt(0),\n          d = BigInt(1),\n          l = BigInt(2),\n          h = BigInt(7),\n          f = BigInt(256),\n          p = BigInt(113);\n        for (let e = 0, t = d, r = 1, n = 0; e < 24; e++) {\n          [r, n] = [n, (2 * r + 3 * n) % 5], s.push(2 * (5 * n + r)), a.push((e + 1) * (e + 2) / 2 % 64);\n          let o = u;\n          for (let e = 0; e < 7; e++) t = (t << d ^ (t >> h) * p) % f, t & l && (o ^= d << (d << BigInt(e)) - d);\n          c.push(o);\n        }\n        const [m, g] = o.default.split(c, !0),\n          y = (e, t, r) => r > 32 ? o.default.rotlBH(e, t, r) : o.default.rotlSH(e, t, r),\n          v = (e, t, r) => r > 32 ? o.default.rotlBL(e, t, r) : o.default.rotlSL(e, t, r);\n        function b(e, t = 24) {\n          const r = new Uint32Array(10);\n          for (let n = 24 - t; n < 24; n++) {\n            for (let t = 0; t < 10; t++) r[t] = e[t] ^ e[t + 10] ^ e[t + 20] ^ e[t + 30] ^ e[t + 40];\n            for (let t = 0; t < 10; t += 2) {\n              const n = (t + 8) % 10,\n                o = (t + 2) % 10,\n                i = r[o],\n                s = r[o + 1],\n                a = y(i, s, 1) ^ r[n],\n                c = v(i, s, 1) ^ r[n + 1];\n              for (let r = 0; r < 50; r += 10) e[t + r] ^= a, e[t + r + 1] ^= c;\n            }\n            let t = e[2],\n              o = e[3];\n            for (let r = 0; r < 24; r++) {\n              const n = a[r],\n                i = y(t, o, n),\n                c = v(t, o, n),\n                u = s[r];\n              t = e[u], o = e[u + 1], e[u] = i, e[u + 1] = c;\n            }\n            for (let t = 0; t < 50; t += 10) {\n              for (let n = 0; n < 10; n++) r[n] = e[t + n];\n              for (let n = 0; n < 10; n++) e[t + n] ^= ~r[(n + 2) % 10] & r[(n + 4) % 10];\n            }\n            e[0] ^= m[n], e[1] ^= g[n];\n          }\n          r.fill(0);\n        }\n        t.keccakP = b;\n        class E extends i.Hash {\n          constructor(e, t, r, o = !1, s = 24) {\n            if (super(), this.blockLen = e, this.suffix = t, this.outputLen = r, this.enableXOF = o, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, n.default.number(r), 0 >= this.blockLen || this.blockLen >= 200) throw new Error(\"Sha3 supports only keccak-f1600 function\");\n            this.state = new Uint8Array(200), this.state32 = (0, i.u32)(this.state);\n          }\n          keccak() {\n            b(this.state32, this.rounds), this.posOut = 0, this.pos = 0;\n          }\n          update(e) {\n            n.default.exists(this);\n            const {\n                blockLen: t,\n                state: r\n              } = this,\n              o = (e = (0, i.toBytes)(e)).length;\n            for (let n = 0; n < o;) {\n              const i = Math.min(t - this.pos, o - n);\n              for (let t = 0; t < i; t++) r[this.pos++] ^= e[n++];\n              this.pos === t && this.keccak();\n            }\n            return this;\n          }\n          finish() {\n            if (this.finished) return;\n            this.finished = !0;\n            const {\n              state: e,\n              suffix: t,\n              pos: r,\n              blockLen: n\n            } = this;\n            e[r] ^= t, 0 != (128 & t) && r === n - 1 && this.keccak(), e[n - 1] ^= 128, this.keccak();\n          }\n          writeInto(e) {\n            n.default.exists(this, !1), n.default.bytes(e), this.finish();\n            const t = this.state,\n              {\n                blockLen: r\n              } = this;\n            for (let n = 0, o = e.length; n < o;) {\n              this.posOut >= r && this.keccak();\n              const i = Math.min(r - this.posOut, o - n);\n              e.set(t.subarray(this.posOut, this.posOut + i), n), this.posOut += i, n += i;\n            }\n            return e;\n          }\n          xofInto(e) {\n            if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n            return this.writeInto(e);\n          }\n          xof(e) {\n            return n.default.number(e), this.xofInto(new Uint8Array(e));\n          }\n          digestInto(e) {\n            if (n.default.output(e, this), this.finished) throw new Error(\"digest() was already called\");\n            return this.writeInto(e), this.destroy(), e;\n          }\n          digest() {\n            return this.digestInto(new Uint8Array(this.outputLen));\n          }\n          destroy() {\n            this.destroyed = !0, this.state.fill(0);\n          }\n          _cloneInto(e) {\n            const {\n              blockLen: t,\n              suffix: r,\n              outputLen: n,\n              rounds: o,\n              enableXOF: i\n            } = this;\n            return e || (e = new E(t, r, n, i, o)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = o, e.suffix = r, e.outputLen = n, e.enableXOF = i, e.destroyed = this.destroyed, e;\n          }\n        }\n        t.Keccak = E;\n        const _ = (e, t, r) => (0, i.wrapConstructor)(() => new E(t, e, r));\n        t.sha3_224 = _(6, 144, 28), t.sha3_256 = _(6, 136, 32), t.sha3_384 = _(6, 104, 48), t.sha3_512 = _(6, 72, 64), t.keccak_224 = _(1, 144, 28), t.keccak_256 = _(1, 136, 32), t.keccak_384 = _(1, 104, 48), t.keccak_512 = _(1, 72, 64);\n        const A = (e, t, r) => (0, i.wrapConstructorWithOpts)((n = {}) => new E(t, e, void 0 === n.dkLen ? r : n.dkLen, !0));\n        t.shake128 = A(31, 168, 16), t.shake256 = A(31, 136, 32);\n      },\n      2263: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.randomBytes = t.wrapConstructorWithOpts = t.wrapConstructor = t.checkOpts = t.Hash = t.concatBytes = t.toBytes = t.utf8ToBytes = t.asyncLoop = t.nextTick = t.hexToBytes = t.bytesToHex = t.isLE = t.rotr = t.createView = t.u32 = t.u8 = void 0;\n        const n = r(4318);\n        if (t.u8 = e => new Uint8Array(e.buffer, e.byteOffset, e.byteLength), t.u32 = e => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), t.createView = e => new DataView(e.buffer, e.byteOffset, e.byteLength), t.rotr = (e, t) => e << 32 - t | e >>> t, t.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0], !t.isLE) throw new Error(\"Non little-endian hardware is not supported\");\n        const o = Array.from({\n          length: 256\n        }, (e, t) => t.toString(16).padStart(2, \"0\"));\n        function i(e) {\n          if (\"string\" != typeof e) throw new TypeError(\"utf8ToBytes expected string, got \" + typeof e);\n          return new TextEncoder().encode(e);\n        }\n        function s(e) {\n          if (\"string\" == typeof e && (e = i(e)), !(e instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);\n          return e;\n        }\n        t.bytesToHex = function (e) {\n          if (!(e instanceof Uint8Array)) throw new Error(\"Uint8Array expected\");\n          let t = \"\";\n          for (let r = 0; r < e.length; r++) t += o[e[r]];\n          return t;\n        }, t.hexToBytes = function (e) {\n          if (\"string\" != typeof e) throw new TypeError(\"hexToBytes: expected string, got \" + typeof e);\n          if (e.length % 2) throw new Error(\"hexToBytes: received invalid unpadded hex\");\n          const t = new Uint8Array(e.length / 2);\n          for (let r = 0; r < t.length; r++) {\n            const n = 2 * r,\n              o = e.slice(n, n + 2),\n              i = Number.parseInt(o, 16);\n            if (Number.isNaN(i) || i < 0) throw new Error(\"Invalid byte sequence\");\n            t[r] = i;\n          }\n          return t;\n        }, t.nextTick = async () => {}, t.asyncLoop = async function (e, r, n) {\n          let o = Date.now();\n          for (let i = 0; i < e; i++) {\n            n(i);\n            const e = Date.now() - o;\n            e >= 0 && e < r || (await (0, t.nextTick)(), o += e);\n          }\n        }, t.utf8ToBytes = i, t.toBytes = s, t.concatBytes = function (...e) {\n          if (!e.every(e => e instanceof Uint8Array)) throw new Error(\"Uint8Array list expected\");\n          if (1 === e.length) return e[0];\n          const t = e.reduce((e, t) => e + t.length, 0),\n            r = new Uint8Array(t);\n          for (let t = 0, n = 0; t < e.length; t++) {\n            const o = e[t];\n            r.set(o, n), n += o.length;\n          }\n          return r;\n        }, t.Hash = class {\n          clone() {\n            return this._cloneInto();\n          }\n        }, t.checkOpts = function (e, t) {\n          if (void 0 !== t && (\"object\" != typeof t || (r = t, \"[object Object]\" !== Object.prototype.toString.call(r) || r.constructor !== Object))) throw new TypeError(\"Options should be object or undefined\");\n          var r;\n          return Object.assign(e, t);\n        }, t.wrapConstructor = function (e) {\n          const t = t => e().update(s(t)).digest(),\n            r = e();\n          return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;\n        }, t.wrapConstructorWithOpts = function (e) {\n          const t = (t, r) => e(r).update(s(t)).digest(),\n            r = e({});\n          return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = t => e(t), t;\n        }, t.randomBytes = function (e = 32) {\n          if (n.crypto && \"function\" == typeof n.crypto.getRandomValues) return n.crypto.getRandomValues(new Uint8Array(e));\n          throw new Error(\"crypto.getRandomValues must be defined\");\n        };\n      },\n      3687: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.keccak512 = t.keccak384 = t.keccak256 = t.keccak224 = void 0;\n        const n = r(5179),\n          o = r(5487);\n        t.keccak224 = (0, o.wrapHash)(n.keccak_224), t.keccak256 = (() => {\n          const e = (0, o.wrapHash)(n.keccak_256);\n          return e.create = n.keccak_256.create, e;\n        })(), t.keccak384 = (0, o.wrapHash)(n.keccak_384), t.keccak512 = (0, o.wrapHash)(n.keccak_512);\n      },\n      1341: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getRandomBytes = t.getRandomBytesSync = void 0;\n        const n = r(2263);\n        t.getRandomBytesSync = function (e) {\n          return (0, n.randomBytes)(e);\n        }, t.getRandomBytes = async function (e) {\n          return (0, n.randomBytes)(e);\n        };\n      },\n      5487: function (e, t, r) {\n        \"use strict\";\n\n        e = r.nmd(e);\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.crypto = t.wrapHash = t.equalsBytes = t.hexToBytes = t.bytesToUtf8 = t.utf8ToBytes = t.createView = t.concatBytes = t.toHex = t.bytesToHex = t.assertBytes = t.assertBool = void 0;\n        const o = n(r(8989)),\n          i = r(2263),\n          s = o.default.bool;\n        t.assertBool = s;\n        const a = o.default.bytes;\n        t.assertBytes = a;\n        var c = r(2263);\n        Object.defineProperty(t, \"bytesToHex\", {\n          enumerable: !0,\n          get: function () {\n            return c.bytesToHex;\n          }\n        }), Object.defineProperty(t, \"toHex\", {\n          enumerable: !0,\n          get: function () {\n            return c.bytesToHex;\n          }\n        }), Object.defineProperty(t, \"concatBytes\", {\n          enumerable: !0,\n          get: function () {\n            return c.concatBytes;\n          }\n        }), Object.defineProperty(t, \"createView\", {\n          enumerable: !0,\n          get: function () {\n            return c.createView;\n          }\n        }), Object.defineProperty(t, \"utf8ToBytes\", {\n          enumerable: !0,\n          get: function () {\n            return c.utf8ToBytes;\n          }\n        }), t.bytesToUtf8 = function (e) {\n          if (!(e instanceof Uint8Array)) throw new TypeError(\"bytesToUtf8 expected Uint8Array, got \" + typeof e);\n          return new TextDecoder().decode(e);\n        }, t.hexToBytes = function (e) {\n          const t = e.startsWith(\"0x\") ? e.substring(2) : e;\n          return (0, i.hexToBytes)(t);\n        }, t.equalsBytes = function (e, t) {\n          if (e.length !== t.length) return !1;\n          for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1;\n          return !0;\n        }, t.wrapHash = function (e) {\n          return t => (o.default.bytes(t), e(t));\n        }, t.crypto = (() => {\n          const t = \"object\" == typeof self && \"crypto\" in self ? self.crypto : void 0,\n            r = \"function\" == typeof e.require && e.require.bind(e);\n          return {\n            node: r && !t ? r(\"crypto\") : void 0,\n            web: t\n          };\n        })();\n      },\n      9386: e => {\n        \"use strict\";\n\n        var t = Object.prototype.hasOwnProperty,\n          r = \"~\";\n        function n() {}\n        function o(e, t, r) {\n          this.fn = e, this.context = t, this.once = r || !1;\n        }\n        function i(e, t, n, i, s) {\n          if (\"function\" != typeof n) throw new TypeError(\"The listener must be a function\");\n          var a = new o(n, i || e, s),\n            c = r ? r + t : t;\n          return e._events[c] ? e._events[c].fn ? e._events[c] = [e._events[c], a] : e._events[c].push(a) : (e._events[c] = a, e._eventsCount++), e;\n        }\n        function s(e, t) {\n          0 == --e._eventsCount ? e._events = new n() : delete e._events[t];\n        }\n        function a() {\n          this._events = new n(), this._eventsCount = 0;\n        }\n        Object.create && (n.prototype = Object.create(null), new n().__proto__ || (r = !1)), a.prototype.eventNames = function () {\n          var e,\n            n,\n            o = [];\n          if (0 === this._eventsCount) return o;\n          for (n in e = this._events) t.call(e, n) && o.push(r ? n.slice(1) : n);\n          return Object.getOwnPropertySymbols ? o.concat(Object.getOwnPropertySymbols(e)) : o;\n        }, a.prototype.listeners = function (e) {\n          var t = r ? r + e : e,\n            n = this._events[t];\n          if (!n) return [];\n          if (n.fn) return [n.fn];\n          for (var o = 0, i = n.length, s = new Array(i); o < i; o++) s[o] = n[o].fn;\n          return s;\n        }, a.prototype.listenerCount = function (e) {\n          var t = r ? r + e : e,\n            n = this._events[t];\n          return n ? n.fn ? 1 : n.length : 0;\n        }, a.prototype.emit = function (e, t, n, o, i, s) {\n          var a = r ? r + e : e;\n          if (!this._events[a]) return !1;\n          var c,\n            u,\n            d = this._events[a],\n            l = arguments.length;\n          if (d.fn) {\n            switch (d.once && this.removeListener(e, d.fn, void 0, !0), l) {\n              case 1:\n                return d.fn.call(d.context), !0;\n              case 2:\n                return d.fn.call(d.context, t), !0;\n              case 3:\n                return d.fn.call(d.context, t, n), !0;\n              case 4:\n                return d.fn.call(d.context, t, n, o), !0;\n              case 5:\n                return d.fn.call(d.context, t, n, o, i), !0;\n              case 6:\n                return d.fn.call(d.context, t, n, o, i, s), !0;\n            }\n            for (u = 1, c = new Array(l - 1); u < l; u++) c[u - 1] = arguments[u];\n            d.fn.apply(d.context, c);\n          } else {\n            var h,\n              f = d.length;\n            for (u = 0; u < f; u++) switch (d[u].once && this.removeListener(e, d[u].fn, void 0, !0), l) {\n              case 1:\n                d[u].fn.call(d[u].context);\n                break;\n              case 2:\n                d[u].fn.call(d[u].context, t);\n                break;\n              case 3:\n                d[u].fn.call(d[u].context, t, n);\n                break;\n              case 4:\n                d[u].fn.call(d[u].context, t, n, o);\n                break;\n              default:\n                if (!c) for (h = 1, c = new Array(l - 1); h < l; h++) c[h - 1] = arguments[h];\n                d[u].fn.apply(d[u].context, c);\n            }\n          }\n          return !0;\n        }, a.prototype.on = function (e, t, r) {\n          return i(this, e, t, r, !1);\n        }, a.prototype.once = function (e, t, r) {\n          return i(this, e, t, r, !0);\n        }, a.prototype.removeListener = function (e, t, n, o) {\n          var i = r ? r + e : e;\n          if (!this._events[i]) return this;\n          if (!t) return s(this, i), this;\n          var a = this._events[i];\n          if (a.fn) a.fn !== t || o && !a.once || n && a.context !== n || s(this, i);else {\n            for (var c = 0, u = [], d = a.length; c < d; c++) (a[c].fn !== t || o && !a[c].once || n && a[c].context !== n) && u.push(a[c]);\n            u.length ? this._events[i] = 1 === u.length ? u[0] : u : s(this, i);\n          }\n          return this;\n        }, a.prototype.removeAllListeners = function (e) {\n          var t;\n          return e ? (t = r ? r + e : e, this._events[t] && s(this, t)) : (this._events = new n(), this._eventsCount = 0), this;\n        }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, e.exports = a;\n      },\n      5844: (e, t) => {\n        \"use strict\";\n\n        function r(e) {\n          if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);\n        }\n        function n(e) {\n          if (\"boolean\" != typeof e) throw new Error(`Expected boolean, not ${e}`);\n        }\n        function o(e, ...t) {\n          if (!(e instanceof Uint8Array)) throw new TypeError(\"Expected Uint8Array\");\n          if (t.length > 0 && !t.includes(e.length)) throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);\n        }\n        function i(e) {\n          if (\"function\" != typeof e || \"function\" != typeof e.create) throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n          r(e.outputLen), r(e.blockLen);\n        }\n        function s(e, t = !0) {\n          if (e.destroyed) throw new Error(\"Hash instance has been destroyed\");\n          if (t && e.finished) throw new Error(\"Hash#digest() has already been called\");\n        }\n        function a(e, t) {\n          o(e);\n          const r = t.outputLen;\n          if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);\n        }\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.output = t.exists = t.hash = t.bytes = t.bool = t.number = void 0, t.number = r, t.bool = n, t.bytes = o, t.hash = i, t.exists = s, t.output = a;\n        const c = {\n          number: r,\n          bool: n,\n          bytes: o,\n          hash: i,\n          exists: s,\n          output: a\n        };\n        t.default = c;\n      },\n      6631: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.add = t.toBig = t.split = t.fromBig = void 0;\n        const r = BigInt(2 ** 32 - 1),\n          n = BigInt(32);\n        function o(e, t = !1) {\n          return t ? {\n            h: Number(e & r),\n            l: Number(e >> n & r)\n          } : {\n            h: 0 | Number(e >> n & r),\n            l: 0 | Number(e & r)\n          };\n        }\n        function i(e, t = !1) {\n          let r = new Uint32Array(e.length),\n            n = new Uint32Array(e.length);\n          for (let i = 0; i < e.length; i++) {\n            const {\n              h: s,\n              l: a\n            } = o(e[i], t);\n            [r[i], n[i]] = [s, a];\n          }\n          return [r, n];\n        }\n        function s(e, t, r, n) {\n          const o = (t >>> 0) + (n >>> 0);\n          return {\n            h: e + r + (o / 2 ** 32 | 0) | 0,\n            l: 0 | o\n          };\n        }\n        t.fromBig = o, t.split = i, t.toBig = (e, t) => BigInt(e >>> 0) << n | BigInt(t >>> 0), t.add = s;\n        const a = {\n          fromBig: o,\n          split: i,\n          toBig: t.toBig,\n          shrSH: (e, t, r) => e >>> r,\n          shrSL: (e, t, r) => e << 32 - r | t >>> r,\n          rotrSH: (e, t, r) => e >>> r | t << 32 - r,\n          rotrSL: (e, t, r) => e << 32 - r | t >>> r,\n          rotrBH: (e, t, r) => e << 64 - r | t >>> r - 32,\n          rotrBL: (e, t, r) => e >>> r - 32 | t << 64 - r,\n          rotr32H: (e, t) => t,\n          rotr32L: (e, t) => e,\n          rotlSH: (e, t, r) => e << r | t >>> 32 - r,\n          rotlSL: (e, t, r) => t << r | e >>> 32 - r,\n          rotlBH: (e, t, r) => t << r - 32 | e >>> 64 - r,\n          rotlBL: (e, t, r) => e << r - 32 | t >>> 64 - r,\n          add: s,\n          add3L: (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0),\n          add3H: (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0,\n          add4L: (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0),\n          add4H: (e, t, r, n, o) => t + r + n + o + (e / 2 ** 32 | 0) | 0,\n          add5H: (e, t, r, n, o, i) => t + r + n + o + i + (e / 2 ** 32 | 0) | 0,\n          add5L: (e, t, r, n, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0)\n        };\n        t.default = a;\n      },\n      4174: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.crypto = void 0, t.crypto = \"object\" == typeof globalThis && \"crypto\" in globalThis ? globalThis.crypto : void 0;\n      },\n      5406: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.shake256 = t.shake128 = t.keccak_512 = t.keccak_384 = t.keccak_256 = t.keccak_224 = t.sha3_512 = t.sha3_384 = t.sha3_256 = t.sha3_224 = t.Keccak = t.keccakP = void 0;\n        const n = r(5844),\n          o = r(6631),\n          i = r(2532),\n          [s, a, c] = [[], [], []],\n          u = BigInt(0),\n          d = BigInt(1),\n          l = BigInt(2),\n          h = BigInt(7),\n          f = BigInt(256),\n          p = BigInt(113);\n        for (let e = 0, t = d, r = 1, n = 0; e < 24; e++) {\n          [r, n] = [n, (2 * r + 3 * n) % 5], s.push(2 * (5 * n + r)), a.push((e + 1) * (e + 2) / 2 % 64);\n          let o = u;\n          for (let e = 0; e < 7; e++) t = (t << d ^ (t >> h) * p) % f, t & l && (o ^= d << (d << BigInt(e)) - d);\n          c.push(o);\n        }\n        const [m, g] = o.default.split(c, !0),\n          y = (e, t, r) => r > 32 ? o.default.rotlBH(e, t, r) : o.default.rotlSH(e, t, r),\n          v = (e, t, r) => r > 32 ? o.default.rotlBL(e, t, r) : o.default.rotlSL(e, t, r);\n        function b(e, t = 24) {\n          const r = new Uint32Array(10);\n          for (let n = 24 - t; n < 24; n++) {\n            for (let t = 0; t < 10; t++) r[t] = e[t] ^ e[t + 10] ^ e[t + 20] ^ e[t + 30] ^ e[t + 40];\n            for (let t = 0; t < 10; t += 2) {\n              const n = (t + 8) % 10,\n                o = (t + 2) % 10,\n                i = r[o],\n                s = r[o + 1],\n                a = y(i, s, 1) ^ r[n],\n                c = v(i, s, 1) ^ r[n + 1];\n              for (let r = 0; r < 50; r += 10) e[t + r] ^= a, e[t + r + 1] ^= c;\n            }\n            let t = e[2],\n              o = e[3];\n            for (let r = 0; r < 24; r++) {\n              const n = a[r],\n                i = y(t, o, n),\n                c = v(t, o, n),\n                u = s[r];\n              t = e[u], o = e[u + 1], e[u] = i, e[u + 1] = c;\n            }\n            for (let t = 0; t < 50; t += 10) {\n              for (let n = 0; n < 10; n++) r[n] = e[t + n];\n              for (let n = 0; n < 10; n++) e[t + n] ^= ~r[(n + 2) % 10] & r[(n + 4) % 10];\n            }\n            e[0] ^= m[n], e[1] ^= g[n];\n          }\n          r.fill(0);\n        }\n        t.keccakP = b;\n        class E extends i.Hash {\n          constructor(e, t, r, o = !1, s = 24) {\n            if (super(), this.blockLen = e, this.suffix = t, this.outputLen = r, this.enableXOF = o, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, n.default.number(r), 0 >= this.blockLen || this.blockLen >= 200) throw new Error(\"Sha3 supports only keccak-f1600 function\");\n            this.state = new Uint8Array(200), this.state32 = (0, i.u32)(this.state);\n          }\n          keccak() {\n            b(this.state32, this.rounds), this.posOut = 0, this.pos = 0;\n          }\n          update(e) {\n            n.default.exists(this);\n            const {\n                blockLen: t,\n                state: r\n              } = this,\n              o = (e = (0, i.toBytes)(e)).length;\n            for (let n = 0; n < o;) {\n              const i = Math.min(t - this.pos, o - n);\n              for (let t = 0; t < i; t++) r[this.pos++] ^= e[n++];\n              this.pos === t && this.keccak();\n            }\n            return this;\n          }\n          finish() {\n            if (this.finished) return;\n            this.finished = !0;\n            const {\n              state: e,\n              suffix: t,\n              pos: r,\n              blockLen: n\n            } = this;\n            e[r] ^= t, 0 != (128 & t) && r === n - 1 && this.keccak(), e[n - 1] ^= 128, this.keccak();\n          }\n          writeInto(e) {\n            n.default.exists(this, !1), n.default.bytes(e), this.finish();\n            const t = this.state,\n              {\n                blockLen: r\n              } = this;\n            for (let n = 0, o = e.length; n < o;) {\n              this.posOut >= r && this.keccak();\n              const i = Math.min(r - this.posOut, o - n);\n              e.set(t.subarray(this.posOut, this.posOut + i), n), this.posOut += i, n += i;\n            }\n            return e;\n          }\n          xofInto(e) {\n            if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n            return this.writeInto(e);\n          }\n          xof(e) {\n            return n.default.number(e), this.xofInto(new Uint8Array(e));\n          }\n          digestInto(e) {\n            if (n.default.output(e, this), this.finished) throw new Error(\"digest() was already called\");\n            return this.writeInto(e), this.destroy(), e;\n          }\n          digest() {\n            return this.digestInto(new Uint8Array(this.outputLen));\n          }\n          destroy() {\n            this.destroyed = !0, this.state.fill(0);\n          }\n          _cloneInto(e) {\n            const {\n              blockLen: t,\n              suffix: r,\n              outputLen: n,\n              rounds: o,\n              enableXOF: i\n            } = this;\n            return e || (e = new E(t, r, n, i, o)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = o, e.suffix = r, e.outputLen = n, e.enableXOF = i, e.destroyed = this.destroyed, e;\n          }\n        }\n        t.Keccak = E;\n        const _ = (e, t, r) => (0, i.wrapConstructor)(() => new E(t, e, r));\n        t.sha3_224 = _(6, 144, 28), t.sha3_256 = _(6, 136, 32), t.sha3_384 = _(6, 104, 48), t.sha3_512 = _(6, 72, 64), t.keccak_224 = _(1, 144, 28), t.keccak_256 = _(1, 136, 32), t.keccak_384 = _(1, 104, 48), t.keccak_512 = _(1, 72, 64);\n        const A = (e, t, r) => (0, i.wrapConstructorWithOpts)((n = {}) => new E(t, e, void 0 === n.dkLen ? r : n.dkLen, !0));\n        t.shake128 = A(31, 168, 16), t.shake256 = A(31, 136, 32);\n      },\n      2532: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.randomBytes = t.wrapConstructorWithOpts = t.wrapConstructor = t.checkOpts = t.Hash = t.concatBytes = t.toBytes = t.utf8ToBytes = t.asyncLoop = t.nextTick = t.hexToBytes = t.bytesToHex = t.isLE = t.rotr = t.createView = t.u32 = t.u8 = void 0;\n        const n = r(4174);\n        if (t.u8 = e => new Uint8Array(e.buffer, e.byteOffset, e.byteLength), t.u32 = e => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), t.createView = e => new DataView(e.buffer, e.byteOffset, e.byteLength), t.rotr = (e, t) => e << 32 - t | e >>> t, t.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0], !t.isLE) throw new Error(\"Non little-endian hardware is not supported\");\n        const o = Array.from({\n          length: 256\n        }, (e, t) => t.toString(16).padStart(2, \"0\"));\n        function i(e) {\n          if (\"string\" != typeof e) throw new TypeError(\"utf8ToBytes expected string, got \" + typeof e);\n          return new TextEncoder().encode(e);\n        }\n        function s(e) {\n          if (\"string\" == typeof e && (e = i(e)), !(e instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);\n          return e;\n        }\n        t.bytesToHex = function (e) {\n          if (!(e instanceof Uint8Array)) throw new Error(\"Uint8Array expected\");\n          let t = \"\";\n          for (let r = 0; r < e.length; r++) t += o[e[r]];\n          return t;\n        }, t.hexToBytes = function (e) {\n          if (\"string\" != typeof e) throw new TypeError(\"hexToBytes: expected string, got \" + typeof e);\n          if (e.length % 2) throw new Error(\"hexToBytes: received invalid unpadded hex\");\n          const t = new Uint8Array(e.length / 2);\n          for (let r = 0; r < t.length; r++) {\n            const n = 2 * r,\n              o = e.slice(n, n + 2),\n              i = Number.parseInt(o, 16);\n            if (Number.isNaN(i) || i < 0) throw new Error(\"Invalid byte sequence\");\n            t[r] = i;\n          }\n          return t;\n        }, t.nextTick = async () => {}, t.asyncLoop = async function (e, r, n) {\n          let o = Date.now();\n          for (let i = 0; i < e; i++) {\n            n(i);\n            const e = Date.now() - o;\n            e >= 0 && e < r || (await (0, t.nextTick)(), o += e);\n          }\n        }, t.utf8ToBytes = i, t.toBytes = s, t.concatBytes = function (...e) {\n          if (!e.every(e => e instanceof Uint8Array)) throw new Error(\"Uint8Array list expected\");\n          if (1 === e.length) return e[0];\n          const t = e.reduce((e, t) => e + t.length, 0),\n            r = new Uint8Array(t);\n          for (let t = 0, n = 0; t < e.length; t++) {\n            const o = e[t];\n            r.set(o, n), n += o.length;\n          }\n          return r;\n        }, t.Hash = class {\n          clone() {\n            return this._cloneInto();\n          }\n        }, t.checkOpts = function (e, t) {\n          if (void 0 !== t && (\"object\" != typeof t || (r = t, \"[object Object]\" !== Object.prototype.toString.call(r) || r.constructor !== Object))) throw new TypeError(\"Options should be object or undefined\");\n          var r;\n          return Object.assign(e, t);\n        }, t.wrapConstructor = function (e) {\n          const t = t => e().update(s(t)).digest(),\n            r = e();\n          return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;\n        }, t.wrapConstructorWithOpts = function (e) {\n          const t = (t, r) => e(r).update(s(t)).digest(),\n            r = e({});\n          return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = t => e(t), t;\n        }, t.randomBytes = function (e = 32) {\n          if (n.crypto && \"function\" == typeof n.crypto.getRandomValues) return n.crypto.getRandomValues(new Uint8Array(e));\n          throw new Error(\"crypto.getRandomValues must be defined\");\n        };\n      },\n      4488: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.keccak512 = t.keccak384 = t.keccak256 = t.keccak224 = void 0;\n        const n = r(5406),\n          o = r(7737);\n        t.keccak224 = (0, o.wrapHash)(n.keccak_224), t.keccak256 = (() => {\n          const e = (0, o.wrapHash)(n.keccak_256);\n          return e.create = n.keccak_256.create, e;\n        })(), t.keccak384 = (0, o.wrapHash)(n.keccak_384), t.keccak512 = (0, o.wrapHash)(n.keccak_512);\n      },\n      7737: function (e, t, r) {\n        \"use strict\";\n\n        e = r.nmd(e);\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.crypto = t.wrapHash = t.equalsBytes = t.hexToBytes = t.bytesToUtf8 = t.utf8ToBytes = t.createView = t.concatBytes = t.toHex = t.bytesToHex = t.assertBytes = t.assertBool = void 0;\n        const o = n(r(5844)),\n          i = r(2532),\n          s = o.default.bool;\n        t.assertBool = s;\n        const a = o.default.bytes;\n        t.assertBytes = a;\n        var c = r(2532);\n        Object.defineProperty(t, \"bytesToHex\", {\n          enumerable: !0,\n          get: function () {\n            return c.bytesToHex;\n          }\n        }), Object.defineProperty(t, \"toHex\", {\n          enumerable: !0,\n          get: function () {\n            return c.bytesToHex;\n          }\n        }), Object.defineProperty(t, \"concatBytes\", {\n          enumerable: !0,\n          get: function () {\n            return c.concatBytes;\n          }\n        }), Object.defineProperty(t, \"createView\", {\n          enumerable: !0,\n          get: function () {\n            return c.createView;\n          }\n        }), Object.defineProperty(t, \"utf8ToBytes\", {\n          enumerable: !0,\n          get: function () {\n            return c.utf8ToBytes;\n          }\n        }), t.bytesToUtf8 = function (e) {\n          if (!(e instanceof Uint8Array)) throw new TypeError(\"bytesToUtf8 expected Uint8Array, got \" + typeof e);\n          return new TextDecoder().decode(e);\n        }, t.hexToBytes = function (e) {\n          const t = e.startsWith(\"0x\") ? e.substring(2) : e;\n          return (0, i.hexToBytes)(t);\n        }, t.equalsBytes = function (e, t) {\n          if (e.length !== t.length) return !1;\n          for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1;\n          return !0;\n        }, t.wrapHash = function (e) {\n          return t => (o.default.bytes(t), e(t));\n        }, t.crypto = (() => {\n          const t = \"object\" == typeof self && \"crypto\" in self ? self.crypto : void 0,\n            r = \"function\" == typeof e.require && e.require.bind(e);\n          return {\n            node: r && !t ? r(\"crypto\") : void 0,\n            web: t\n          };\n        })();\n      },\n      6608: (e, t) => {\n        \"use strict\";\n\n        function r(e) {\n          return function (e) {\n            let t = 0;\n            return () => e[t++];\n          }(function (e) {\n            let t = 0;\n            function r() {\n              return e[t++] << 8 | e[t++];\n            }\n            let n = r(),\n              o = 1,\n              i = [0, 1];\n            for (let e = 1; e < n; e++) i.push(o += r());\n            let s = r(),\n              a = t;\n            t += s;\n            let c = 0,\n              u = 0;\n            function d() {\n              return 0 == c && (u = u << 8 | e[t++], c = 8), u >> --c & 1;\n            }\n            const l = 2 ** 31,\n              h = l >>> 1,\n              f = l - 1;\n            let p = 0;\n            for (let e = 0; e < 31; e++) p = p << 1 | d();\n            let m = [],\n              g = 0,\n              y = l;\n            for (;;) {\n              let e = Math.floor(((p - g + 1) * o - 1) / y),\n                t = 0,\n                r = n;\n              for (; r - t > 1;) {\n                let n = t + r >>> 1;\n                e < i[n] ? r = n : t = n;\n              }\n              if (0 == t) break;\n              m.push(t);\n              let s = g + Math.floor(y * i[t] / o),\n                a = g + Math.floor(y * i[t + 1] / o) - 1;\n              for (; 0 == ((s ^ a) & h);) p = p << 1 & f | d(), s = s << 1 & f, a = a << 1 & f | 1;\n              for (; s & ~a & 536870912;) p = p & h | p << 1 & f >>> 1 | d(), s = s << 1 ^ h, a = (a ^ h) << 1 | h | 1;\n              g = s, y = 1 + a - s;\n            }\n            let v = n - 4;\n            return m.map(t => {\n              switch (t - v) {\n                case 3:\n                  return v + 65792 + (e[a++] << 16 | e[a++] << 8 | e[a++]);\n                case 2:\n                  return v + 256 + (e[a++] << 8 | e[a++]);\n                case 1:\n                  return v + e[a++];\n                default:\n                  return t - 1;\n              }\n            });\n          }(function (e) {\n            let t = [];\n            [...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"].forEach((e, r) => t[e.charCodeAt(0)] = r);\n            let r = e.length,\n              n = new Uint8Array(6 * r >> 3);\n            for (let o = 0, i = 0, s = 0, a = 0; o < r; o++) a = a << 6 | t[e.charCodeAt(o)], s += 6, s >= 8 && (n[i++] = a >> (s -= 8));\n            return n;\n          }(e)));\n        }\n        function n(e) {\n          return 1 & e ? ~e >> 1 : e >> 1;\n        }\n        function o(e, t) {\n          let r = Array(e);\n          for (let o = 0, i = 0; o < e; o++) r[o] = i += n(t());\n          return r;\n        }\n        function i(e, t = 0) {\n          let r = [];\n          for (;;) {\n            let n = e(),\n              o = e();\n            if (!o) break;\n            t += n;\n            for (let e = 0; e < o; e++) r.push(t + e);\n            t += o + 1;\n          }\n          return r;\n        }\n        function s(e) {\n          return c(() => {\n            let t = i(e);\n            if (t.length) return t;\n          });\n        }\n        function a(e) {\n          let t = [];\n          for (;;) {\n            let r = e();\n            if (0 == r) break;\n            t.push(d(r, e));\n          }\n          for (;;) {\n            let r = e() - 1;\n            if (r < 0) break;\n            t.push(l(r, e));\n          }\n          return t.flat();\n        }\n        function c(e) {\n          let t = [];\n          for (;;) {\n            let r = e(t.length);\n            if (!r) break;\n            t.push(r);\n          }\n          return t;\n        }\n        function u(e, t, r) {\n          let n = Array(e).fill().map(() => []);\n          for (let i = 0; i < t; i++) o(e, r).forEach((e, t) => n[t].push(e));\n          return n;\n        }\n        function d(e, t) {\n          let r = 1 + t(),\n            n = t(),\n            o = c(t);\n          return u(o.length, 1 + e, t).flatMap((e, t) => {\n            let [i, ...s] = e;\n            return Array(o[t]).fill().map((e, t) => {\n              let o = t * n;\n              return [i + t * r, s.map(e => e + o)];\n            });\n          });\n        }\n        function l(e, t) {\n          return u(1 + t(), 1 + e, t).map(e => [e[0], e.slice(1)]);\n        }\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n        var h = r(\"AEIRrQh1DccBuQJ+APkBMQDiASoAnADQAHQAngBmANQAaACKAEQAgwBJAHcAOQA9ACoANQAmAGMAHgAvACgAJQAWACwAGQAjAB8ALwAVACgAEQAdAAkAHAARABgAFwA7ACcALAAtADcAEwApABAAHQAfABAAGAAeABsAFwAUBLoF3QEXE7k3ygXaALgArkYBbgCsCAPMAK6GNjY2NjFiAQ0ODBDyAAQHRgbrOAVeBV8APTI5B/a9GAUNz8gAFQPPBeelYALMCjYCjqgCht8/lW+QAsXSAoP5ASbmEADytAFIAjSUCkaWAOoA6QocAB7bwM8TEkSkBCJ+AQQCQBjED/IQBjDwDASIbgwDxAeuBzQAsgBwmO+snIYAYgaaAioG8AAiAEIMmhcCqgLKQiDWCMIwA7gCFAIA9zRyqgCohB8AHgQsAt4dASQAwBnUBQEQIFM+CZ4JjyUiIVbATOqDSQAaABMAHAAVclsAKAAVAE71HN89+gI5X8qc5jUKFyRfVAJfPfMAGgATABwAFXIgY0CeAMPyACIAQAzMFsKqAgHavwViBekC0KYCxLcCClMjpGwUehp0TPwAwhRuAugAEjQ0kBfQmAKBggETIgDEFG4C6AASNAFPUCyYTBEDLgIFMBDecB60Ad5KAHgyEn4COBYoAy4uwD5yAEDoAfwsAM4OqLwBImqIALgMAAwCAIraUAUi3HIeAKgu2AGoBgYGBgYrNAOiAG4BCiA+9Dd7BB8eALEBzgIoAgDmMhJ6OvpQtzOoLjVPBQAGAS4FYAVftr8FcDtkQhlBWEiee5pmZqH/EhoDzA4s+H4qBKpSAlpaAnwisi4BlqqsPGIDTB4EimgQANgCBrJGNioCBzACQGQAcgFoJngAiiQgAJwBUL4ALnAeAbbMAz40KEoEWgF2YAZsAmwA+FAeAzAIDABQSACyAABkAHoAMrwGDvr2IJSGBgAQKAAwALoiTgHYAeIOEjiXf4HvABEAGAA7AEQAPzp3gNrHEGYQYwgFTRBMc0EVEgKzD60L7BEcDNgq0tPfADSwB/IDWgfyA1oDWgfyB/IDWgfyA1oDWgNaA1ocEfAh2scQZg9PBHQFlQWSBN0IiiZQEYgHLwjZVBR0JRxOA0wBAyMsSSM7mjMSJUlME00KCAM2SWyufT8DTjGyVPyQqQPSMlY5cwgFHngSpwAxD3ojNbxOhXpOcacKUk+1tYZJaU5uAsU6rz//CigJmm/Cd1UGRBAeJ6gQ+gw2AbgBPg3wS9sE9AY+BMwfgBkcD9CVnwioLeAM8CbmLqSAXSP4KoYF8Ev3POALUFFrD1wLaAnmOmaBUQMkARAijgrgDTwIcBD2CsxuDegRSAc8A9hJnQCoBwQLFB04FbgmE2KvCww5egb+GvkLkiayEyx6/wXWGiQGUAEsGwIA0i7qhbNaNFwfT2IGBgsoI8oUq1AjDShAunhLGh4HGCWsApRDc0qKUTkeliH5PEANaS4WUX8H+DwIGVILhDyhRq5FERHVPpA9SyJMTC8EOIIsMieOCdIPiAy8fHUBXAkkCbQMdBM0ERo3yAg8BxwwlycnGAgkRphgnQT6ogP2E9QDDgVCCUQHFgO4HDATMRUsBRCBJ9oC9jbYLrYCklaDARoFzg8oH+IQU0fjDuwIngJoA4Yl7gAwFSQAGiKeCEZmAGKP21MILs4IympvI3cDahTqZBF2B5QOWgeqHDYVwhzkcMteDoYLKKayCV4BeAmcAWIE5ggMNV6MoyBEZ1aLWxieIGRBQl3/AjQMaBWiRMCHewKOD24SHgE4AXYHPA0EAnoR8BFuEJgI7oYHNbgz+zooBFIhhiAUCioDUmzRCyom/Az7bAGmEmUDDzRAd/FnrmC5JxgABxwyyEFjIfQLlU/QDJ8axBhFVDEZ5wfCA/Ya9iftQVoGAgOmBhY6UDPxBMALbAiOCUIATA6mGgfaGG0KdIzTATSOAbqcA1qUhgJykgY6Bw4Aag6KBXzoACACqgimAAgA0gNaADwCsAegABwAiEQBQAMqMgEk6AKSA5YINM4BmDIB9iwEHsYMGAD6Om5NAsO0AoBtZqUF4FsCkQJMOAFQKAQIUUpUA7J05ADeAE4GFuJKARiuTc4d5kYB4nIuAMoA/gAIOAcIRAHQAfZwALoBYgs0CaW2uAFQ7CwAhgAYbgHaAowA4AA4AIL0AVYAUAVc/AXWAlJMARQ0Gy5aZAG+AyIBNgEQAHwGzpCozAoiBHAH1gIQHhXkAu8xB7gEAyLiE9BCyAK94VgAMhkKOwqqCqlgXmM2CTR1PVMAER+rPso/UQVUO1Y7WztWO1s7VjtbO1Y7WztWO1sDmsLlwuUKb19IYe4MqQ3XRMs6TBPeYFRgNRPLLboUxBXRJVkZQBq/Jwgl51UMDwct1mYzCC80eBe/AEIpa4NEY4keMwpOHOpTlFT7LR4AtEulM7INrxsYREMFSnXwYi0WEQolAmSEAmJFXlCyAF43IwKh+gJomwJmDAKfhzgeDgJmPgJmKQRxBIIDfxYDfpU5CTl6GjmFOiYmAmwgAjI5OA0CbcoCbbHyjQI2akguAWoA4QDkAE0IB5sMkAEBDsUAELgCdzICdqVCAnlORgJ4vSBf3kWxRvYCfEICessCfQwCfPNIA0iAZicALhhJW0peGBpKzwLRBALQz0sqA4hSA4fpRMiRNQLypF0GAwOxS9FMMCgG0k1PTbICi0ICitvEHgogRmoIugKOOgKOX0OahAKO3AKOX3tRt1M4AA1S11SIApP+ApMPAOwAH1UhVbJV0wksHimYiTLkeGlFPjwCl6IC77VYJKsAXCgClpICln+fAKxZr1oMhFAAPgKWuAKWUVxHXNQCmc4CmWdczV0KHAKcnjnFOqACnBkCn54CnruNACASNC0SAp30Ap6VALhAYTdh8gKe1gKgcQGsAp6iIgKeUahjy2QqKC4CJ7ICJoECoP4CoE/aAqYyAqXRAqgCAIACp/Vof2i0AAZMah9q1AKs5gKssQKtagKtBQJXIAJV3wKx5NoDH1FsmgKywBACsusabONtZm1LYgMl0AK2Xz5CbpMDKUgCuGECuUoYArktenA5cOQCvRwDLbUDMhQCvotyBQMzdAK+HXMlc1ICw84CwwdzhXROOEh04wM8qgADPJ0DPcICxX8CxkoCxhOMAshsVALIRwLJUgLJMQJkoALd1Xh8ZHixeShL0wMYpmcFAmH3GfaVJ3sOXpVevhQCz24Cz28yTlbV9haiAMmwAs92ASztA04Vfk4IAtwqAtuNAtJSA1JfA1NiAQQDVY+AjEIDzhnwY0h4AoLRg5AC2soC2eGEE4RMpz8DhqgAMgNkEYZ0XPwAWALfaALeu3Z6AuIy7RcB8zMqAfSeAfLVigLr9gLpc3wCAur8AurnAPxKAbwC7owC65+WrZcGAu5CA4XjmHxw43GkAvMGAGwDjhmZlgL3FgORcQOSigL3mwL53AL4aZofmq6+OpshA52GAv79AR4APJ8fAJ+2AwWQA6ZtA6bcANTIAwZtoYuiCAwDDEwBIAEiB3AGZLxqCAC+BG7CFI4ethAAGng8ACYDNrIDxAwQA4yCAWYqJACM8gAkAOamCqKUCLoGIqbIBQCuBRjCBfAkREUEFn8Fbz5FRzJCKEK7X3gYX8MAlswFOQCQUyCbwDstYDkYutYONhjNGJDJ/QVeBV8FXgVfBWoFXwVeBV8FXgVfBV4FXwVeBV9NHAjejG4JCQkKa17wMgTQA7gGNsLCAMIErsIA7kcwFrkFTT5wPndCRkK9X3w+X+8AWBgzsgCNBcxyzAOm7kaBRC0qCzIdLj08fnTfccH4GckscAFy13U3HgVmBXHJyMm/CNZQYgcHBwqDXoSSxQA6P4gAChbYBuy0KgwAjMoSAwgUAOVsJEQrJlFCuELDSD8qXy5gPS4/KgnIRAUKSz9KPn8+iD53PngCkELDUElCX9JVVnFUETNyWzYCcQASdSZf5zpBIgluogppKjJDJC1CskLDMswIzANf0BUmNRAPEAMGAQYpfqTfcUE0UR7JssmzCWzI0tMKZ0FmD+wQqhgAk5QkTEIsG7BtQM4/Cjo/Sj53QkYcDhEkU05zYjM0Wui8GQqE9CQyQkYcZA9REBU6W0pJPgs7SpwzCogiNEJGG/wPWikqHzc4BwyPaPBlCnhk0GASYDQqdQZKYCBACSIlYLoNCXIXbFVgVBgIBQZk7mAcYJxghGC6YFJgmG8WHga8FdxcsLxhC0MdsgHCMtTICSYcByMKJQGAAnMBNjecWYcCAZEKv04hAOsqdJUR0RQErU3xAaICjqNWBUdmAP4ARBEHOx1egRKsEysmwbZOAFYTOwMAHBO+NVsC2RJLbBEiAN9VBnwEESVhADgAvQKhLgsWdrIgAWIBjQoDA+D0FgaxBlEGwAAky1ywYRC7aBOQCy1GDsIBwgEpCU4DYQUvLy8nJSYoMxktDSgTlABbAnVel1CcCHUmBA94TgHadRbVWCcgsLdN8QcYBVNmAP4ARBEHgQYNK3MRjhKsPzc0zrZdFBIAZsMSAGpKblAoIiLGADgAvQKhLi1CFdUClxiCAVDCWM90eY7epaIO/KAVRBvzEuASDQ8iAwHOCUEQmgwXMhM9EgBCALrVAQkAqwDoAJuRNgAbAGIbzTVzfTEUyAIXCUIrStroIyUSG4QCggTIEbHxcwA+QDQOrT8u1agjB8IQABBBLtUYIAB9suEjD8IhThzUqHclAUQqZiMC8qAPBFPz6x9sDMMNAQhDCkUABccLRAJSDcIIww1DLtWoMQrDCUMPkhroBCIOwgyYCCILwhZCAKcQwgsFGKd74wA7cgtCDEMAAq0JwwUi1/UMBQ110QaCAAfCEmIYEsMBCADxCAAAexViDRbSG/x2F8IYQgAuwgLyqMIAHsICXCcxhgABwgAC6hVDFcIr8qPCz6hCCgKlJ1IAAmIA5+QZwqViFb/LAPsaggioBRH/dwDfwqfCGOIBGsKjknl5BwKpoooAEsINGxIAA5oAbcINAAvCp0IIGkICwQionNEPAgfHqUIFAOGCL71txQNPAAPyABXCAAcCAAnCAGmSABrCAA7CCRjCjnAWAgABYgAOcgAuUiUABsIAF8IIKAANUQC6wi0AA8IADqIq8gCyYQAcIgAbwgAB8gqoAAXNCxwV4gAHogBCwgEJAGnCAAuCAB3CAAjCCagABdEAbqYZ3ACYCCgABdEAAUIAB+IAHaIIKAAGoQAJggAbMgBtIgDmwocACGIACEIAFMIDAGkCCSgABtEA45IACUILqA7L+2YAB0IAbqNATwBOAArCCwADQgAJtAM+AAciABmCAAISpwIACiIACkIACgKn8gbCAAkiAAMSABBCBwAUQgARcgAPkgAN8gANwgAZEg0WIgAVQgBuoha6AcIAwQATQgBpMhEA4VIAAkIABFkAF4IFIgAG1wAYwgQlAYIvWQBATAC2DwcUDHkALzF3AasMCGUCcyoTBgQQDnZSc2YxkCYFhxsFaTQ9A6gKuwYI3wAdAwIKdQF9eU5ZGygDVgIcRQEzBgp6TcSCWYFHADAAOAgAAgAAAFoR4gCClzMBMgB97BQYOU0IUQBeDAAIVwEOkdMAf0IEJ6wAYQDdHACcbz4mkgDUcrgA1tsBHQ/JfHoiH10kENgBj5eyKVpaVE8ZQ8mQAAAAhiM+RzAy5xieVgB5ATAsNylJIBYDN1wE/sz1AFJs4wBxAngCRhGBOs54NTXcAgEMFxkmCxsOsrMAAAMCBAICABnRAgAqAQAFBQUFBQUEBAQEBAQDBAUGBwgDBAQEBAMBASEAigCNAJI8AOcAuADZAKFDAL8ArwCqAKUA6wCjANcAoADkAQUBAADEAH4AXwDPANEBAADbAO8AjQCmAS4A5wDcANkKAAgOMTrZ2dnZu8Xh0tXTSDccAU8BWTRMAVcBZgFlAVgBSVBISm0SAVAaDA8KOT0SDQAmEyosLjE9Pz9CQkJDRBNFBSNWVlZWWFhXWC5ZWlxbWyJiZmZlZ2Ypa211dHd3d3d3d3l5eXl5eXl5eXl5e3t8e3phAEPxAEgAmQB3ADEAZfcAjQBWAFYANgJz7gCKAAT39wBjAJLxAJ4ATgBhAGP+/q8AhACEAGgAVQCwACMAtQCCAj0CQAD7AOYA/QD9AOcA/gDoAOgA5wDlAC4CeAFQAT8BPQFTAT0BPQE9ATgBNwE3ATcBGwFXFgAwDwcAAFIeER0KHB0VAI0AlQClAFAAaR8CMAB1AG4AlgMSAyQxAx5IRU4wAJACTgDGAlYCoQC/ApMCkwKTApMCkwKTAogCkwKTApMCkwKTApMCkgKSApUCnQKUApMCkwKRApECkQKQAnIB0QKUApoCkwKTApIbfhACAPsKA5oCXgI3HAFRFToC3RYPMBgBSzwYUpYBeKlBAWZeAQIDPEwBAwCWMB4flnEAMGcAcAA1AJADm8yS8LWLYQzBMhXJARgIpNx7MQsEKmEBuQDkhYeGhYeFiImJhYqNi4WMj42HjomPiZCFkYWShZORlIWVhZaJl4WYhZmFmoWbipyPnYmehQCJK6cAigRCBD8EQQREBEIESARFBEAERgRIBEcEQwRFBEgAqgOOANBYANYCEwD9YQD9ASAA/QD7APsA/AD72wOLKmzFAP0A+wD7APwA+yMAkGEA/QCQASAA/QCQAvMA/QCQ2wOLKmzFIwD+YQEgAP0A/QD7APsA/AD7AP4A+wD7APwA+9sDiypsxSMAkGEBIAD9AJAA/QCQAvMA/QCQ2wOLKmzFIwJKAT0CUQFAAlLIA6UC8wOl2wOLKmzFIwCQYQEgA6UAkAOlAJAC8wOlAJDbA4sqbMUjBDcAkAQ4AJANlDh0JwEzAJAHRXUKKgEEAM1hCQBbYQAFGjkJAJAJRN8AUAkAkAkAnW0/6mOd3brkH5dB9mNQ/eNThoJ1CP8EZzy46pMulzRpOAZDJDXL2yXaVtAh1MxM82zfnsL/FXSaOaxJlgv345IW0Dfon3fzkx0WByY6wfCroENsWq/bORcfBvtlWbGzP5ju+gqE1DjyFssbkkSeqLAdrCkLOfItA7XNe1PctDPFKoNd/aZ6IQq6JTB6IrDBZ5/nJIbTHMeaaIWRoDvc42ORs9KtvcQWZd+Nv1D2C/hrzaOrFUjpItLWRI4x3GmzQqZbVH5LoCEJpk3hzt1pmM7bPitwOPG8gTKLVFszSrDZyLmfq8LkwkSUhIQlN4nFJUEhU2N7NBTOGk4Y2q9A2M7ps8jcevOKfycp9u3DyCe9hCt7i5HV8U5pm5LnVnKnyzbIyAN/LU4aqT3JK+e9JsdusAsUCgAuCnc4IwbgPBg4EPGOv5gR8D+96c8fLb09f7L6ON2k+Zxe/Y0AYoZIZ8yuu1At7f70iuSFoFmyPpwDU/4lQ+mHkFmq/CwtE7A979KNdD8zaHSx4HoxWsM8vl+2brNxN0QtIUvOfNGAYyv1R5DaM1JAR0C+Ugp6/cNq4pUDyDPKJjFeP4/L1TBoOJak3PVlmDCi/1oF8k1mnzTCz15BdAvmFjQrjide74m2NW1NG/qRrzhbNwwejlhnPfRn4mIfYmXzj5Fbu3C2TUpnYg+djp65dxZJ8XhwUqJ8JYrrR4WtrHKdKjz0i77K+QitukOAZSfFIwvBr1GKYpSukYTqF4gNtgaNDqh78ZDH4Qerglo3VpTLT0wOglaX6bDNhfs04jHVcMfCHwIb+y5bAaBvh2RARFYEjxjr1xTfU09JEjdY1vfcPrPVmnBBSDPj9TcZ1V/Dz8fvy0WLWZM0JPbRL0hLSPeVoC8hgQIGaeE6AYVZnnqm62/wt00pDl5Nw/nDo+bF1tC4qo5DryXVn8ffL3kuT51e+VcBTGiibvP+vqX50dppfxyNORSr48S5WXV8fzcsgjRQH6zjl+nuUYFVloiEnZOPDpHD/7ILh3JuFCdvAi2ANXYXjTDA5Up6YLihbc7d+dBlI9+mdgr8m8+3/Dp26W/Jssn7b9/pOEP4i+/9TsPI9m2NfNKwEI35mqKV+HpZ+W69Y8sM/sIA9Ltvhd+evQTUUfSkYxki28/CBT0cT96HrlrSrE+V9RzhskX0CsDsCfHffBVybkxmHOFOgaUurWNQ2AcZbi1WjkZzYArWZBHFd1SYwtqQ0DIZt7OV40ewQxCr/LgxAc8dLJeAJFseWJq9XiOp21hLv/HhsFbYbg3zCR8JmonZjhuKYrS/KJc30vnOL2CM+GfogNWug2DstZPzauCNeeD8zlP8wxPyfLHYQB/J+wQE3aDpXH/5tdIQpLn3JXNJYZFiXInGB7FqxRxHYJ/re/lHprE5sngUMm11uOIA3bbtkk06I8DYxuwPD+e4sAeNfor0DkWmiCQFiNptkmiD2xGO1kIKGr/Tuu4bHe6z2NaS7Ih0c+Gpv+QbLY9ea122BXNSitM41sxUSlnWl+uJBIFoLqt66v/VfGIQos2lzhOOLDuScVxcyrqH3/FI4vaYB0b8gFHLXtxyX/9JpUCYNwlLZ1v5CeB99l0F795R5wl5UHRq1OYyKqsoIY07wJz2CT0TOf5/JRBPtJIIk5pOJ60SHayS9kMSKbI3fLLYztsY3B4MlSyoEfc9gL4yJVrPo+OGGunCK4p15UbCArJP/PQgUWDW4l+2P/tCqRRy2flIZL/nVeY/vyAfILUM5qEGfcFXXXrAit7skwDEFnD7mL1ATtyrz7HcodhzP7gShFhazIPm7X0+mTCeSWfrOr5WcvJfip19JRRLfXjuQpQjcNCuXo8kqkxQ68ukJQoxlnfjevc0WcKnGpUvyY54eJTS1IRWDqfHANukJLw56ts5yS6Nea7IrL6/78aKmZsch4Q694ujxgx5+0PhlGpzWimajpvkBOOUQlHLkJorzqu4e768L9nJtZWYturb7dsBxjzlNhd/gZcBuRgIUSdgZjg7Rx+f/zLcs4mAa3qDbJNUQVNbSg+dm0L3KH1uhesTPaErVYjZ8Isvfr+zfiX3DT0PlaOv+hdGvLUIlKSEcYHPMs0NtTGzyqMe74yciNFdAVZVzol/XtLsEqivKqfW7zWTCNCvZkPnnBlMv3UHW5RNNEJfuyR3MvYH/9E6gcts5GAwKIgCaBQ+V2Eh9O0IJkxFksPI1V9obqDKCpmPM55mLd+VQgRqgD+9XvsUxjbh/AXXPxOpc0FXFyJzc85aa1VQZa90LAWR4oinrBaOBr8DymCpFbdXMTn7Cv18S0hMR7T/o5VkRqN1g1/dvaDdZsRArO3bopkfee4efLF+hyVdcX4u3aNGTkWvLRafW+sXPktA1lla4UkSB7uJIULfxy/RAflk2miyw9xq9uVGgCNzqCv4iX+AUchfMkZdEgRZ9TZ+1CPTH2jXjMXjFl/+bEPzSjM7zPKKWhyZUgQG1lpp+DNz+Zz+85kD59q99U5R4B3vuI9WenCWqroy2U2Ruq6I+di5N/v9SmYnqJ5H1HLWCbIg6iVrn3s2gFBVFhrc1zzNqoFe275K3Jy1T0Mc5yeE1iRwO2b1L/j/S8jyvGDz6B3NMFEHErGHMM2+oJ5LobazyWEitdgMjQnsd0cjYrCqRpx8idpfwRq6hz/LleX6obpuJh/AGIu4sxD35hwkIEr5ShH8xro7tTDYK1GPHGylK6rp7NCG0lMr7YqwziMUBwXv0zPW667f3/IRLJRD7mkuwUP6mpkxyVjNlcBiAX12r//+WTuzWxsue7bsjRp7xFjpR2tRLqGHLvjYt3TpeybR82K61iLn+pOSWDfUv/HU8ecBtML+Gbz0v9vmlxSgZeBBzbGeP1KSqsH14ZM2kibgDhbS21hIALSOYFCE9LY+2CNvtzT2QuSJMiKP3zwvvs+/JkDwTg0jHVE0XH//U0nu5HKQtCL2KGDQYUgT7qIMVN/OoWqEz1oeG4wG7InZg47NE7rfHB2i7rkpYCUzaPfVtDYgTEPNpa8gXHI2Pp8A6YB8OYHkXDZMMcOL3rJD0Hxk+mRlsSJ12/7T52IcFst5zRc7uDJtQTXBdm9GvsvyXcBbMfKXWqsDSeEnFyPUXZGTafti4a0it8SN1qXxzBmzj+gVZ/FojNy+x73AuuqtJ/oaMZF6m5kbW6ItpfnUT/BrQunS+gLjTTUz0d8jTMpAfFQ40RQi9uM5qdFYzqk85hqSH1zsPOhiO5CN+hNZvL/RIs7m7LyLDuV80ZtyHHqVEngTVPBctHQhmcPjM30m1veDmHCXEpjybWAbgj3TqLUPNazzdHgxYmNuT7trWFcGOi7iTeL5YeK2yp2H98yoLN+skqhffZI/5n/ivceo44wJRY8bzC6DGwdgkMOulYhzW5m6OKyK2Mg+E3YE19L8ngE08TdAuNu0mIzd6kw0i03zzm4oqfVSZjZyxXnBhvt0v89EmnArya/UvHQrdQxBDAJagK2y+OqgBqzQ4FnUeiKfb7HFoUvFSknWhwq58TpBlVRZ0B0A7QWz7X4GLHcbdh5kFI/PKJ91OEh/kmnMEdh+Z23myFH8sXjR/KaHttrpz80N+bl0HM17RX48UjUWslrYHYW7oiHVgcGqTBoTrqK4JYwTTArFO1/APJ8DnEYf+wD92Dw15a9wrPxyJA88yYcv9RypzXLKAWmMuE0KAtIGjfKx1GbRQIq0AkttuRpBO7p4SGrTZuAOat3hTxXEcIKh3HgC1d88K7bz1+Jsi+y7tL/7zc0ZxCBB3hSxvP90GkUp1Lm2wuESafZyFy4Opir+o3gMWtDSuLF3LRHXTUGkKQtvARnwam8BuKv8Q2fHH/cEwPCQd3dhzgri8eTezRsQoGz6ha+S4E7ZzDB/LXwl04vA70NeVsf5rmv1TLvcQSNIBk3U6Qh6Bm+0905B91hopTLnTJRWZkUmbckEw0woG81azyw6LZaBL5Qx2HPvd3LHGLpN6mPZlto50NwW2zFOkgoPKV1gr142teD9aok2HNkPMepl3NIi78ShnAlJCzjZplteUoqz0+iUEOym1LZGGFHMBkc6/5f+sRCCFZZW6KrEby64o/ZfefQAPP6b5ko2fuujIv7uonIKXN6XiJsZmcOeGxteQ+b/ope3Z1HFeXYoW1AJrU/OiCpsyQP1Pr1BdQKFzS0oYnLCAweSnIh7qMFMRBMY7BcnJ5oskUbbRNiosqMzCYUAZPbo8tjCCsCBm5SoGcTHBMXcE+yQpl/OfBkcTw3oa4X7V+ohEh/Zkcv0cqc8sY40IsOW6lLiIrvYND/exZbRlOMgaHvb/QQKaY0k6Aamee2o3LVARCbIP4RoSd7u3CXkG+Iz6iFLfsN38F9xU4n3ueeVgiRs3jw70SMWu1QzDdiLsKtU1qvaLhv7dUbnLimdqYG+pa2aRZ8A6Q9JSr3yTs1MiAvfFHPQJTiqpI/hVUMmL6gPj6eL7lH0IkLCNcaogBA0TGfO0wO6ddf8Fju0L3YbRrWe8J3IewsNBCbpC2b6etQRJnSGLuWDiFoBez9hJHw6+bMQQGQS8YV/kzQ5AFHEqPaMgOjyR5zaHtlOBI4mjo8gdNItHUHQ7Bzq/E/xV1B+L0uoRcLIEj4hcv0yWQTwWLHzoFrvEZPygABpc4rnVjhfcBw5wOvaVVtgiG5qjklrTY1ZaXHkasyVYBd+lgo6zEHMumfK8XR2eD0cVn5w8l1uxGz2ACwtFob/CTV/TUx1kCKp+QROanLrNBiSPTxAf1eOFE+JifgAJ+pyrFqS/0wKlPWUVKlB2Bhu1Ggx2cvfdiR49VIsgBNnE75pf5lpFaQuz8+VPreUd/HLlW8kDSr25AnETsVRrOycLBPYD9/j/7Z0KKdOjtrM71AT+VsjD3D97aUDP5WrHp1DWghsk/lS/hp2VMwo0eqoEerLL/4/SlmyjStwWVDqF6jHC89niCwr1tMSe8GxeC9wjzMKmE7ZtdHOWqqc1OoTI24eVQc++crbyxSU4TxiB+vWoaAUpYQxZ06KKIPq6EvN/rN4DZ0/tQWYVqZ3FTIftPBfIuOWX3PonIKTUArpSvfmQRpkWD00wc3AQS98i4ZYaUbI+DGv90tuEKRjb2ocfdddC21YGUATYQmzelz7JqWBAQqKrWYdWEJlfPeRFZHtUm2MaISZsoOvURowxJKveGRegmBiKZ3d1cMFioJL33RoIKT0eDeK8FH/ybAhZU5TQIsWYmjyeT7EOLL5xZuRPf4qRIo6bbLtFOV6SX60fR8Smys/u1D5DjkmHJyr/woVAvBP2dxGo9gH1LgIm8XlFF1KSYvfj+0w7aTEfoFpcO+Jv3Ssbv8wwkED5JEC+jdln2dzToPNRtWiPbRb8f8G4aZX1j/2Vdbu7jM3gAVD5BKR+yJaOwLtwJodwjWu5di47tnNs9ahpnCUzVMObQfbTqMNs64MGANlgyihKjhwZ6p1Jsnro0/SfkOk6wx+HgUB6Mz9cUiF7KrJkhxnOVjCCcqPZglIojIRoDtkd2AkLNZC88GdP2qZV/1N6PBAe+fpgWZ36oHnewQ8CHdXcxbwQVjOn8U3qD9+e7FzWpg135vgdEMZ9fH5agDnNzdjKFZQ4tDsJs/S6Lk8FqjFJpHMjaRU6FI/DBDM0g+RRkxNoUvm14JAn5dgd6aVHt1aMkSXiJVenbm2FfrIEaFKHtm1erv1BJ5056ULL8AMGLmHav4yxg6F6n5oBq7bdP6zEr6f+QTDJ/KE1XfoG24JvVk2GL7Fb+me27otVFnq1e/2wEuqv6X+2zLQuJQszy5YJi/M5888fMy34L6z8ykD5sCHgzliAoAtEeoaFmnPT63kOYrZWspxYzqQBu/QKNyQ8e4QwKJUCVazmIUp6/zpLA3bWH2ch7QZN0rzWGxMRl3K1osWeETxL95TZSG/atM8LB9B92/71+g9UGWDPfD+lu/KdOQ85rocuHe91/gHA/iprG9PZ2juX49kaRxZ+1/sB3Ck35eWYBFsmCl0wC4QZWX5c5QMuSAEz1CJj0JWArSReV4D/vrgLw+EyhBB6aA4+B34PdlDaTLpm9q9Pkl+bzVWrSO+7uVrIECzsvk8RcmfmNSJretRcoI7ZcIfAqwciU9nJ8O4u1EgkcMOzC/MM2l6OYZRrGcqXCitp4LPXruVPzeD402JGV9grZyz9wJolMLC/YCcWs9CjiWv+DNRLaoSgD5M8T4PzmG8cXYM4jPo5SG1wY3QK/4wzVPrc33wI+AcGI//yXgvyBjocGrl768DMaYCGglwIit4r6t6ulwhwHJ4KeV3VHjspXXG4DIlDR2HNFvPaqkBViIvr433qZPuUINp6oi1LyVVC+EE1j6+wab8uPMeAo6e9uWYequvZynhnYazrvrDQJVkK3KZRoSR5BHi6vOC+AVCujMiQ1GVzGDZ4RFv8jFm7z5CU0iPH2JeXqUzqaKKP4P7osPkcIL99Y7fP3l+TzeFXO2kSpLIJW51oEY8DRIhqexGnxj0nmtGOseStuViIE2mJge45LENf77xjuI7egRNpzthNiajnuqikg0aQS1JqlIZf+hwSUlOp8BEQ0y3xiTOJkohBP3eyYiPDlZpFY88EWOpp4+hC/tQdhrQ56h2VJ2XA6vhPAbj+wH6iA2XYuTvRV25N8wNPQuA0Vzzem2ADZPFK2vr8l0I3GTV3fUN4S6FFYygW2Pu98f+lsgPf67rwVCbgMFAACW3P10GbxnK3SNuNK+VlPRiL7U3dK1o3spH/MFfDkgXuXjxDTxJrYctqHdwUg4rhUCNA13lGjuhJDatpFb/mExsBWS46aLFtROqVm8xQNPXK6A2rRfazJSWpIyh+FMmorXPXYnHQ7YLOmD4B5QTI8rzp7OomiarnaFs5syYjQ0ucc7g1/JzT446IFlDtpUL7DP9bLRCLJryUvi5R71/qX7ycqRSwunQ7+tfJz44Na3aJNszaMEZ/BV4iOGopabYdmvAPe+kIdGCNq5Q8fg8Ld0VNNXV0ZiiGej7zSA+pexy6wKC5k4rZa0k+qaN8bKq3oJWMQCSGaK7PrwMvA8t8BZTzjDqXcFTAIeRtl0SdlGSuAziVXItFcgAkeqwuNsbsrUZFcU6KUZLmvG415kHa0AwMFW2cNSUvPR0U9iCPh0nyslT92B5slYXiDWeSXvxHXItvjI8z5KCIVTIHqGZsbDBTr7WdHzcUAI1ipR86H3o0p2wPhfp7xg9oWOxWIK4a5BWdaV9OAPc0XuvlbwitCVtZDzZxGhIOl77ZgrRYR7LZQFE+Ih23hW3gI914ekkjgbKCi2bsqSAvij6GGj5p+k6evQtJp3qVh9vg+jiJvFCGcKBCITMWpqHZNKfE6IT0dKntS0rhu0DB5D9qIS0/RboNLsx2DlRMlx1QIBeBpHJNKdCL9uWM9eS7RJXKNOpraULtutuJYOl0apdE4LxfsyRSZb6fJkd51SHrI7lLB4vEg4fifJ1dqcWSeY4DgcyjrUcymK+gd3o+qj+3gHKWlLVdMUr3IeF8aClYBq+eeCV9Y7n1Ye8yL7rEvxY7jAlLwucKQ51pu59N8we8XwrbXPChBHXP4LnD3kDwQ85w1DKghtwvpO609fZOrPq8Q7GOOAjHhfR5VqvpoFne8oMHbCrWb1L0IdATo+h1PFeLLI8wc+FEyftLvskCdOtxKfAx3IEJXzBfWTKq5viKP/uu99dxnEpoNJhRtjSZGwOTWr7Ys44++P58O+nkYxd1Gcqm8G3Gh7AHSCxiPNyJWijI/lECrKrAXgBqkRShvdkd7IfoqUlziFDiglx+jdHnmRVmGnk3p/3n78M/HkzFUGZOS07cPnPn9jAnBWl4qDrB1ECf9idIKOdkJTKcZ690nuLW2yDsqwNpgrlT+wx2gv+Engha74lfVqbwqS15FRwuFDfq3bVCZcPy78TL2pH/DOdHeL9MFAtyybQNwHaO781rnJZAhR4M+AYWoSoa0EjQ99xivreM+FKwd7Jp/FC2vvvcq1z3RnRau/BM5KGkBPBSUBOzTNdfaJS/PWTDb1jRSgn2MuY3pVZbY9peHBVI3Ce/u70hg4f7MCVeAjYJfzTkDVLuB6jyjZs5Kko3u39ozgLK4LuwSbUrNIU5cl6Bs3De62AE084XRsm64Gs5W1ofxsWIZ9cYl8PNa5zQHl9ls5aiIKN0rHIIzBnLr03Kle2qq+n/gLDAzvF89vdZCvUFEHRoi9n33O3i49UWyeHP+ZAeRf+psM867nfqON092zE4Pj7AbLtvIUFJFr1y9Le0CL2flc7LUqbgGzOw4/q3vA/cJO5JeI8S+8bc1Y7pqYSzoEWSFn5G7EoPHTGHPMU6SeLKEeli+i8dHY3lWxSrIOU2y0TNo1SeRYewhVx05OXeVDf0xhHNckqp0arRk+bgToeSaHbVZ5nj3IH3m2oayt3sXY78qSPcDpc/5C7VXDRj6bROvvBG5JCsKl/yeMPAUn1flMsmr/FaFdb7gVUXnhLa+/Ilj87PpCC6rILQ6wkIP1ywEg0PztSEzbsJoRwQzDaxkiTN27YDnsy/YKfe6jKcqZWs64skzUAHIt+nXxju0dUVtbCSDAUXYw78Yd4bJKuYU8gbzLzgL4XIUC2HcPIVCUYvM7cybOBFVBdeGR4cOVB7QbGnohTRpiPrGqi1a8QXFBYqENawROuR43OG8dl+Jx4TpwAoi2kkPXW7b/ARSs4DO/z4H6oTIUpN3+/K6Iuc49C4/Uf1NxQTEE91VP8RnLKTpxjywMe2VxM1l4YGXSFY80HUAKIdqczBnnLMPklFV8mrr5hFDypn5TAT00ruU6AjDPNvncoVzX4ac6wAzTwrNH7oz1XLH1wzjQs5k7hcNLbznXQGB7M+rXxKtZXPrz1Ar+OxYGDkJvElknZsHD/IcxRd7ujmmLYpDDbverynroCnSKVQWEGjHL57PaI/WokvhYRpPMk4ni2EUhjDuIF+IU2R0fs40i+66bw8sz8OzyC2eFAxxicd2n5Juta2eWa9KtObD7xLmPvtK+8cjQt+NLjcZCTt+Ss9p1od0bklVgaIV1qJbWxUOr6iUzLDzFefYxAtyRcBr53IaDB25n60KQdhroQWMUpuWSUpELSFxiu4vgQeRoEZe78/ua3TlrszB8sLVZoecnV9YMYz+HkZA/pLqbFhzurB52Wl/WEM6sVk4q04OnzWZFi76JkcGgeeUyYUIwhCDMdIfTUdD4wQpYm3LBw0sp33CVK2q305jeyzgGnBzSMXjesm4XjcEhhrjPSLtwqqoaFCqD5DlHYhoTVafWtBUQXoNfDk19IFxq8sImCcqgMhOToIZUO2530aasY908dMX2nTMFjgv+lapdI8k/e0a7pFw6X3Tgf0m99bbCpOzVgRu2Dw/13CehVfFj+8BeKP6SZV4g/qiX42NWP568PzMajFm2ANmKtHjEIAIc2hc1iecBR9elGP4LmAQwAVmZT8kWc7JSY0ag583ch/Z16krGrjn2YdIaa22egy4/niU6m0WAG3K/yP65cfL//CP+JzcnoLHQFb/KJQeBrEbR1/IKo+YOFXWIQ8ghNxYdMwa49NeXzFqFOIXTmk3w/v5KneS8sGHiPGACh0DE9a1uLAochB79g3IqYObhlswemMucZnAE7dBkp5OAfToa5gHFbIPcec0fVWEOOLftQXsuffyv3wo1LWDDm+SyNMWgSEWtjMyYkjLjTkUtmj7DQlfbpHf38lDvoEN9d2ALxnWCjph4jvfEIRbHvltKbvE2BiYlz45mnJPeFrwZcBny3k0/pyXNrSbEIWvvZw14Y0Fqy4tba1Fu0yNNYaf47jfnz7VCCxKsrJz5oz3F8jXUdQqFu+gDq6EzvKDipXf/3NmcsCC74VB3OgHPgN7W9cU54pjGFDMfifl3m5Vhy21uk1U2nYCrddrifkpwGLYmLSSQAAjC6M3yB1fc6KHpgDnMXh2bYX2ns+Qma+DBgyCkZ0TqZK8Mp2Sryx7HdMM74X9hrwYhQbwlK+zgATAXRzQyS+hK4OTnP17/cyJ2WzY6DChYWGJYXGCnEdMswF5VTYQdSyTpdLXYuh+x2Qr7DR3H2x+YdP0qsLAzYJIWKwrrKkpBgWCmgNCn5t+QbWqf/LoLuvjgDFLtMoxNK5axIA9kammelvwh5ZI52ktrEm/OVEESPQPZGHAIhP7oWDBnGnuzG45XOTpZWsxwNO4UiyxH8riTvQq4JVq5GwX3yqVCbSR0ef/gVYDgiYaiD2EAAxuEPKyXTp/HhL96eVTpaDqFEoV2x1PP/UMcs/XqeGc1gZQG1ot6YxaIEWHanYavH9YdLFjlyU5yrYALVg/sxBjT39oD+BIXvf4LTbvvvpX3srxckEX1XAM9s2uajUTlpPq32mcx4T+sibdQEHQV2WmgwMhbYovh7WWTPfLF03ZbV5a+ElsSIyH6kgJ8+D6aN/6f+ZstkZOYZYx9GbagcrEqwNblz0iZ9NTyvIAeNn3Oup7rtyD4wVE0PoqcnR/LoSK1s1esmOGPjs3zHB8xW4iL8IrhqAJfsWNBYW9TGR11C3KZJaN7MP4O5Ykmpvw94hHzVmsYA68RQdFYfPlFOgCNBoSdy5ODcv11l9bLs135M4okEc4/e8hQczcz2PWipIVSBxa/5sr9xyTFbjG4xm8f4LmrAhD1uEDGrFDl/6X7Nw7/WZPW7fZJGYN8eZ68Td5KGfJyKjD+pTysvTi+8Q8R0L9wKAxAUrYswdvAuiNeenxSplQZjYTxbcH/wP97fOY215SozY3UDRhv7lomztURB2O2UriTX3oAiTKoInkHQietZyhBQ9wMTVHgMrxOP5T/0gN14eFTz0m2D6/iJMbXYGHdIkKEGV2Voa8k/hVNvAVAZKrDEXthUxotwYkYysTDk8j27XEVy+4a30jopuAp5+/xWYb0ne6lwKZwR3j6kDXroOOtrHqWlkJHSWLoPEQJQo/ARzR8UBZSckmeBPn3gJwY62Zo2dyy1AyRRDQBFAJKH9KX+7auP8U8XDo7mMSzq5ZxmaJ5bLpNg4ZM7938SAjMHcu1yB4+lkHnVLnIp86AOPgigH+ZFDRq1QuKWK3pK5JkLDJdakj176NCbjXDASt1h/t1p+GHyKbAoevHSnHuPfoBmQ3nJrDjOhPfwVYi8V5r0KB8BsrfFu8BvhYCbNrvCVnd4Q8RktqIR/ZilioC6g3++L7PHzuXa8NFSF5zd+ISzGLTjrfaKXsBFCkkK0ksSDbl91yXUghMFOskQBeUoo7o3wuIsE29goRIORuJ4b1jSumvR0gR8B21iyW1G4FqHkZOlWz9zq5FnaJX1WbeAxe2DfGSAnw4cqDwg3LFalk6eH89Sdc41Fr6voEa0hfwdkb54yOM7WevDugT1FRzEqdg9zZZ44ZAKGH3ZyqFve3SE4UDN6tLmIFTdIwMrtYRXWBQDB7vvqOuYj7cN31av64+jg/g1uce+am3TOl0cUUL6s0l35FJ9p8vJcG+G8lAFqC0pdmd/aaWYpqDLvB5LEasLMgbPN2N+Wvkh6HYxPOrZEfoxQX/67AzcWOR0K3eYGOgQhyWL7cwKGlxmY/E2b8CKi6Ssgok+7B+zTtq/DXmaDAHRnwbwvCDJ9pITO5RQgBuprEWT0avZv7QjbzITYD8Fzgy4TSYG3z9tLso0Z7MfgHDLKU+kHrzxWkBPwJRydKMXG4AaCA7mlAmjzpNhGOrMGZGZlHSjPbmO5jPd/lKBrViZ0BaXMmqaFOwA/f03O04qQX6MSVA37+SA5Pne/KP7caLJKuOCJXoXpzArUrYesMVc/RXnOv03YrwKgPlR2SjpqIycyulmodZBy6gVc1jA9y6lJqWgR6SY6tc24sVcYuh2GaTeikYJnhr2d6BiL3oLx8M8wuJBdI3FRVIIAx4XougScOw2xWgwUoSYKeLUHc310kVBzSE/vFeHAjlUil8KZftctMgwGjwrhMbjDbK4rB32fTe9jnsqijdp5kOwkD9+klel+lNh3joAFQ\");\n        const f = new Map([[8217, \"apostrophe\"], [8260, \"fraction slash\"], [12539, \"middle dot\"]]);\n        function p(e) {\n          return `{${function (e) {\n            return e.toString(16).toUpperCase().padStart(2, \"0\");\n          }(e)}}`;\n        }\n        function m(e) {\n          let t = [];\n          for (let r = 0, n = e.length; r < n;) {\n            let n = e.codePointAt(r);\n            r += n < 65536 ? 1 : 2, t.push(n);\n          }\n          return t;\n        }\n        function g(e) {\n          let t = e.length;\n          if (t < 4096) return String.fromCodePoint(...e);\n          let r = [];\n          for (let n = 0; n < t;) r.push(String.fromCodePoint(...e.slice(n, n += 4096)));\n          return r.join(\"\");\n        }\n        function y(e, t) {\n          let r = e.length,\n            n = r - t.length;\n          for (let o = 0; 0 == n && o < r; o++) n = e[o] - t[o];\n          return n;\n        }\n        var v = r(\"AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g\");\n        function b(e) {\n          return e >> 24 & 255;\n        }\n        function E(e) {\n          return 16777215 & e;\n        }\n        const _ = new Map(s(v).flatMap((e, t) => e.map(e => [e, t + 1 << 24]))),\n          A = new Set(i(v)),\n          T = new Map(),\n          w = new Map();\n        for (let [e, t] of a(v)) {\n          if (!A.has(e) && 2 == t.length) {\n            let [r, n] = t,\n              o = w.get(r);\n            o || (o = new Map(), w.set(r, o)), o.set(n, e);\n          }\n          T.set(e, t.reverse());\n        }\n        const I = 44032,\n          R = 4352,\n          P = 4449,\n          x = 4519;\n        function O(e) {\n          return e >= I && e < 55204;\n        }\n        function S(e, t) {\n          if (e >= R && e < 4371 && t >= P && t < 4470) return I + 588 * (e - R) + 28 * (t - P);\n          if (O(e) && t > x && t < 4547 && (e - I) % 28 == 0) return e + (t - x);\n          {\n            let r = w.get(e);\n            return r && (r = r.get(t), r) ? r : -1;\n          }\n        }\n        function C(e) {\n          let t = [],\n            r = [],\n            n = !1;\n          function o(e) {\n            let r = _.get(e);\n            r && (n = !0, e |= r), t.push(e);\n          }\n          for (let n of e) for (;;) {\n            if (n < 128) t.push(n);else if (O(n)) {\n              let e = n - I,\n                t = e % 588 / 28 | 0,\n                r = e % 28;\n              o(R + (e / 588 | 0)), o(P + t), r > 0 && o(x + r);\n            } else {\n              let e = T.get(n);\n              e ? r.push(...e) : o(n);\n            }\n            if (!r.length) break;\n            n = r.pop();\n          }\n          if (n && t.length > 1) {\n            let e = b(t[0]);\n            for (let r = 1; r < t.length; r++) {\n              let n = b(t[r]);\n              if (0 == n || e <= n) {\n                e = n;\n                continue;\n              }\n              let o = r - 1;\n              for (;;) {\n                let r = t[o + 1];\n                if (t[o + 1] = t[o], t[o] = r, !o) break;\n                if (e = b(t[--o]), e <= n) break;\n              }\n              e = b(t[r]);\n            }\n          }\n          return t;\n        }\n        function B(e) {\n          return C(e).map(E);\n        }\n        function k(e) {\n          return function (e) {\n            let t = [],\n              r = [],\n              n = -1,\n              o = 0;\n            for (let i of e) {\n              let e = b(i),\n                s = E(i);\n              if (-1 == n) 0 == e ? n = s : t.push(s);else if (o > 0 && o >= e) 0 == e ? (t.push(n, ...r), r.length = 0, n = s) : r.push(s), o = e;else {\n                let i = S(n, s);\n                i >= 0 ? n = i : 0 == o && 0 == e ? (t.push(n), n = s) : (r.push(s), o = e);\n              }\n            }\n            return n >= 0 && t.push(n, ...r), t;\n          }(C(e));\n        }\n        const N = 65039,\n          M = \".\";\n        function L() {\n          return new Set(i(h));\n        }\n        const D = new Map(a(h)),\n          F = L(),\n          H = L(),\n          j = L(),\n          U = L(),\n          G = s(h);\n        function V() {\n          return new Set([i(h).map(e => G[e]), i(h)].flat(2));\n        }\n        const W = h(),\n          Z = c(e => {\n            let t = c(h).map(e => e + 96);\n            if (t.length) {\n              let r = e >= W;\n              t[0] -= 32, t = g(t), r && (t = `Restricted[${t}]`);\n              let n = V(),\n                o = V(),\n                i = [...n, ...o].sort((e, t) => e - t);\n              return {\n                N: t,\n                P: n,\n                M: h() - 1,\n                R: r,\n                V: new Set(i)\n              };\n            }\n          }),\n          q = L(),\n          z = new Map();\n        [...q, ...L()].sort((e, t) => e - t).map((e, t, r) => {\n          let n = h(),\n            o = r[t] = n ? r[t - n] : {\n              V: [],\n              M: new Map()\n            };\n          o.V.push(e), q.has(e) || z.set(e, o);\n        });\n        for (let {\n          V: e,\n          M: t\n        } of new Set(z.values())) {\n          let r = [];\n          for (let t of e) {\n            let e = Z.filter(e => e.V.has(t)),\n              n = r.find(({\n                G: t\n              }) => e.some(e => t.has(e)));\n            n || (n = {\n              G: new Set(),\n              V: []\n            }, r.push(n)), n.V.push(t), e.forEach(e => n.G.add(e));\n          }\n          let n = r.flatMap(({\n            G: e\n          }) => [...e]);\n          for (let {\n            G: e,\n            V: o\n          } of r) {\n            let r = new Set(n.filter(t => !e.has(t)));\n            for (let e of o) t.set(e, r);\n          }\n        }\n        let K = new Set(),\n          Q = new Set();\n        for (let e of Z) for (let t of e.V) (K.has(t) ? Q : K).add(t);\n        for (let e of K) z.has(e) || Q.has(e) || z.set(e, 1);\n        const X = new Set([...K, ...B(K)]),\n          J = i(h),\n          Y = function e(t) {\n            let r = c(() => {\n                let t = i(h).map(e => J[e]);\n                if (t.length) return e(t);\n              }).sort((e, t) => t.Q.size - e.Q.size),\n              n = h(),\n              o = n % 3;\n            n = n / 3 | 0;\n            let s = 1 & n;\n            return n >>= 1, {\n              B: r,\n              V: o,\n              F: s,\n              S: 1 & n,\n              C: 2 & n,\n              Q: new Set(t)\n            };\n          }([]);\n        class $ extends Array {\n          get is_emoji() {\n            return !0;\n          }\n        }\n        function ee(e, t = p) {\n          let r = [];\n          ne(e[0]) && r.push(\"\");\n          let n = 0,\n            o = e.length;\n          for (let i = 0; i < o; i++) {\n            let o = e[i];\n            oe(o) && (r.push(g(e.slice(n, i))), r.push(t(o)), n = i + 1);\n          }\n          return r.push(g(e.slice(n, o))), r.join(\"\");\n        }\n        function te(e) {\n          return (oe(e) ? \"\" : `\"${ee([e])}\" `) + p(e);\n        }\n        function re(e) {\n          for (let t = e.lastIndexOf(95); t > 0;) if (95 !== e[--t]) throw new Error(\"underscore allowed only at start\");\n        }\n        function ne(e) {\n          return H.has(e);\n        }\n        function oe(e) {\n          return j.has(e);\n        }\n        function ie(e, t) {\n          let r = 0;\n          return e.split(M).map(e => {\n            let n,\n              o = m(e),\n              i = {\n                input: o,\n                offset: r\n              };\n            r += o.length + 1;\n            try {\n              let e,\n                r = i.tokens = de(o, k),\n                s = r.length;\n              if (!s) throw new Error(\"empty label\");\n              {\n                let o = r[0],\n                  a = s > 1 || o.is_emoji;\n                if (!a && o.every(e => e < 128)) n = o, re(n), function (e) {\n                  if (e.length >= 4 && 45 == e[2] && 45 == e[3]) throw new Error(\"invalid label extension\");\n                }(n), e = \"ASCII\";else if (a && (i.emoji = !0, o = r.flatMap(e => e.is_emoji ? [] : e)), n = r.flatMap(e => !t && e.is_emoji ? le(e) : e), re(n), o.length) {\n                  if (H.has(n[0])) throw ue(\"leading combining mark\");\n                  for (let e = 1; e < s; e++) {\n                    let t = r[e];\n                    if (!t.is_emoji && H.has(t[0])) throw ue(`emoji + combining mark: \"${g(r[e - 1])} + ${ee([t[0]])}\"`);\n                  }\n                  !function (e) {\n                    let t = e[0],\n                      r = f.get(t);\n                    if (r) throw ue(`leading ${r}`);\n                    let n = e.length,\n                      o = -1;\n                    for (let i = 1; i < n; i++) {\n                      t = e[i];\n                      let n = f.get(t);\n                      if (n) {\n                        if (o == i) throw ue(`${r} + ${n}`);\n                        o = i + 1, r = n;\n                      }\n                    }\n                    if (o == n) throw ue(`trailing ${r}`);\n                  }(n);\n                  let t = [...new Set(o)],\n                    [i] = function (e) {\n                      let t = Z;\n                      for (let r of e) {\n                        let e = t.filter(e => e.V.has(r));\n                        if (!e.length) throw t === Z ? ae(r) : ce(t[0], r);\n                        if (t = e, 1 == e.length) break;\n                      }\n                      return t;\n                    }(t);\n                  !function (e, t) {\n                    let {\n                      V: r,\n                      M: n\n                    } = e;\n                    for (let n of t) if (!r.has(n)) throw ce(e, n);\n                    if (n >= 0) for (let r = 1, o = B(t).length; r < o; r++) if (H.has(t[r])) {\n                      let i = r + 1;\n                      for (; i < o && H.has(t[i]);) i++;\n                      if (i - r > n) throw new Error(`too many combining marks: ${e.N} \"${g(t.slice(r - 1, i))}\" (${i - r}/${n})`);\n                      r = i;\n                    }\n                  }(i, o), function (e, t) {\n                    let r,\n                      n = [];\n                    for (let e of t) {\n                      let t = z.get(e);\n                      if (1 === t) return;\n                      if (t) {\n                        let n = t.M.get(e);\n                        if (r = r ? r.filter(e => n.has(e)) : [...n], !r.length) return;\n                      } else n.push(e);\n                    }\n                    if (r) for (let t of r) if (n.every(e => t.V.has(e))) throw new Error(`whole-script confusable: ${e.N}/${t.N}`);\n                  }(i, t), e = i.N;\n                } else e = \"Emoji\";\n              }\n              i.type = e;\n            } catch (e) {\n              i.error = e;\n            }\n            return i.output = n, i;\n          });\n        }\n        function se(e) {\n          return e.map(({\n            input: t,\n            error: r,\n            output: n\n          }) => {\n            if (r) {\n              let n = r.message;\n              throw new Error(1 == e.length ? n : `Invalid label \"${ee(t)}\": ${n}`);\n            }\n            return g(n);\n          }).join(M);\n        }\n        function ae(e) {\n          return new Error(`disallowed character: ${te(e)}`);\n        }\n        function ce(e, t) {\n          let r = te(t),\n            n = Z.find(e => e.P.has(t));\n          return n && (r = `${n.N} ${r}`), new Error(`illegal mixture: ${e.N} + ${r}`);\n        }\n        function ue(e) {\n          return new Error(`illegal placement: ${e}`);\n        }\n        function de(e, t) {\n          let r = [],\n            n = [];\n          for (e = e.slice().reverse(); e.length;) {\n            let o = he(e);\n            if (o) n.length && (r.push(t(n)), n = []), r.push(o);else {\n              let t = e.pop();\n              if (X.has(t)) n.push(t);else {\n                let e = D.get(t);\n                if (e) n.push(...e);else if (!F.has(t)) throw ae(t);\n              }\n            }\n          }\n          return n.length && r.push(t(n)), r;\n        }\n        function le(e) {\n          return e.filter(e => e != N);\n        }\n        function he(e, t) {\n          let r,\n            n,\n            o = Y,\n            i = [],\n            s = e.length;\n          for (t && (t.length = 0); s;) {\n            let a = e[--s];\n            if (o = o.B.find(e => e.Q.has(a)), !o) break;\n            if (o.S) n = a;else if (o.C && a === n) break;\n            i.push(a), o.F && (i.push(N), s > 0 && e[s - 1] == N && s--), o.V && (r = fe(i, o), t && t.push(...e.slice(s).reverse()), e.length = s);\n          }\n          return r;\n        }\n        function fe(e, t) {\n          let r = $.from(e);\n          return 2 == t.V && r.splice(1, 1), r;\n        }\n        const pe = \"valid\",\n          me = \"mapped\",\n          ge = \"ignored\";\n        function ye(e) {\n          return e == pe || e == me;\n        }\n        function ve(e) {\n          return e.some(e => U.has(e));\n        }\n        function be(e) {\n          for (let t = 0; t < e.length; t++) if (e[t].type == pe) {\n            let r = t + 1;\n            for (; r < e.length && e[r].type == pe;) r++;\n            e.splice(t, r - t, {\n              type: pe,\n              cps: e.slice(t, r).flatMap(e => e.cps)\n            });\n          }\n          return e;\n        }\n        t.ens_beautify = function (e) {\n          let t = ie(e, !0);\n          for (let {\n            type: e,\n            output: r,\n            error: n\n          } of t) if (!n && \"Greek\" !== e) {\n            let e = 0;\n            for (;;) {\n              let t = r.indexOf(958, e);\n              if (t < 0) break;\n              r[t] = 926, e = t + 1;\n            }\n          }\n          return se(t);\n        }, t.ens_emoji = function () {\n          let e = [];\n          return function t(r, n, o) {\n            if (r.S) o = n[n.length - 1];else if (r.C && o === n[n.length - 1]) return;\n            r.F && n.push(N), r.V && e.push(fe(n, r));\n            for (let e of r.B) for (let r of e.Q) t(e, [...n, r], o);\n          }(Y, []), e.sort(y);\n        }, t.ens_normalize = function (e) {\n          return se(ie(e));\n        }, t.ens_normalize_fragment = function (e, t) {\n          let r = t ? B : k;\n          return e.split(M).map(e => g(de(m(e), r).flatMap(e => e.is_emoji ? le(e) : e))).join(M);\n        }, t.ens_split = ie, t.ens_tokenize = function e(t, {\n          nf: r = !0\n        } = {}) {\n          let n = m(t).reverse(),\n            o = [],\n            i = [];\n          for (; n.length;) {\n            let e = he(n, o);\n            if (e) i.push({\n              type: \"emoji\",\n              emoji: e,\n              input: o.slice(),\n              cps: le(e)\n            });else {\n              let e = n.pop();\n              if (46 == e) i.push({\n                type: \"stop\",\n                cp: e\n              });else if (X.has(e)) i.push({\n                type: pe,\n                cps: [e]\n              });else if (F.has(e)) i.push({\n                type: ge,\n                cp: e\n              });else {\n                let t = D.get(e);\n                t ? i.push({\n                  type: me,\n                  cp: e,\n                  cps: t.slice()\n                }) : i.push({\n                  type: \"disallowed\",\n                  cp: e\n                });\n              }\n            }\n          }\n          if (r) for (let t = 0, r = -1; t < i.length; t++) {\n            let n = i[t];\n            if (ye(n.type)) {\n              if (ve(n.cps)) {\n                let n = t + 1;\n                for (let e = n; e < i.length; e++) {\n                  let {\n                    type: t,\n                    cps: r\n                  } = i[e];\n                  if (ye(t)) {\n                    if (!ve(r)) break;\n                    n = e + 1;\n                  } else if (t !== ge) break;\n                }\n                r < 0 && (r = t);\n                let o = i.slice(r, n),\n                  s = o.flatMap(e => ye(e.type) ? e.cps : []),\n                  a = k(s);\n                y(a, s) ? (i.splice(r, n - r, {\n                  type: \"nfc\",\n                  input: s,\n                  cps: a,\n                  tokens0: be(o),\n                  tokens: e(g(a), {\n                    nf: !1\n                  })\n                }), t = r) : t = n - 1, r = -1;\n              } else r = t;\n            } else n.type !== ge && (r = -1);\n          }\n          return be(i);\n        }, t.is_combining_mark = ne, t.nfc = k, t.nfd = B, t.safe_str_from_cps = ee, t.should_escape = oe;\n      },\n      1732: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.outputSyncingFormatter = t.outputPostFormatter = t.inputPostFormatter = t.outputBlockFormatter = t.outputTransactionReceiptFormatter = t.outputLogFormatter = t.inputLogFormatter = t.inputTopicFormatter = t.outputTransactionFormatter = t.inputSignFormatter = t.inputTransactionFormatter = t.inputCallFormatter = t.txInputOptionsFormatter = t.inputAddressFormatter = t.inputDefaultBlockNumberFormatter = t.inputBlockNumberFormatter = t.outputBigIntegerFormatter = t.outputProofFormatter = t.inputStorageKeysFormatter = void 0;\n        const n = r(5071),\n          o = r(9910),\n          i = r(9970),\n          s = r(9634),\n          a = r(7345);\n        t.inputStorageKeysFormatter = e => e.map(e => (0, s.numberToHex)(e)), t.outputProofFormatter = e => ({\n          address: (0, s.toChecksumAddress)(e.address),\n          nonce: (0, s.hexToNumberString)(e.nonce),\n          balance: (0, s.hexToNumberString)(e.balance)\n        }), t.outputBigIntegerFormatter = e => (0, s.toNumber)(e), t.inputBlockNumberFormatter = e => {\n          if (!(0, a.isNullish)(e)) return \"string\" == typeof e && (0, a.isBlockTag)(e) ? e : \"genesis\" === e ? \"0x0\" : \"string\" == typeof e && (0, s.isHexStrict)(e) ? e.toLowerCase() : (0, s.numberToHex)(e);\n        }, t.inputDefaultBlockNumberFormatter = (e, r) => e ? (0, t.inputBlockNumberFormatter)(e) : (0, t.inputBlockNumberFormatter)(r), t.inputAddressFormatter = e => {\n          if (o.Iban.isValid(e) && o.Iban.isDirect(e)) return new o.Iban(e).toAddress().toLowerCase();\n          if ((0, s.isAddress)(e)) return `0x${e.toLowerCase().replace(\"0x\", \"\")}`;\n          throw new n.FormatterError(`Provided address ${e} is invalid, the capitalization checksum test failed, or it's an indirect IBAN address which can't be converted.`);\n        }, t.txInputOptionsFormatter = e => {\n          var r;\n          const o = Object.assign({}, e);\n          if (e.to && (o.to = (0, t.inputAddressFormatter)(e.to)), e.data && e.input) throw new n.FormatterError('You can\\'t have \"data\" and \"input\" as properties of transactions at the same time, please use either \"data\" or \"input\" instead.');\n          if (!e.input && e.data && (o.input = e.data, delete o.data), e.input && !e.input.startsWith(\"0x\") && (o.input = `0x${e.input}`), o.input && !(0, s.isHexStrict)(o.input)) throw new n.FormatterError(\"The input field must be HEX encoded data.\");\n          return (e.gas || e.gasLimit) && (o.gas = (0, s.toNumber)(null !== (r = e.gas) && void 0 !== r ? r : e.gasLimit)), (e.maxPriorityFeePerGas || e.maxFeePerGas) && delete o.gasPrice, [\"gasPrice\", \"gas\", \"value\", \"maxPriorityFeePerGas\", \"maxFeePerGas\", \"nonce\", \"chainId\"].filter(e => !(0, a.isNullish)(o[e])).forEach(e => {\n            o[e] = (0, s.numberToHex)(o[e]);\n          }), o;\n        }, t.inputCallFormatter = (e, r) => {\n          var n;\n          const o = (0, t.txInputOptionsFormatter)(e),\n            i = null !== (n = o.from) && void 0 !== n ? n : r;\n          return i && (o.from = (0, t.inputAddressFormatter)(i)), o;\n        }, t.inputTransactionFormatter = (e, r) => {\n          var o;\n          const i = (0, t.txInputOptionsFormatter)(e);\n          if (\"number\" != typeof i.from && (!i.from || \"object\" != typeof i.from)) {\n            if (i.from = null !== (o = i.from) && void 0 !== o ? o : r, !e.from && \"number\" != typeof e.from) throw new n.FormatterError('The send transactions \"from\" field must be defined!');\n            i.from = (0, t.inputAddressFormatter)(e.from);\n          }\n          return i;\n        }, t.inputSignFormatter = e => (0, s.isHexStrict)(e) ? e : (0, s.utf8ToHex)(e), t.outputTransactionFormatter = e => {\n          const r = Object.assign({}, e);\n          return e.blockNumber && (r.blockNumber = (0, s.hexToNumber)(e.blockNumber)), e.transactionIndex && (r.transactionIndex = (0, s.hexToNumber)(e.transactionIndex)), r.nonce = (0, s.hexToNumber)(e.nonce), r.gas = (0, s.hexToNumber)(e.gas), e.gasPrice && (r.gasPrice = (0, t.outputBigIntegerFormatter)(e.gasPrice)), e.maxFeePerGas && (r.maxFeePerGas = (0, t.outputBigIntegerFormatter)(e.maxFeePerGas)), e.maxPriorityFeePerGas && (r.maxPriorityFeePerGas = (0, t.outputBigIntegerFormatter)(e.maxPriorityFeePerGas)), e.type && (r.type = (0, s.hexToNumber)(e.type)), r.value = (0, t.outputBigIntegerFormatter)(e.value), e.to && (0, s.isAddress)(e.to) ? r.to = (0, s.toChecksumAddress)(e.to) : r.to = void 0, e.from && (r.from = (0, s.toChecksumAddress)(e.from)), r;\n        }, t.inputTopicFormatter = e => {\n          if ((0, a.isNullish)(e)) return null;\n          const t = String(e);\n          return (0, a.isHex)(t) ? t : (0, s.fromUtf8)(t);\n        }, t.inputLogFormatter = e => {\n          var r;\n          const n = (0, a.isNullish)(e) ? {} : (0, s.mergeDeep)({}, e);\n          return (0, a.isNullish)(n.fromBlock) && (n.fromBlock = i.BlockTags.LATEST), n.fromBlock = (0, t.inputBlockNumberFormatter)(n.fromBlock), (0, a.isNullish)(n.toBlock) || (n.toBlock = (0, t.inputBlockNumberFormatter)(n.toBlock)), n.topics = null !== (r = n.topics) && void 0 !== r ? r : [], n.topics = n.topics.map(e => Array.isArray(e) ? e.map(t.inputTopicFormatter) : (0, t.inputTopicFormatter)(e)), n.address && (n.address = Array.isArray(n.address) ? n.address.map(e => (0, t.inputAddressFormatter)(e)) : (0, t.inputAddressFormatter)(n.address)), n;\n        }, t.outputLogFormatter = e => {\n          const t = Object.assign({}, e),\n            r = \"string\" == typeof e.logIndex ? e.logIndex : (0, s.numberToHex)(e.logIndex);\n          if (\"string\" == typeof e.blockHash && \"string\" == typeof e.transactionHash) {\n            const n = (0, s.sha3Raw)(`${e.blockHash.replace(\"0x\", \"\")}${e.transactionHash.replace(\"0x\", \"\")}${r.replace(\"0x\", \"\")}`);\n            t.id = `log_${n.replace(\"0x\", \"\").slice(0, 8)}`;\n          } else e.id || (t.id = void 0);\n          return e.blockNumber && (0, s.isHexStrict)(e.blockNumber) && (t.blockNumber = (0, s.hexToNumber)(e.blockNumber)), e.transactionIndex && (0, s.isHexStrict)(e.transactionIndex) && (t.transactionIndex = (0, s.hexToNumber)(e.transactionIndex)), e.logIndex && (0, s.isHexStrict)(e.logIndex) && (t.logIndex = (0, s.hexToNumber)(e.logIndex)), e.address && (t.address = (0, s.toChecksumAddress)(e.address)), t;\n        }, t.outputTransactionReceiptFormatter = e => {\n          if (\"object\" != typeof e) throw new n.FormatterError(`Received receipt is invalid: ${String(e)}`);\n          const r = Object.assign({}, e);\n          return e.blockNumber && (r.blockNumber = (0, s.hexToNumber)(e.blockNumber)), e.transactionIndex && (r.transactionIndex = (0, s.hexToNumber)(e.transactionIndex)), r.cumulativeGasUsed = (0, s.hexToNumber)(e.cumulativeGasUsed), r.gasUsed = (0, s.hexToNumber)(e.gasUsed), e.logs && Array.isArray(e.logs) && (r.logs = e.logs.map(t.outputLogFormatter)), e.effectiveGasPrice && (r.effectiveGasPrice = (0, s.hexToNumber)(e.effectiveGasPrice)), e.contractAddress && (r.contractAddress = (0, s.toChecksumAddress)(e.contractAddress)), e.status && (r.status = Boolean(parseInt(e.status, 10))), r;\n        }, t.outputBlockFormatter = e => {\n          const r = Object.assign({}, e);\n          return r.gasLimit = (0, s.hexToNumber)(e.gasLimit), r.gasUsed = (0, s.hexToNumber)(e.gasUsed), r.size = (0, s.hexToNumber)(e.size), r.timestamp = (0, s.hexToNumber)(e.timestamp), e.number && (r.number = (0, s.hexToNumber)(e.number)), e.difficulty && (r.difficulty = (0, t.outputBigIntegerFormatter)(e.difficulty)), e.totalDifficulty && (r.totalDifficulty = (0, t.outputBigIntegerFormatter)(e.totalDifficulty)), e.transactions && Array.isArray(e.transactions) && (r.transactions = e.transactions.map(t.outputTransactionFormatter)), e.miner && (r.miner = (0, s.toChecksumAddress)(e.miner)), e.baseFeePerGas && (r.baseFeePerGas = (0, t.outputBigIntegerFormatter)(e.baseFeePerGas)), r;\n        }, t.inputPostFormatter = e => {\n          var t;\n          const r = Object.assign({}, e);\n          return e.ttl && (r.ttl = (0, s.numberToHex)(e.ttl)), e.workToProve && (r.workToProve = (0, s.numberToHex)(e.workToProve)), e.priority && (r.priority = (0, s.numberToHex)(e.priority)), e.topics && !Array.isArray(e.topics) && (r.topics = e.topics ? [e.topics] : []), r.topics = null === (t = r.topics) || void 0 === t ? void 0 : t.map(e => e.startsWith(\"0x\") ? e : (0, s.fromUtf8)(e)), r;\n        }, t.outputPostFormatter = e => {\n          var t;\n          const r = Object.assign({}, e);\n          return e.expiry && (r.expiry = (0, s.hexToNumber)(e.expiry)), e.sent && (r.sent = (0, s.hexToNumber)(e.sent)), e.ttl && (r.ttl = (0, s.hexToNumber)(e.ttl)), e.workProved && (r.workProved = (0, s.hexToNumber)(e.workProved)), e.topics || (r.topics = []), r.topics = null === (t = r.topics) || void 0 === t ? void 0 : t.map(s.toUtf8), r;\n        }, t.outputSyncingFormatter = e => {\n          const t = Object.assign({}, e);\n          return t.startingBlock = (0, s.hexToNumber)(e.startingBlock), t.currentBlock = (0, s.hexToNumber)(e.currentBlock), t.highestBlock = (0, s.hexToNumber)(e.highestBlock), e.knownStates && (t.knownStates = (0, s.hexToNumber)(e.knownStates)), e.pulledStates && (t.pulledStates = (0, s.hexToNumber)(e.pulledStates)), t;\n        };\n      },\n      6527: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          i = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          },\n          s = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return o(t, e), t;\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.formatters = void 0, i(r(6171), t), i(r(8441), t), i(r(860), t), i(r(1819), t), i(r(8174), t), i(r(8202), t), i(r(7003), t), i(r(8165), t), i(r(1732), t), i(r(4738), t), i(r(8976), t), t.formatters = s(r(1732));\n      },\n      8165: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      7003: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isSupportSubscriptions = t.isSupportedProvider = t.isLegacySendAsyncProvider = t.isLegacySendProvider = t.isEIP1193Provider = t.isLegacyRequestProvider = t.isMetaMaskProvider = t.isWeb3Provider = void 0;\n        const n = r(9970);\n        t.isWeb3Provider = e => n.Web3BaseProvider.isWeb3Provider(e), t.isMetaMaskProvider = e => \"string\" != typeof e && \"request\" in e && \"AsyncFunction\" === e.request.constructor.name && \"isMetaMask\" in e && e.isMetaMask, t.isLegacyRequestProvider = e => \"string\" != typeof e && \"request\" in e && \"Function\" === e.request.constructor.name, t.isEIP1193Provider = e => \"string\" != typeof e && \"request\" in e && \"AsyncFunction\" === e.request.constructor.name, t.isLegacySendProvider = e => \"string\" != typeof e && \"send\" in e, t.isLegacySendAsyncProvider = e => \"string\" != typeof e && \"sendAsync\" in e, t.isSupportedProvider = e => e && ((0, t.isWeb3Provider)(e) || (0, t.isEIP1193Provider)(e) || (0, t.isLegacyRequestProvider)(e) || (0, t.isLegacySendAsyncProvider)(e) || (0, t.isLegacySendProvider)(e)), t.isSupportSubscriptions = e => e && \"supportsSubscriptions\" in e ? e.supportsSubscriptions() : !(!e || \"string\" == typeof e || !(\"on\" in e));\n      },\n      8202: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3BatchRequest = t.DEFAULT_BATCH_REQUEST_TIMEOUT = void 0;\n        const o = r(9634),\n          i = r(5071);\n        t.DEFAULT_BATCH_REQUEST_TIMEOUT = 1e3, t.Web3BatchRequest = class {\n          constructor(e) {\n            this._requestManager = e, this._requests = new Map();\n          }\n          get requests() {\n            return [...this._requests.values()].map(e => e.payload);\n          }\n          add(e) {\n            const t = o.jsonRpc.toPayload(e),\n              r = new o.Web3DeferredPromise();\n            return this._requests.set(t.id, {\n              payload: t,\n              promise: r\n            }), r;\n          }\n          execute(e) {\n            var r;\n            return n(this, void 0, void 0, function* () {\n              if (0 === this.requests.length) return Promise.resolve([]);\n              const n = new o.Web3DeferredPromise({\n                timeout: null !== (r = null == e ? void 0 : e.timeout) && void 0 !== r ? r : t.DEFAULT_BATCH_REQUEST_TIMEOUT,\n                eagerStart: !0,\n                timeoutMessage: \"Batch request timeout\"\n              });\n              return this._processBatchRequest(n).catch(e => n.reject(e)), n.catch(e => {\n                e instanceof i.OperationTimeoutError && this._abortAllRequests(\"Batch request timeout\"), n.reject(e);\n              }), n;\n            });\n          }\n          _processBatchRequest(e) {\n            var t, r;\n            return n(this, void 0, void 0, function* () {\n              const n = yield this._requestManager.sendBatch([...this._requests.values()].map(e => e.payload));\n              if (n.length !== this._requests.size) throw this._abortAllRequests(\"Invalid batch response\"), new i.ResponseError(n, `Batch request size mismatch the results size. Requests: ${this._requests.size}, Responses: ${n.length}`);\n              const s = this.requests.map(e => e.id).map(Number).sort((e, t) => e - t),\n                a = n.map(e => e.id).map(Number).sort((e, t) => e - t);\n              if (JSON.stringify(s) !== JSON.stringify(a)) throw this._abortAllRequests(\"Invalid batch response\"), new i.ResponseError(n, `Batch request mismatch the results. Requests: [${s.join()}], Responses: [${a.join()}]`);\n              for (const e of n) o.jsonRpc.isResponseWithResult(e) ? null === (t = this._requests.get(e.id)) || void 0 === t || t.promise.resolve(e.result) : o.jsonRpc.isResponseWithError(e) && (null === (r = this._requests.get(e.id)) || void 0 === r || r.promise.reject(e.error));\n              e.resolve(n);\n            });\n          }\n          _abortAllRequests(e) {\n            for (const {\n              promise: t\n            } of this._requests.values()) t.reject(new i.OperationAbortError(e));\n          }\n        };\n      },\n      6171: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3Config = t.Web3ConfigEvent = void 0;\n        const n = r(9970),\n          o = r(5071),\n          i = r(9634),\n          s = r(8976);\n        var a;\n        !function (e) {\n          e.CONFIG_CHANGE = \"CONFIG_CHANGE\";\n        }(a = t.Web3ConfigEvent || (t.Web3ConfigEvent = {}));\n        class c extends s.Web3EventEmitter {\n          constructor(e) {\n            super(), this.config = {\n              handleRevert: !1,\n              defaultAccount: void 0,\n              defaultBlock: \"latest\",\n              transactionBlockTimeout: 50,\n              transactionConfirmationBlocks: 24,\n              transactionPollingInterval: 1e3,\n              transactionPollingTimeout: 75e4,\n              transactionReceiptPollingInterval: void 0,\n              transactionSendTimeout: 75e4,\n              transactionConfirmationPollingInterval: void 0,\n              blockHeaderTimeout: 10,\n              maxListenersWarningThreshold: 100,\n              contractDataInputFill: \"data\",\n              defaultNetworkId: void 0,\n              defaultChain: \"mainnet\",\n              defaultHardfork: \"london\",\n              defaultCommon: void 0,\n              defaultTransactionType: \"0x2\",\n              defaultMaxPriorityFeePerGas: (0, i.toHex)(25e8),\n              enableExperimentalFeatures: {\n                useSubscriptionWhenCheckingBlockTimeout: !1,\n                useRpcCallSpecification: !1\n              },\n              transactionBuilder: void 0,\n              transactionTypeParser: void 0,\n              defaultReturnFormat: n.DEFAULT_RETURN_FORMAT\n            }, this.setConfig(null != e ? e : {});\n          }\n          setConfig(e) {\n            const t = Object.keys(e);\n            for (const r of t) this._triggerConfigChange(r, e[r]);\n            Object.assign(this.config, e);\n          }\n          get handleRevert() {\n            return this.config.handleRevert;\n          }\n          set handleRevert(e) {\n            this._triggerConfigChange(\"handleRevert\", e), this.config.handleRevert = e;\n          }\n          get contractDataInputFill() {\n            return this.config.contractDataInputFill;\n          }\n          set contractDataInputFill(e) {\n            this._triggerConfigChange(\"contractDataInputFill\", e), this.config.contractDataInputFill = e;\n          }\n          get defaultAccount() {\n            return this.config.defaultAccount;\n          }\n          set defaultAccount(e) {\n            this._triggerConfigChange(\"defaultAccount\", e), this.config.defaultAccount = e;\n          }\n          get defaultBlock() {\n            return this.config.defaultBlock;\n          }\n          set defaultBlock(e) {\n            this._triggerConfigChange(\"defaultBlock\", e), this.config.defaultBlock = e;\n          }\n          get transactionSendTimeout() {\n            return this.config.transactionSendTimeout;\n          }\n          set transactionSendTimeout(e) {\n            this._triggerConfigChange(\"transactionSendTimeout\", e), this.config.transactionSendTimeout = e;\n          }\n          get transactionBlockTimeout() {\n            return this.config.transactionBlockTimeout;\n          }\n          set transactionBlockTimeout(e) {\n            this._triggerConfigChange(\"transactionBlockTimeout\", e), this.config.transactionBlockTimeout = e;\n          }\n          get transactionConfirmationBlocks() {\n            return this.config.transactionConfirmationBlocks;\n          }\n          set transactionConfirmationBlocks(e) {\n            this._triggerConfigChange(\"transactionConfirmationBlocks\", e), this.config.transactionConfirmationBlocks = e;\n          }\n          get transactionPollingInterval() {\n            return this.config.transactionPollingInterval;\n          }\n          set transactionPollingInterval(e) {\n            this._triggerConfigChange(\"transactionPollingInterval\", e), this.config.transactionPollingInterval = e, this.transactionReceiptPollingInterval = e, this.transactionConfirmationPollingInterval = e;\n          }\n          get transactionPollingTimeout() {\n            return this.config.transactionPollingTimeout;\n          }\n          set transactionPollingTimeout(e) {\n            this._triggerConfigChange(\"transactionPollingTimeout\", e), this.config.transactionPollingTimeout = e;\n          }\n          get transactionReceiptPollingInterval() {\n            return this.config.transactionReceiptPollingInterval;\n          }\n          set transactionReceiptPollingInterval(e) {\n            this._triggerConfigChange(\"transactionReceiptPollingInterval\", e), this.config.transactionReceiptPollingInterval = e;\n          }\n          get transactionConfirmationPollingInterval() {\n            return this.config.transactionConfirmationPollingInterval;\n          }\n          set transactionConfirmationPollingInterval(e) {\n            this._triggerConfigChange(\"transactionConfirmationPollingInterval\", e), this.config.transactionConfirmationPollingInterval = e;\n          }\n          get blockHeaderTimeout() {\n            return this.config.blockHeaderTimeout;\n          }\n          set blockHeaderTimeout(e) {\n            this._triggerConfigChange(\"blockHeaderTimeout\", e), this.config.blockHeaderTimeout = e;\n          }\n          get enableExperimentalFeatures() {\n            return this.config.enableExperimentalFeatures;\n          }\n          set enableExperimentalFeatures(e) {\n            this._triggerConfigChange(\"enableExperimentalFeatures\", e), this.config.enableExperimentalFeatures = e;\n          }\n          get maxListenersWarningThreshold() {\n            return this.config.maxListenersWarningThreshold;\n          }\n          set maxListenersWarningThreshold(e) {\n            this._triggerConfigChange(\"maxListenersWarningThreshold\", e), this.setMaxListenerWarningThreshold(e), this.config.maxListenersWarningThreshold = e;\n          }\n          get defaultReturnFormat() {\n            return this.config.defaultReturnFormat;\n          }\n          set defaultReturnFormat(e) {\n            this._triggerConfigChange(\"defaultReturnFormat\", e), this.config.defaultReturnFormat = e;\n          }\n          get defaultNetworkId() {\n            return this.config.defaultNetworkId;\n          }\n          set defaultNetworkId(e) {\n            this._triggerConfigChange(\"defaultNetworkId\", e), this.config.defaultNetworkId = e;\n          }\n          get defaultChain() {\n            return this.config.defaultChain;\n          }\n          set defaultChain(e) {\n            if (!(0, i.isNullish)(this.config.defaultCommon) && !(0, i.isNullish)(this.config.defaultCommon.baseChain) && e !== this.config.defaultCommon.baseChain) throw new o.ConfigChainMismatchError(this.config.defaultChain, e);\n            this._triggerConfigChange(\"defaultChain\", e), this.config.defaultChain = e;\n          }\n          get defaultHardfork() {\n            return this.config.defaultHardfork;\n          }\n          set defaultHardfork(e) {\n            if (!(0, i.isNullish)(this.config.defaultCommon) && !(0, i.isNullish)(this.config.defaultCommon.hardfork) && e !== this.config.defaultCommon.hardfork) throw new o.ConfigHardforkMismatchError(this.config.defaultCommon.hardfork, e);\n            this._triggerConfigChange(\"defaultHardfork\", e), this.config.defaultHardfork = e;\n          }\n          get defaultCommon() {\n            return this.config.defaultCommon;\n          }\n          set defaultCommon(e) {\n            if (!(0, i.isNullish)(this.config.defaultHardfork) && !(0, i.isNullish)(e) && !(0, i.isNullish)(e.hardfork) && this.config.defaultHardfork !== e.hardfork) throw new o.ConfigHardforkMismatchError(this.config.defaultHardfork, e.hardfork);\n            if (!(0, i.isNullish)(this.config.defaultChain) && !(0, i.isNullish)(e) && !(0, i.isNullish)(e.baseChain) && this.config.defaultChain !== e.baseChain) throw new o.ConfigChainMismatchError(this.config.defaultChain, e.baseChain);\n            this._triggerConfigChange(\"defaultCommon\", e), this.config.defaultCommon = e;\n          }\n          get defaultTransactionType() {\n            return this.config.defaultTransactionType;\n          }\n          set defaultTransactionType(e) {\n            this._triggerConfigChange(\"defaultTransactionType\", e), this.config.defaultTransactionType = e;\n          }\n          get defaultMaxPriorityFeePerGas() {\n            return this.config.defaultMaxPriorityFeePerGas;\n          }\n          set defaultMaxPriorityFeePerGas(e) {\n            this._triggerConfigChange(\"defaultMaxPriorityFeePerGas\", e), this.config.defaultMaxPriorityFeePerGas = e;\n          }\n          get transactionBuilder() {\n            return this.config.transactionBuilder;\n          }\n          set transactionBuilder(e) {\n            this._triggerConfigChange(\"transactionBuilder\", e), this.config.transactionBuilder = e;\n          }\n          get transactionTypeParser() {\n            return this.config.transactionTypeParser;\n          }\n          set transactionTypeParser(e) {\n            this._triggerConfigChange(\"transactionTypeParser\", e), this.config.transactionTypeParser = e;\n          }\n          _triggerConfigChange(e, t) {\n            this.emit(a.CONFIG_CHANGE, {\n              name: e,\n              oldValue: this.config[e],\n              newValue: t\n            });\n          }\n        }\n        t.Web3Config = c;\n      },\n      8174: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3EthPluginBase = t.Web3PluginBase = t.Web3Context = void 0;\n        const o = r(5071),\n          i = r(9634),\n          s = r(9247),\n          a = r(7003),\n          c = r(8202),\n          u = r(6171),\n          d = r(8441),\n          l = r(860);\n        class h extends u.Web3Config {\n          constructor(e) {\n            var t;\n            if (super(), this.providers = d.Web3RequestManager.providers, (0, i.isNullish)(e) || \"string\" == typeof e && \"\" !== e.trim() || (0, a.isSupportedProvider)(e)) return this._requestManager = new d.Web3RequestManager(e), void (this._subscriptionManager = new l.Web3SubscriptionManager(this._requestManager, {}));\n            const {\n              config: r,\n              provider: n,\n              requestManager: o,\n              subscriptionManager: s,\n              registeredSubscriptions: c,\n              accountProvider: u,\n              wallet: h,\n              requestManagerMiddleware: f\n            } = e;\n            this.setConfig(null != r ? r : {}), this._requestManager = null != o ? o : new d.Web3RequestManager(n, null === (t = null == r ? void 0 : r.enableExperimentalFeatures) || void 0 === t ? void 0 : t.useSubscriptionWhenCheckingBlockTimeout, f), this._subscriptionManager = s || new l.Web3SubscriptionManager(this.requestManager, null != c ? c : {}), u && (this._accountProvider = u), h && (this._wallet = h);\n          }\n          get requestManager() {\n            return this._requestManager;\n          }\n          get subscriptionManager() {\n            return this._subscriptionManager;\n          }\n          get wallet() {\n            return this._wallet;\n          }\n          get accountProvider() {\n            return this._accountProvider;\n          }\n          static fromContextObject(...e) {\n            return new this(...e.reverse());\n          }\n          getContextObject() {\n            var e;\n            return {\n              config: this.config,\n              provider: this.provider,\n              requestManager: this.requestManager,\n              subscriptionManager: this.subscriptionManager,\n              registeredSubscriptions: null === (e = this.subscriptionManager) || void 0 === e ? void 0 : e.registeredSubscriptions,\n              providers: this.providers,\n              wallet: this.wallet,\n              accountProvider: this.accountProvider\n            };\n          }\n          use(e, ...t) {\n            const r = new e(...[...t, this.getContextObject()]);\n            return this.on(u.Web3ConfigEvent.CONFIG_CHANGE, e => {\n              r.setConfig({\n                [e.name]: e.newValue\n              });\n            }), this[e.name] = r, r;\n          }\n          link(e) {\n            this.setConfig(e.config), this._requestManager = e.requestManager, this.provider = e.provider, this._subscriptionManager = e.subscriptionManager, this._wallet = e.wallet, this._accountProvider = e._accountProvider, e.on(u.Web3ConfigEvent.CONFIG_CHANGE, e => {\n              this.setConfig({\n                [e.name]: e.newValue\n              });\n            });\n          }\n          registerPlugin(e) {\n            if (void 0 !== this[e.pluginNamespace]) throw new o.ExistingPluginNamespaceError(e.pluginNamespace);\n            const t = {\n              [e.pluginNamespace]: e\n            };\n            t[e.pluginNamespace].link(this), Object.assign(this, t);\n          }\n          get provider() {\n            return this.currentProvider;\n          }\n          set provider(e) {\n            this.requestManager.setProvider(e);\n          }\n          get currentProvider() {\n            return this.requestManager.provider;\n          }\n          set currentProvider(e) {\n            this.requestManager.setProvider(e);\n          }\n          get givenProvider() {\n            return h.givenProvider;\n          }\n          setProvider(e) {\n            return this.provider = e, !0;\n          }\n          setRequestManagerMiddleware(e) {\n            this.requestManager.setMiddleware(e);\n          }\n          get BatchRequest() {\n            return c.Web3BatchRequest.bind(void 0, this._requestManager);\n          }\n          extend(e) {\n            var t;\n            return e.property && !this[e.property] && (this[e.property] = {}), null === (t = e.methods) || void 0 === t || t.forEach(t => {\n              const r = (...e) => n(this, void 0, void 0, function* () {\n                return this.requestManager.send({\n                  method: t.call,\n                  params: e\n                });\n              });\n              e.property ? this[e.property][t.name] = r : this[t.name] = r;\n            }), this;\n          }\n        }\n        t.Web3Context = h, h.providers = d.Web3RequestManager.providers;\n        class f extends h {\n          registerNewTransactionType(e, t) {\n            s.TransactionFactory.registerTransactionType(e, t);\n          }\n        }\n        t.Web3PluginBase = f, t.Web3EthPluginBase = class extends f {};\n      },\n      8976: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3EventEmitter = void 0;\n        const n = r(9634);\n        t.Web3EventEmitter = class {\n          constructor() {\n            this._emitter = new n.EventEmitter();\n          }\n          on(e, t) {\n            this._emitter.on(e, t);\n          }\n          once(e, t) {\n            this._emitter.once(e, t);\n          }\n          off(e, t) {\n            this._emitter.off(e, t);\n          }\n          emit(e, t) {\n            this._emitter.emit(e, t);\n          }\n          listenerCount(e) {\n            return this._emitter.listenerCount(e);\n          }\n          listeners(e) {\n            return this._emitter.listeners(e);\n          }\n          eventNames() {\n            return this._emitter.eventNames();\n          }\n          removeAllListeners() {\n            return this._emitter.removeAllListeners();\n          }\n          setMaxListenerWarningThreshold(e) {\n            this._emitter.setMaxListeners(e);\n          }\n          getMaxListeners() {\n            return this._emitter.getMaxListeners();\n          }\n        };\n      },\n      4738: function (e, t, r) {\n        \"use strict\";\n\n        var n,\n          o = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (o, i) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3PromiEvent = void 0;\n        const i = r(8976);\n        class s extends i.Web3EventEmitter {\n          constructor(e) {\n            super(), this[n] = \"Promise\", this._promise = new Promise(e);\n          }\n          then(e, t) {\n            return o(this, void 0, void 0, function* () {\n              return this._promise.then(e, t);\n            });\n          }\n          catch(e) {\n            return o(this, void 0, void 0, function* () {\n              return this._promise.catch(e);\n            });\n          }\n          finally(e) {\n            return o(this, void 0, void 0, function* () {\n              return this._promise.finally(e);\n            });\n          }\n          on(e, t) {\n            return super.on(e, t), this;\n          }\n          once(e, t) {\n            return super.once(e, t), this;\n          }\n        }\n        t.Web3PromiEvent = s, n = Symbol.toStringTag;\n      },\n      8441: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (o, i) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__importDefault || function (e) {\n            return e && e.__esModule ? e : {\n              default: e\n            };\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3RequestManager = t.Web3RequestManagerEvent = void 0;\n        const i = r(5071),\n          s = o(r(2636)),\n          a = o(r(1161)),\n          c = r(9634),\n          u = r(7003),\n          d = r(8976);\n        var l;\n        !function (e) {\n          e.PROVIDER_CHANGED = \"PROVIDER_CHANGED\", e.BEFORE_PROVIDER_CHANGE = \"BEFORE_PROVIDER_CHANGE\";\n        }(l = t.Web3RequestManagerEvent || (t.Web3RequestManagerEvent = {}));\n        const h = {\n          HttpProvider: s.default,\n          WebsocketProvider: a.default\n        };\n        class f extends d.Web3EventEmitter {\n          constructor(e, t, r) {\n            super(), (0, c.isNullish)(e) || this.setProvider(e), this.useRpcCallSpecification = t, (0, c.isNullish)(r) || (this.middleware = r);\n          }\n          static get providers() {\n            return h;\n          }\n          get provider() {\n            return this._provider;\n          }\n          get providers() {\n            return h;\n          }\n          setProvider(e) {\n            let t;\n            if (e && \"string\" == typeof e && this.providers) {\n              if (/^http(s)?:\\/\\//i.test(e)) t = new this.providers.HttpProvider(e);else {\n                if (!/^ws(s)?:\\/\\//i.test(e)) throw new i.ProviderError(`Can't autodetect provider for \"${e}\"`);\n                t = new this.providers.WebsocketProvider(e);\n              }\n            } else t = (0, c.isNullish)(e) ? void 0 : e;\n            return this.emit(l.BEFORE_PROVIDER_CHANGE, this._provider), this._provider = t, this.emit(l.PROVIDER_CHANGED, this._provider), !0;\n          }\n          setMiddleware(e) {\n            this.middleware = e;\n          }\n          send(e) {\n            return n(this, void 0, void 0, function* () {\n              const t = Object.assign({}, e);\n              let r = yield this._sendRequest(t);\n              if ((0, c.isNullish)(this.middleware) || (r = yield this.middleware.processResponse(r)), c.jsonRpc.isResponseWithResult(r)) return r.result;\n              throw new i.ResponseError(r);\n            });\n          }\n          sendBatch(e) {\n            return n(this, void 0, void 0, function* () {\n              return yield this._sendRequest(e);\n            });\n          }\n          _sendRequest(e) {\n            return n(this, void 0, void 0, function* () {\n              const {\n                provider: t\n              } = this;\n              if ((0, c.isNullish)(t)) throw new i.ProviderError(\"Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.\");\n              let r = c.jsonRpc.isBatchRequest(e) ? c.jsonRpc.toBatchPayload(e) : c.jsonRpc.toPayload(e);\n              if ((0, c.isNullish)(this.middleware) || (r = yield this.middleware.processRequest(r)), (0, u.isWeb3Provider)(t)) {\n                let e;\n                try {\n                  e = yield t.request(r);\n                } catch (t) {\n                  e = t;\n                }\n                return this._processJsonRpcResponse(r, e, {\n                  legacy: !1,\n                  error: !1\n                });\n              }\n              if ((0, u.isEIP1193Provider)(t)) return t.request(r).then(e => this._processJsonRpcResponse(r, e, {\n                legacy: !0,\n                error: !1\n              })).catch(e => this._processJsonRpcResponse(r, e, {\n                legacy: !0,\n                error: !0\n              }));\n              if ((0, u.isLegacyRequestProvider)(t)) return new Promise((e, n) => {\n                const o = e => {\n                    n(this._processJsonRpcResponse(r, e, {\n                      legacy: !0,\n                      error: !0\n                    }));\n                  },\n                  i = t => e(this._processJsonRpcResponse(r, t, {\n                    legacy: !0,\n                    error: !1\n                  })),\n                  s = t.request(r, (e, t) => e ? o(e) : i(t));\n                (0, c.isPromise)(s) && s.then(i).catch(e => {\n                  try {\n                    const t = this._processJsonRpcResponse(r, e, {\n                      legacy: !0,\n                      error: !0\n                    });\n                    n(t);\n                  } catch (e) {\n                    n(e);\n                  }\n                });\n              });\n              if ((0, u.isLegacySendProvider)(t)) return new Promise((e, n) => {\n                t.send(r, (t, o) => {\n                  if (t) return n(this._processJsonRpcResponse(r, t, {\n                    legacy: !0,\n                    error: !0\n                  }));\n                  if ((0, c.isNullish)(o)) throw new i.ResponseError({}, 'Got a \"nullish\" response from provider.');\n                  return e(this._processJsonRpcResponse(r, o, {\n                    legacy: !0,\n                    error: !1\n                  }));\n                });\n              });\n              if ((0, u.isLegacySendAsyncProvider)(t)) return t.sendAsync(r).then(e => this._processJsonRpcResponse(r, e, {\n                legacy: !0,\n                error: !1\n              })).catch(e => this._processJsonRpcResponse(r, e, {\n                legacy: !0,\n                error: !0\n              }));\n              throw new i.ProviderError(\"Provider does not have a request or send method to use.\");\n            });\n          }\n          _processJsonRpcResponse(e, t, {\n            legacy: r,\n            error: n\n          }) {\n            if ((0, c.isNullish)(t)) return this._buildResponse(e, null, n);\n            if (c.jsonRpc.isResponseWithError(t)) {\n              if (this.useRpcCallSpecification && (0, c.isResponseRpcError)(t)) {\n                const e = t;\n                if (i.rpcErrorsMap.get(e.error.code)) throw new (0, i.rpcErrorsMap.get(e.error.code).error)(e);\n                throw new i.RpcError(e);\n              }\n              if (!f._isReverted(t)) throw new i.InvalidResponseError(t, e);\n            }\n            if (c.jsonRpc.isResponseWithResult(t)) return t;\n            if (t instanceof Error) throw f._isReverted(t), t;\n            if (!r && c.jsonRpc.isBatchRequest(e) && c.jsonRpc.isBatchResponse(t)) return t;\n            if (r && !n && c.jsonRpc.isBatchRequest(e)) return t;\n            if (r && n && c.jsonRpc.isBatchRequest(e)) throw t;\n            if (r && !c.jsonRpc.isResponseWithError(t) && !c.jsonRpc.isResponseWithResult(t)) return this._buildResponse(e, t, n);\n            if (c.jsonRpc.isBatchRequest(e) && !Array.isArray(t)) throw new i.ResponseError(t, \"Got normal response for a batch request.\");\n            if (!c.jsonRpc.isBatchRequest(e) && Array.isArray(t)) throw new i.ResponseError(t, \"Got batch response for a normal request.\");\n            throw new i.ResponseError(t, \"Invalid response\");\n          }\n          static _isReverted(e) {\n            let t;\n            if (c.jsonRpc.isResponseWithError(e) ? t = e.error : e instanceof Error && (t = e), null == t ? void 0 : t.message.includes(\"revert\")) throw new i.ContractExecutionError(t);\n            return !1;\n          }\n          _buildResponse(e, t, r) {\n            const n = {\n              jsonrpc: \"2.0\",\n              id: c.jsonRpc.isBatchRequest(e) ? e[0].id : \"id\" in e ? e.id : null\n            };\n            return r ? Object.assign(Object.assign({}, n), {\n              error: t\n            }) : Object.assign(Object.assign({}, n), {\n              result: t\n            });\n          }\n        }\n        t.Web3RequestManager = f;\n      },\n      860: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3SubscriptionManager = void 0;\n        const o = r(9970),\n          i = r(5071),\n          s = r(9634),\n          a = r(7003),\n          c = r(8441);\n        t.Web3SubscriptionManager = class {\n          constructor(e, t, r = !1) {\n            this.requestManager = e, this.registeredSubscriptions = t, this.tolerateUnlinkedSubscription = r, this._subscriptions = new Map(), this.requestManager.on(c.Web3RequestManagerEvent.BEFORE_PROVIDER_CHANGE, () => n(this, void 0, void 0, function* () {\n              yield this.unsubscribe();\n            })), this.requestManager.on(c.Web3RequestManagerEvent.PROVIDER_CHANGED, () => {\n              this.clear(), this.listenToProviderEvents();\n            }), this.listenToProviderEvents();\n          }\n          listenToProviderEvents() {\n            const e = this.requestManager.provider;\n            this.requestManager.provider && (\"function\" != typeof (null == e ? void 0 : e.supportsSubscriptions) || (null == e ? void 0 : e.supportsSubscriptions())) && \"function\" == typeof this.requestManager.provider.on && (\"function\" == typeof this.requestManager.provider.request ? this.requestManager.provider.on(\"message\", e => this.messageListener(e)) : e.on(\"data\", e => this.messageListener(e)));\n          }\n          messageListener(e) {\n            var t, r, n;\n            if (!e) throw new i.SubscriptionError(\"Should not call messageListener with no data. Type was\");\n            const o = (null === (t = e.params) || void 0 === t ? void 0 : t.subscription) || (null === (r = e.data) || void 0 === r ? void 0 : r.subscription) || (null === (n = e.id) || void 0 === n ? void 0 : n.toString(16));\n            if (o) {\n              const t = this._subscriptions.get(o);\n              null == t || t.processSubscriptionData(e);\n            }\n          }\n          subscribe(e, t, r = o.DEFAULT_RETURN_FORMAT) {\n            return n(this, void 0, void 0, function* () {\n              const n = this.registeredSubscriptions[e];\n              if (!n) throw new i.SubscriptionError(\"Invalid subscription type\");\n              const o = new n(null != t ? t : void 0, {\n                subscriptionManager: this,\n                returnFormat: r\n              });\n              return yield this.addSubscription(o), o;\n            });\n          }\n          get subscriptions() {\n            return this._subscriptions;\n          }\n          addSubscription(e) {\n            return n(this, void 0, void 0, function* () {\n              if (!this.requestManager.provider) throw new i.ProviderError(\"Provider not available\");\n              if (!this.supportsSubscriptions()) throw new i.SubscriptionError(\"The current provider does not support subscriptions\");\n              if (e.id && this._subscriptions.has(e.id)) throw new i.SubscriptionError(`Subscription with id \"${e.id}\" already exists`);\n              if (yield e.sendSubscriptionRequest(), (0, s.isNullish)(e.id)) throw new i.SubscriptionError(\"Subscription is not subscribed yet.\");\n              return this._subscriptions.set(e.id, e), e.id;\n            });\n          }\n          removeSubscription(e) {\n            return n(this, void 0, void 0, function* () {\n              const {\n                id: t\n              } = e;\n              if ((0, s.isNullish)(t)) throw new i.SubscriptionError(\"Subscription is not subscribed yet. Or, had already been unsubscribed but not through the Subscription Manager.\");\n              if (!this._subscriptions.has(t) && !this.tolerateUnlinkedSubscription) throw new i.SubscriptionError(`Subscription with id \"${t.toString()}\" does not exists`);\n              return yield e.sendUnsubscribeRequest(), this._subscriptions.delete(t), t;\n            });\n          }\n          unsubscribe(e) {\n            return n(this, void 0, void 0, function* () {\n              const t = [];\n              for (const [r, n] of this.subscriptions.entries()) (!e || \"function\" == typeof e && e({\n                id: r,\n                sub: n\n              })) && t.push(this.removeSubscription(n));\n              return Promise.all(t);\n            });\n          }\n          clear() {\n            this._subscriptions.clear();\n          }\n          supportsSubscriptions() {\n            return !(0, s.isNullish)(this.requestManager.provider) && (0, a.isSupportSubscriptions)(this.requestManager.provider);\n          }\n        };\n      },\n      1819: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3Subscription = void 0;\n        const o = r(9970),\n          i = r(9634),\n          s = r(860),\n          a = r(8976);\n        class c extends a.Web3EventEmitter {\n          constructor(e, t) {\n            var r;\n            super(), this.args = e;\n            const {\n                requestManager: n\n              } = t,\n              {\n                subscriptionManager: i\n              } = t;\n            this._subscriptionManager = n ? new s.Web3SubscriptionManager(n, {}, !0) : i, this._returnFormat = null !== (r = null == t ? void 0 : t.returnFormat) && void 0 !== r ? r : o.DEFAULT_RETURN_FORMAT;\n          }\n          get id() {\n            return this._id;\n          }\n          get lastBlock() {\n            return this._lastBlock;\n          }\n          subscribe() {\n            return n(this, void 0, void 0, function* () {\n              return this._subscriptionManager.addSubscription(this);\n            });\n          }\n          processSubscriptionData(e) {\n            var t, r;\n            (null == e ? void 0 : e.data) ? this._processSubscriptionResult(null !== (r = null === (t = null == e ? void 0 : e.data) || void 0 === t ? void 0 : t.result) && void 0 !== r ? r : null == e ? void 0 : e.data) : e && i.jsonRpc.isResponseWithNotification(e) && this._processSubscriptionResult(null == e ? void 0 : e.params.result);\n          }\n          sendSubscriptionRequest() {\n            return n(this, void 0, void 0, function* () {\n              return this._id = yield this._subscriptionManager.requestManager.send({\n                method: \"eth_subscribe\",\n                params: this._buildSubscriptionParams()\n              }), this.emit(\"connected\", this._id), this._id;\n            });\n          }\n          get returnFormat() {\n            return this._returnFormat;\n          }\n          get subscriptionManager() {\n            return this._subscriptionManager;\n          }\n          resubscribe() {\n            return n(this, void 0, void 0, function* () {\n              yield this.unsubscribe(), yield this.subscribe();\n            });\n          }\n          unsubscribe() {\n            return n(this, void 0, void 0, function* () {\n              this.id && (yield this._subscriptionManager.removeSubscription(this));\n            });\n          }\n          sendUnsubscribeRequest() {\n            return n(this, void 0, void 0, function* () {\n              yield this._subscriptionManager.requestManager.send({\n                method: \"eth_unsubscribe\",\n                params: [this.id]\n              }), this._id = void 0;\n            });\n          }\n          formatSubscriptionResult(e) {\n            return e;\n          }\n          _processSubscriptionResult(e) {\n            this.emit(\"data\", this.formatSubscriptionResult(e));\n          }\n          _processSubscriptionError(e) {\n            this.emit(\"error\", e);\n          }\n          _buildSubscriptionParams() {\n            throw new Error(\"Implement in the child class\");\n          }\n        }\n        t.Web3Subscription = c;\n      },\n      7639: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ERR_TX_POLLING_TIMEOUT = t.ERR_TX_DATA_AND_INPUT = t.ERR_TX_UNSUPPORTED_TYPE = t.ERR_TX_UNSUPPORTED_EIP_1559 = t.ERR_TX_UNABLE_TO_POPULATE_NONCE = t.ERR_TX_INVALID_NONCE_OR_CHAIN_ID = t.ERR_TX_INVALID_OBJECT = t.ERR_TX_INVALID_LEGACY_FEE_MARKET = t.ERR_TX_INVALID_FEE_MARKET_GAS_PRICE = t.ERR_TX_INVALID_FEE_MARKET_GAS = t.ERR_TX_INVALID_LEGACY_GAS = t.ERR_TX_MISSING_GAS = t.ERR_TX_MISSING_CHAIN_INFO = t.ERR_TX_INVALID_CHAIN_INFO = t.ERR_TX_CHAIN_ID_MISMATCH = t.ERR_TX_MISSING_CUSTOM_CHAIN_ID = t.ERR_TX_MISSING_CUSTOM_CHAIN = t.ERR_TX_INVALID_CALL = t.ERR_TX_INVALID_SENDER = t.ERR_RAW_TX_UNDEFINED = t.ERR_TX_OUT_OF_GAS = t.ERR_TX_REVERT_WITHOUT_REASON = t.ERR_TX_CONTRACT_NOT_STORED = t.ERR_TX_NO_CONTRACT_ADDRESS = t.ERR_TX_REVERT_TRANSACTION = t.ERR_TX_REVERT_INSTRUCTION = t.ERR_TX = t.ERR_CONTRACT_TX_DATA_AND_INPUT = t.ERR_CONTRACT_EXECUTION_REVERTED = t.ERR_CONTRACT_INSTANTIATION = t.ERR_CONTRACT_MISSING_FROM_ADDRESS = t.ERR_CONTRACT_MISSING_ADDRESS = t.ERR_CONTRACT_MISSING_DEPLOY_DATA = t.ERR_CONTRACT_RESERVED_EVENT = t.ERR_CONTRACT_EVENT_NOT_EXISTS = t.ERR_CONTRACT_REQUIRED_CALLBACK = t.ERR_CONTRACT_ABI_MISSING = t.ERR_CONTRACT_RESOLVER_MISSING = t.ERR_CONTRACT = t.ERR_MULTIPLE_ERRORS = t.ERR_INVALID_METHOD_PARAMS = t.ERR_EXISTING_PLUGIN_NAMESPACE = t.ERR_ABI_ENCODING = t.ERR_OPERATION_ABORT = t.ERR_OPERATION_TIMEOUT = t.ERR_METHOD_NOT_IMPLEMENTED = t.ERR_FORMATTERS = t.ERR_PARAM = t.ERR_INVALID_RESPONSE = t.ERR_RESPONSE = void 0, t.ERR_INVALID_BYTES = t.ERR_INVALID_STRING = t.ERR_ENS_NETWORK_NOT_SYNCED = t.ERR_ENS_UNSUPPORTED_NETWORK = t.ERR_ENS_CHECK_INTERFACE_SUPPORT = t.JSONRPC_ERR_CHAIN_DISCONNECTED = t.JSONRPC_ERR_DISCONNECTED = t.JSONRPC_ERR_UNSUPPORTED_METHOD = t.JSONRPC_ERR_UNAUTHORIZED = t.JSONRPC_ERR_REJECTED_REQUEST = t.GENESIS_BLOCK_NUMBER = t.ERR_INVALID_SIGNATURE = t.ERR_SIGNATURE_FAILED = t.ERR_PBKDF2_ITERATIONS = t.ERR_INVALID_KEYSTORE = t.ERR_IV_LENGTH = t.ERR_INVALID_PASSWORD = t.ERR_KEY_VERSION_UNSUPPORTED = t.ERR_KEY_DERIVATION_FAIL = t.ERR_UNSUPPORTED_KDF = t.ERR_INVALID_PRIVATE_KEY = t.ERR_PRIVATE_KEY_LENGTH = t.ERR_WS_PROVIDER = t.ERR_SUBSCRIPTION = t.ERR_INVALID_CLIENT = t.ERR_INVALID_PROVIDER = t.ERR_PROVIDER = t.ERR_REQ_ALREADY_SENT = t.ERR_CONN_PENDING_REQUESTS = t.ERR_CONN_MAX_ATTEMPTS = t.ERR_CONN_CLOSE = t.ERR_CONN_NOT_OPEN = t.ERR_CONN_TIMEOUT = t.ERR_CONN_INVALID = t.ERR_CONN = t.ERR_TX_GAS_MISMATCH_INNER_ERROR = t.ERR_TX_MISSING_GAS_INNER_ERROR = t.ERR_TX_INVALID_PROPERTIES_FOR_TYPE = t.ERR_TX_REVERT_TRANSACTION_CUSTOM_ERROR = t.ERR_TX_INVALID_RECEIVER = t.ERR_TX_HARDFORK_MISMATCH = t.ERR_TX_CHAIN_MISMATCH = t.ERR_TX_GAS_MISMATCH = t.ERR_TX_SIGNING = t.ERR_TX_BLOCK_TIMEOUT = t.ERR_TX_SEND_TIMEOUT = t.ERR_TX_NOT_FOUND = t.ERR_TX_LOCAL_WALLET_NOT_AVAILABLE = t.ERR_TX_RECEIPT_MISSING_BLOCK_NUMBER = t.ERR_TX_RECEIPT_MISSING_OR_BLOCKHASH_NULL = void 0, t.ERR_RPC_NOT_SUPPORTED = t.ERR_RPC_LIMIT_EXCEEDED = t.ERR_RPC_UNSUPPORTED_METHOD = t.ERR_RPC_TRANSACTION_REJECTED = t.ERR_RPC_UNAVAILABLE_RESOURCE = t.ERR_RPC_MISSING_RESOURCE = t.ERR_RPC_INVALID_INPUT = t.ERR_RPC_INTERNAL_ERROR = t.ERR_RPC_INVALID_PARAMS = t.ERR_RPC_INVALID_METHOD = t.ERR_RPC_INVALID_REQUEST = t.ERR_RPC_INVALID_JSON = t.ERR_SCHEMA_FORMAT = t.ERR_CORE_CHAIN_MISMATCH = t.ERR_CORE_HARDFORK_MISMATCH = t.ERR_VALIDATION = t.ERR_INVALID_INTEGER = t.ERR_INVALID_NIBBLE_WIDTH = t.ERR_INVALID_TYPE_ABI = t.ERR_INVALID_BLOCK = t.ERR_INVALID_LARGE_VALUE = t.ERR_INVALID_SIZE = t.ERR_INVALID_UNSIGNED_INTEGER = t.ERR_INVALID_BOOLEAN = t.ERR_INVALID_TYPE = t.ERR_INVALID_HEX = t.ERR_INVALID_ADDRESS = t.ERR_INVALID_UNIT = t.ERR_INVALID_NUMBER = void 0, t.ERR_RESPONSE = 100, t.ERR_INVALID_RESPONSE = 101, t.ERR_PARAM = 200, t.ERR_FORMATTERS = 201, t.ERR_METHOD_NOT_IMPLEMENTED = 202, t.ERR_OPERATION_TIMEOUT = 203, t.ERR_OPERATION_ABORT = 204, t.ERR_ABI_ENCODING = 205, t.ERR_EXISTING_PLUGIN_NAMESPACE = 206, t.ERR_INVALID_METHOD_PARAMS = 207, t.ERR_MULTIPLE_ERRORS = 208, t.ERR_CONTRACT = 300, t.ERR_CONTRACT_RESOLVER_MISSING = 301, t.ERR_CONTRACT_ABI_MISSING = 302, t.ERR_CONTRACT_REQUIRED_CALLBACK = 303, t.ERR_CONTRACT_EVENT_NOT_EXISTS = 304, t.ERR_CONTRACT_RESERVED_EVENT = 305, t.ERR_CONTRACT_MISSING_DEPLOY_DATA = 306, t.ERR_CONTRACT_MISSING_ADDRESS = 307, t.ERR_CONTRACT_MISSING_FROM_ADDRESS = 308, t.ERR_CONTRACT_INSTANTIATION = 309, t.ERR_CONTRACT_EXECUTION_REVERTED = 310, t.ERR_CONTRACT_TX_DATA_AND_INPUT = 311, t.ERR_TX = 400, t.ERR_TX_REVERT_INSTRUCTION = 401, t.ERR_TX_REVERT_TRANSACTION = 402, t.ERR_TX_NO_CONTRACT_ADDRESS = 403, t.ERR_TX_CONTRACT_NOT_STORED = 404, t.ERR_TX_REVERT_WITHOUT_REASON = 405, t.ERR_TX_OUT_OF_GAS = 406, t.ERR_RAW_TX_UNDEFINED = 407, t.ERR_TX_INVALID_SENDER = 408, t.ERR_TX_INVALID_CALL = 409, t.ERR_TX_MISSING_CUSTOM_CHAIN = 410, t.ERR_TX_MISSING_CUSTOM_CHAIN_ID = 411, t.ERR_TX_CHAIN_ID_MISMATCH = 412, t.ERR_TX_INVALID_CHAIN_INFO = 413, t.ERR_TX_MISSING_CHAIN_INFO = 414, t.ERR_TX_MISSING_GAS = 415, t.ERR_TX_INVALID_LEGACY_GAS = 416, t.ERR_TX_INVALID_FEE_MARKET_GAS = 417, t.ERR_TX_INVALID_FEE_MARKET_GAS_PRICE = 418, t.ERR_TX_INVALID_LEGACY_FEE_MARKET = 419, t.ERR_TX_INVALID_OBJECT = 420, t.ERR_TX_INVALID_NONCE_OR_CHAIN_ID = 421, t.ERR_TX_UNABLE_TO_POPULATE_NONCE = 422, t.ERR_TX_UNSUPPORTED_EIP_1559 = 423, t.ERR_TX_UNSUPPORTED_TYPE = 424, t.ERR_TX_DATA_AND_INPUT = 425, t.ERR_TX_POLLING_TIMEOUT = 426, t.ERR_TX_RECEIPT_MISSING_OR_BLOCKHASH_NULL = 427, t.ERR_TX_RECEIPT_MISSING_BLOCK_NUMBER = 428, t.ERR_TX_LOCAL_WALLET_NOT_AVAILABLE = 429, t.ERR_TX_NOT_FOUND = 430, t.ERR_TX_SEND_TIMEOUT = 431, t.ERR_TX_BLOCK_TIMEOUT = 432, t.ERR_TX_SIGNING = 433, t.ERR_TX_GAS_MISMATCH = 434, t.ERR_TX_CHAIN_MISMATCH = 435, t.ERR_TX_HARDFORK_MISMATCH = 436, t.ERR_TX_INVALID_RECEIVER = 437, t.ERR_TX_REVERT_TRANSACTION_CUSTOM_ERROR = 438, t.ERR_TX_INVALID_PROPERTIES_FOR_TYPE = 439, t.ERR_TX_MISSING_GAS_INNER_ERROR = 440, t.ERR_TX_GAS_MISMATCH_INNER_ERROR = 441, t.ERR_CONN = 500, t.ERR_CONN_INVALID = 501, t.ERR_CONN_TIMEOUT = 502, t.ERR_CONN_NOT_OPEN = 503, t.ERR_CONN_CLOSE = 504, t.ERR_CONN_MAX_ATTEMPTS = 505, t.ERR_CONN_PENDING_REQUESTS = 506, t.ERR_REQ_ALREADY_SENT = 507, t.ERR_PROVIDER = 600, t.ERR_INVALID_PROVIDER = 601, t.ERR_INVALID_CLIENT = 602, t.ERR_SUBSCRIPTION = 603, t.ERR_WS_PROVIDER = 604, t.ERR_PRIVATE_KEY_LENGTH = 701, t.ERR_INVALID_PRIVATE_KEY = 702, t.ERR_UNSUPPORTED_KDF = 703, t.ERR_KEY_DERIVATION_FAIL = 704, t.ERR_KEY_VERSION_UNSUPPORTED = 705, t.ERR_INVALID_PASSWORD = 706, t.ERR_IV_LENGTH = 707, t.ERR_INVALID_KEYSTORE = 708, t.ERR_PBKDF2_ITERATIONS = 709, t.ERR_SIGNATURE_FAILED = 801, t.ERR_INVALID_SIGNATURE = 802, t.GENESIS_BLOCK_NUMBER = \"0x0\", t.JSONRPC_ERR_REJECTED_REQUEST = 4001, t.JSONRPC_ERR_UNAUTHORIZED = 4100, t.JSONRPC_ERR_UNSUPPORTED_METHOD = 4200, t.JSONRPC_ERR_DISCONNECTED = 4900, t.JSONRPC_ERR_CHAIN_DISCONNECTED = 4901, t.ERR_ENS_CHECK_INTERFACE_SUPPORT = 901, t.ERR_ENS_UNSUPPORTED_NETWORK = 902, t.ERR_ENS_NETWORK_NOT_SYNCED = 903, t.ERR_INVALID_STRING = 1001, t.ERR_INVALID_BYTES = 1002, t.ERR_INVALID_NUMBER = 1003, t.ERR_INVALID_UNIT = 1004, t.ERR_INVALID_ADDRESS = 1005, t.ERR_INVALID_HEX = 1006, t.ERR_INVALID_TYPE = 1007, t.ERR_INVALID_BOOLEAN = 1008, t.ERR_INVALID_UNSIGNED_INTEGER = 1009, t.ERR_INVALID_SIZE = 1010, t.ERR_INVALID_LARGE_VALUE = 1011, t.ERR_INVALID_BLOCK = 1012, t.ERR_INVALID_TYPE_ABI = 1013, t.ERR_INVALID_NIBBLE_WIDTH = 1014, t.ERR_INVALID_INTEGER = 1015, t.ERR_VALIDATION = 1100, t.ERR_CORE_HARDFORK_MISMATCH = 1101, t.ERR_CORE_CHAIN_MISMATCH = 1102, t.ERR_SCHEMA_FORMAT = 1200, t.ERR_RPC_INVALID_JSON = -32700, t.ERR_RPC_INVALID_REQUEST = -32600, t.ERR_RPC_INVALID_METHOD = -32601, t.ERR_RPC_INVALID_PARAMS = -32602, t.ERR_RPC_INTERNAL_ERROR = -32603, t.ERR_RPC_INVALID_INPUT = -32e3, t.ERR_RPC_MISSING_RESOURCE = -32001, t.ERR_RPC_UNAVAILABLE_RESOURCE = -32002, t.ERR_RPC_TRANSACTION_REJECTED = -32003, t.ERR_RPC_UNSUPPORTED_METHOD = -32004, t.ERR_RPC_LIMIT_EXCEEDED = -32005, t.ERR_RPC_NOT_SUPPORTED = -32006;\n      },\n      8105: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.PBKDF2IterationsError = t.IVLengthError = t.InvalidPasswordError = t.KeyStoreVersionError = t.KeyDerivationError = t.InvalidKdfError = t.InvalidSignatureError = t.InvalidPrivateKeyError = t.PrivateKeyLengthError = void 0;\n        const n = r(7639),\n          o = r(3685);\n        class i extends o.BaseWeb3Error {\n          constructor() {\n            super(\"Private key must be 32 bytes.\"), this.code = n.ERR_PRIVATE_KEY_LENGTH;\n          }\n        }\n        t.PrivateKeyLengthError = i;\n        class s extends o.BaseWeb3Error {\n          constructor() {\n            super(\"Invalid Private Key, Not a valid string or uint8Array\"), this.code = n.ERR_INVALID_PRIVATE_KEY;\n          }\n        }\n        t.InvalidPrivateKeyError = s;\n        class a extends o.BaseWeb3Error {\n          constructor(e) {\n            super(`\"${e}\"`), this.code = n.ERR_INVALID_SIGNATURE;\n          }\n        }\n        t.InvalidSignatureError = a;\n        class c extends o.BaseWeb3Error {\n          constructor() {\n            super(\"Invalid key derivation function\"), this.code = n.ERR_UNSUPPORTED_KDF;\n          }\n        }\n        t.InvalidKdfError = c;\n        class u extends o.BaseWeb3Error {\n          constructor() {\n            super(\"Key derivation failed - possibly wrong password\"), this.code = n.ERR_KEY_DERIVATION_FAIL;\n          }\n        }\n        t.KeyDerivationError = u;\n        class d extends o.BaseWeb3Error {\n          constructor() {\n            super(\"Unsupported key store version\"), this.code = n.ERR_KEY_VERSION_UNSUPPORTED;\n          }\n        }\n        t.KeyStoreVersionError = d;\n        class l extends o.BaseWeb3Error {\n          constructor() {\n            super(\"Password cannot be empty\"), this.code = n.ERR_INVALID_PASSWORD;\n          }\n        }\n        t.InvalidPasswordError = l;\n        class h extends o.BaseWeb3Error {\n          constructor() {\n            super(\"Initialization vector must be 16 bytes\"), this.code = n.ERR_IV_LENGTH;\n          }\n        }\n        t.IVLengthError = h;\n        class f extends o.BaseWeb3Error {\n          constructor() {\n            super(\"c > 1000, pbkdf2 is less secure with less iterations\"), this.code = n.ERR_PBKDF2_ITERATIONS;\n          }\n        }\n        t.PBKDF2IterationsError = f;\n      },\n      3789: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.RequestAlreadySentError = t.PendingRequestsOnReconnectingError = t.MaxAttemptsReachedOnReconnectingError = t.ConnectionCloseError = t.ConnectionNotOpenError = t.ConnectionTimeoutError = t.InvalidConnectionError = t.ConnectionError = void 0;\n        const n = r(7639),\n          o = r(3685);\n        class i extends o.BaseWeb3Error {\n          constructor(e, t) {\n            super(e), this.code = n.ERR_CONN, t && (this.errorCode = t.code, this.errorReason = t.reason);\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              errorCode: this.errorCode,\n              errorReason: this.errorReason\n            });\n          }\n        }\n        t.ConnectionError = i, t.InvalidConnectionError = class extends i {\n          constructor(e, t) {\n            super(`CONNECTION ERROR: Couldn't connect to node ${e}.`, t), this.host = e, this.code = n.ERR_CONN_INVALID;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              host: this.host\n            });\n          }\n        }, t.ConnectionTimeoutError = class extends i {\n          constructor(e) {\n            super(`CONNECTION TIMEOUT: timeout of ${e}ms achieved`), this.duration = e, this.code = n.ERR_CONN_TIMEOUT;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              duration: this.duration\n            });\n          }\n        }, t.ConnectionNotOpenError = class extends i {\n          constructor(e) {\n            super(\"Connection not open\", e), this.code = n.ERR_CONN_NOT_OPEN;\n          }\n        }, t.ConnectionCloseError = class extends i {\n          constructor(e) {\n            var t, r;\n            super(`CONNECTION ERROR: The connection got closed with the close code ${null !== (t = null == e ? void 0 : e.code) && void 0 !== t ? t : \"\"} and the following reason string ${null !== (r = null == e ? void 0 : e.reason) && void 0 !== r ? r : \"\"}`, e), this.code = n.ERR_CONN_CLOSE;\n          }\n        }, t.MaxAttemptsReachedOnReconnectingError = class extends i {\n          constructor(e) {\n            super(`Maximum number of reconnect attempts reached! (${e})`), this.code = n.ERR_CONN_MAX_ATTEMPTS;\n          }\n        }, t.PendingRequestsOnReconnectingError = class extends i {\n          constructor() {\n            super(\"CONNECTION ERROR: Provider started to reconnect before the response got received!\"), this.code = n.ERR_CONN_PENDING_REQUESTS;\n          }\n        }, t.RequestAlreadySentError = class extends i {\n          constructor(e) {\n            super(`Request already sent with following id: ${e}`), this.code = n.ERR_REQ_ALREADY_SENT;\n          }\n        };\n      },\n      510: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ContractTransactionDataAndInputError = t.ContractExecutionError = t.Eip838ExecutionError = t.ContractInstantiationError = t.ContractNoFromAddressDefinedError = t.ContractNoAddressDefinedError = t.ContractMissingDeployDataError = t.ContractReservedEventError = t.ContractEventDoesNotExistError = t.ContractOnceRequiresCallbackError = t.ContractMissingABIError = t.ResolverMethodMissingError = t.Web3ContractError = void 0;\n        const n = r(7639),\n          o = r(3685);\n        class i extends o.BaseWeb3Error {\n          constructor(e, t) {\n            super(e), this.code = n.ERR_CONTRACT, this.receipt = t;\n          }\n        }\n        t.Web3ContractError = i;\n        class s extends o.BaseWeb3Error {\n          constructor(e, t) {\n            super(`The resolver at ${e} does not implement requested method: \"${t}\".`), this.address = e, this.name = t, this.code = n.ERR_CONTRACT_RESOLVER_MISSING;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              address: this.address,\n              name: this.name\n            });\n          }\n        }\n        t.ResolverMethodMissingError = s;\n        class a extends o.BaseWeb3Error {\n          constructor() {\n            super(\"You must provide the json interface of the contract when instantiating a contract object.\"), this.code = n.ERR_CONTRACT_ABI_MISSING;\n          }\n        }\n        t.ContractMissingABIError = a;\n        class c extends o.BaseWeb3Error {\n          constructor() {\n            super(\"Once requires a callback as the second parameter.\"), this.code = n.ERR_CONTRACT_REQUIRED_CALLBACK;\n          }\n        }\n        t.ContractOnceRequiresCallbackError = c;\n        class u extends o.BaseWeb3Error {\n          constructor(e) {\n            super(`Event \"${e}\" doesn't exist in this contract.`), this.eventName = e, this.code = n.ERR_CONTRACT_EVENT_NOT_EXISTS;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              eventName: this.eventName\n            });\n          }\n        }\n        t.ContractEventDoesNotExistError = u;\n        class d extends o.BaseWeb3Error {\n          constructor(e) {\n            super(`Event \"${e}\" doesn't exist in this contract.`), this.type = e, this.code = n.ERR_CONTRACT_RESERVED_EVENT;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              type: this.type\n            });\n          }\n        }\n        t.ContractReservedEventError = d;\n        class l extends o.BaseWeb3Error {\n          constructor() {\n            super('No \"data\" specified in neither the given options, nor the default options.'), this.code = n.ERR_CONTRACT_MISSING_DEPLOY_DATA;\n          }\n        }\n        t.ContractMissingDeployDataError = l;\n        class h extends o.BaseWeb3Error {\n          constructor() {\n            super(\"This contract object doesn't have address set yet, please set an address first.\"), this.code = n.ERR_CONTRACT_MISSING_ADDRESS;\n          }\n        }\n        t.ContractNoAddressDefinedError = h;\n        class f extends o.BaseWeb3Error {\n          constructor() {\n            super('No \"from\" address specified in neither the given options, nor the default options.'), this.code = n.ERR_CONTRACT_MISSING_FROM_ADDRESS;\n          }\n        }\n        t.ContractNoFromAddressDefinedError = f;\n        class p extends o.BaseWeb3Error {\n          constructor() {\n            super(...arguments), this.code = n.ERR_CONTRACT_INSTANTIATION;\n          }\n        }\n        t.ContractInstantiationError = p;\n        class m extends i {\n          constructor(e) {\n            if (super(e.message || \"Error\"), this.name = \"name\" in e && e.name || this.constructor.name, this.stack = \"stack\" in e && e.stack || void 0, this.code = e.code, \"object\" == typeof e.data) {\n              let t;\n              t = \"originalError\" in e.data ? e.data.originalError : e.data, this.data = t.data, this.cause = new m(t);\n            } else this.data = e.data;\n          }\n          setDecodedProperties(e, t, r) {\n            this.errorName = e, this.errorSignature = t, this.errorArgs = r;\n          }\n          toJSON() {\n            let e = Object.assign(Object.assign({}, super.toJSON()), {\n              data: this.data\n            });\n            return this.errorName && (e = Object.assign(Object.assign({}, e), {\n              errorName: this.errorName,\n              errorSignature: this.errorSignature,\n              errorArgs: this.errorArgs\n            })), e;\n          }\n        }\n        t.Eip838ExecutionError = m, t.ContractExecutionError = class extends i {\n          constructor(e) {\n            super(\"Error happened while trying to execute a function inside a smart contract\"), this.code = n.ERR_CONTRACT_EXECUTION_REVERTED, this.cause = new m(e);\n          }\n        };\n        class g extends o.InvalidValueError {\n          constructor(e) {\n            var t, r;\n            super(`data: ${null !== (t = e.data) && void 0 !== t ? t : \"undefined\"}, input: ${null !== (r = e.input) && void 0 !== r ? r : \"undefined\"}`, 'You can\\'t have \"data\" and \"input\" as properties of a contract at the same time, please use either \"data\" or \"input\" instead.'), this.code = n.ERR_CONTRACT_TX_DATA_AND_INPUT;\n          }\n        }\n        t.ContractTransactionDataAndInputError = g;\n      },\n      3628: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ConfigChainMismatchError = t.ConfigHardforkMismatchError = void 0;\n        const n = r(3685),\n          o = r(7639);\n        class i extends n.BaseWeb3Error {\n          constructor(e, t) {\n            super(`Web3Config hardfork doesnt match in defaultHardfork ${e} and common.hardfork ${t}`), this.code = o.ERR_CORE_HARDFORK_MISMATCH;\n          }\n        }\n        t.ConfigHardforkMismatchError = i;\n        class s extends n.BaseWeb3Error {\n          constructor(e, t) {\n            super(`Web3Config chain doesnt match in defaultHardfork ${e} and common.hardfork ${t}`), this.code = o.ERR_CORE_HARDFORK_MISMATCH;\n          }\n        }\n        t.ConfigChainMismatchError = s;\n      },\n      1591: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ENSNetworkNotSyncedError = t.ENSUnsupportedNetworkError = t.ENSCheckInterfaceSupportError = void 0;\n        const n = r(7639),\n          o = r(3685);\n        class i extends o.BaseWeb3Error {\n          constructor(e) {\n            super(`ENS resolver check interface support error. \"${e}\"`), this.code = n.ERR_ENS_CHECK_INTERFACE_SUPPORT;\n          }\n        }\n        t.ENSCheckInterfaceSupportError = i;\n        class s extends o.BaseWeb3Error {\n          constructor(e) {\n            super(`ENS is not supported on network ${e}`), this.code = n.ERR_ENS_UNSUPPORTED_NETWORK;\n          }\n        }\n        t.ENSUnsupportedNetworkError = s;\n        class a extends o.BaseWeb3Error {\n          constructor() {\n            super(\"Network not synced\"), this.code = n.ERR_ENS_NETWORK_NOT_SYNCED;\n          }\n        }\n        t.ENSNetworkNotSyncedError = a;\n      },\n      7297: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ExistingPluginNamespaceError = t.AbiError = t.OperationAbortError = t.OperationTimeoutError = t.MethodNotImplementedError = t.FormatterError = t.InvalidMethodParamsError = t.InvalidNumberOfParamsError = void 0;\n        const n = r(7639),\n          o = r(3685);\n        class i extends o.BaseWeb3Error {\n          constructor(e, t, r) {\n            super(`Invalid number of parameters for \"${r}\". Got \"${e}\" expected \"${t}\"!`), this.got = e, this.expected = t, this.method = r, this.code = n.ERR_PARAM;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              got: this.got,\n              expected: this.expected,\n              method: this.method\n            });\n          }\n        }\n        t.InvalidNumberOfParamsError = i;\n        class s extends o.BaseWeb3Error {\n          constructor(e) {\n            super(`Invalid parameters passed. \"${void 0 !== e ? e : \"\"}\"`), this.hint = e, this.code = n.ERR_INVALID_METHOD_PARAMS;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              hint: this.hint\n            });\n          }\n        }\n        t.InvalidMethodParamsError = s;\n        class a extends o.BaseWeb3Error {\n          constructor() {\n            super(...arguments), this.code = n.ERR_FORMATTERS;\n          }\n        }\n        t.FormatterError = a;\n        class c extends o.BaseWeb3Error {\n          constructor() {\n            super(\"The method you're trying to call is not implemented.\"), this.code = n.ERR_METHOD_NOT_IMPLEMENTED;\n          }\n        }\n        t.MethodNotImplementedError = c;\n        class u extends o.BaseWeb3Error {\n          constructor() {\n            super(...arguments), this.code = n.ERR_OPERATION_TIMEOUT;\n          }\n        }\n        t.OperationTimeoutError = u;\n        class d extends o.BaseWeb3Error {\n          constructor() {\n            super(...arguments), this.code = n.ERR_OPERATION_ABORT;\n          }\n        }\n        t.OperationAbortError = d;\n        class l extends o.BaseWeb3Error {\n          constructor(e, t) {\n            super(e), this.code = n.ERR_ABI_ENCODING, this.props = null != t ? t : {};\n          }\n        }\n        t.AbiError = l;\n        class h extends o.BaseWeb3Error {\n          constructor(e) {\n            super(`A plugin with the namespace: ${e} has already been registered.`), this.code = n.ERR_EXISTING_PLUGIN_NAMESPACE;\n          }\n        }\n        t.ExistingPluginNamespaceError = h;\n      },\n      7108: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3WSProviderError = t.SubscriptionError = t.InvalidClientError = t.InvalidProviderError = t.ProviderError = void 0;\n        const n = r(7639),\n          o = r(3685);\n        class i extends o.BaseWeb3Error {\n          constructor() {\n            super(...arguments), this.code = n.ERR_PROVIDER;\n          }\n        }\n        t.ProviderError = i;\n        class s extends o.BaseWeb3Error {\n          constructor(e) {\n            super(`Provider with url \"${e}\" is not set or invalid`), this.clientUrl = e, this.code = n.ERR_INVALID_PROVIDER;\n          }\n        }\n        t.InvalidProviderError = s;\n        class a extends o.BaseWeb3Error {\n          constructor(e) {\n            super(`Client URL \"${e}\" is invalid.`), this.code = n.ERR_INVALID_CLIENT;\n          }\n        }\n        t.InvalidClientError = a;\n        class c extends o.BaseWeb3Error {\n          constructor() {\n            super(...arguments), this.code = n.ERR_SUBSCRIPTION;\n          }\n        }\n        t.SubscriptionError = c;\n        class u extends o.BaseWeb3Error {\n          constructor() {\n            super(...arguments), this.code = n.ERR_WS_PROVIDER;\n          }\n        }\n        t.Web3WSProviderError = u;\n      },\n      9491: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.InvalidResponseError = t.ResponseError = void 0;\n        const n = r(3685),\n          o = r(7639),\n          i = e => (e => !(Array.isArray(e) || \"2.0\" !== e.jsonrpc || !e || void 0 !== e.result && null !== e.result || !(\"error\" in e) || \"number\" != typeof e.id && \"string\" != typeof e.id))(e) ? e.error.message : \"\";\n        class s extends n.BaseWeb3Error {\n          constructor(e, t, r) {\n            var s;\n            let a;\n            super(null != t ? t : `Returned error: ${Array.isArray(e) ? e.map(e => i(e)).join(\",\") : i(e)}`), this.code = o.ERR_RESPONSE, t || (this.data = Array.isArray(e) ? e.map(e => {\n              var t;\n              return null === (t = e.error) || void 0 === t ? void 0 : t.data;\n            }) : null === (s = null == e ? void 0 : e.error) || void 0 === s ? void 0 : s.data), this.request = r, \"error\" in e ? a = e.error : e instanceof Array && (a = e.filter(e => e.error).map(e => e.error)), Array.isArray(a) && a.length > 0 ? this.cause = new n.MultipleErrors(a) : this.cause = a;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              data: this.data,\n              request: this.request\n            });\n          }\n        }\n        t.ResponseError = s, t.InvalidResponseError = class extends s {\n          constructor(e, t) {\n            let r;\n            super(e, void 0, t), this.code = o.ERR_INVALID_RESPONSE, \"error\" in e ? r = e.error : e instanceof Array && (r = e.map(e => e.error)), Array.isArray(r) ? this.cause = new n.MultipleErrors(r) : this.cause = r;\n          }\n        };\n      },\n      4032: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.RpcErrorMessages = t.genericRpcErrorMessageTemplate = void 0;\n        const n = r(7639);\n        t.genericRpcErrorMessageTemplate = \"An Rpc error has occured with a code of *code*\", t.RpcErrorMessages = {\n          [n.ERR_RPC_INVALID_JSON]: {\n            message: \"Parse error\",\n            description: \"Invalid JSON\"\n          },\n          [n.ERR_RPC_INVALID_REQUEST]: {\n            message: \"Invalid request\",\n            description: \"JSON is not a valid request object\\t\"\n          },\n          [n.ERR_RPC_INVALID_METHOD]: {\n            message: \"Method not found\",\n            description: \"Method does not exist\\t\"\n          },\n          [n.ERR_RPC_INVALID_PARAMS]: {\n            message: \"Invalid params\",\n            description: \"Invalid method parameters\"\n          },\n          [n.ERR_RPC_INTERNAL_ERROR]: {\n            message: \"Internal error\",\n            description: \"Internal JSON-RPC error\"\n          },\n          [n.ERR_RPC_INVALID_INPUT]: {\n            message: \"Invalid input\",\n            description: \"Missing or invalid parameters\"\n          },\n          [n.ERR_RPC_MISSING_RESOURCE]: {\n            message: \"Resource not found\",\n            description: \"Requested resource not found\"\n          },\n          [n.ERR_RPC_UNAVAILABLE_RESOURCE]: {\n            message: \"Resource unavailable\",\n            description: \"Requested resource not available\"\n          },\n          [n.ERR_RPC_TRANSACTION_REJECTED]: {\n            message: \"Transaction rejected\",\n            description: \"Transaction creation failed\"\n          },\n          [n.ERR_RPC_UNSUPPORTED_METHOD]: {\n            message: \"Method not supported\",\n            description: \"Method is not implemented\"\n          },\n          [n.ERR_RPC_LIMIT_EXCEEDED]: {\n            message: \"Limit exceeded\",\n            description: \"Request exceeds defined limit\"\n          },\n          [n.ERR_RPC_NOT_SUPPORTED]: {\n            message: \"JSON-RPC version not supported\",\n            description: \"Version of JSON-RPC protocol is not supported\"\n          },\n          [n.JSONRPC_ERR_REJECTED_REQUEST]: {\n            name: \"User Rejected Request\",\n            message: \"The user rejected the request.\"\n          },\n          [n.JSONRPC_ERR_UNAUTHORIZED]: {\n            name: \"Unauthorized\",\n            message: \"The requested method and/or account has not been authorized by the user.\"\n          },\n          [n.JSONRPC_ERR_UNSUPPORTED_METHOD]: {\n            name: \"Unsupported Method\",\n            message: \"The Provider does not support the requested method.\"\n          },\n          [n.JSONRPC_ERR_DISCONNECTED]: {\n            name: \"Disconnected\",\n            message: \"The Provider is disconnected from all chains.\"\n          },\n          [n.JSONRPC_ERR_CHAIN_DISCONNECTED]: {\n            name: \"Chain Disconnected\",\n            message: \"The Provider is not connected to the requested chain.\"\n          },\n          \"0-999\": {\n            name: \"\",\n            message: \"Not used.\"\n          },\n          1e3: {\n            name: \"Normal Closure\",\n            message: \"The connection successfully completed the purpose for which it was created.\"\n          },\n          1001: {\n            name: \"Going Away\",\n            message: \"The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.\"\n          },\n          1002: {\n            name: \"Protocol error\",\n            message: \"The endpoint is terminating the connection due to a protocol error.\"\n          },\n          1003: {\n            name: \"Unsupported Data\",\n            message: \"The connection is being terminated because the endpoint received data of a type it cannot accept. (For example, a text-only endpoint received binary data.)\"\n          },\n          1004: {\n            name: \"Reserved\",\n            message: \"Reserved. A meaning might be defined in the future.\"\n          },\n          1005: {\n            name: \"No Status Rcvd\",\n            message: \"Reserved. Indicates that no status code was provided even though one was expected.\"\n          },\n          1006: {\n            name: \"Abnormal Closure\",\n            message: \"Reserved. Indicates that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected.\"\n          },\n          1007: {\n            name: \"Invalid frame payload data\",\n            message: \"The endpoint is terminating the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message).\"\n          },\n          1008: {\n            name: \"Policy Violation\",\n            message: \"The endpoint is terminating the connection because it received a message that violates its policy. This is a generic status code, used when codes 1003 and 1009 are not suitable.\"\n          },\n          1009: {\n            name: \"Message Too Big\",\n            message: \"The endpoint is terminating the connection because a data frame was received that is too large.\"\n          },\n          1010: {\n            name: \"Mandatory Ext.\",\n            message: \"The client is terminating the connection because it expected the server to negotiate one or more extension, but the server didn't.\"\n          },\n          1011: {\n            name: \"Internal Error\",\n            message: \"The server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.\"\n          },\n          1012: {\n            name: \"Service Restart\",\n            message: \"The server is terminating the connection because it is restarting.\"\n          },\n          1013: {\n            name: \"Try Again Later\",\n            message: \"The server is terminating the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients.\"\n          },\n          1014: {\n            name: \"Bad Gateway\",\n            message: \"The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code.\"\n          },\n          1015: {\n            name: \"TLS handshake\",\n            message: \"Reserved. Indicates that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified).\"\n          },\n          \"1016-2999\": {\n            name: \"\",\n            message: \"For definition by future revisions of the WebSocket Protocol specification, and for definition by extension specifications.\"\n          },\n          \"3000-3999\": {\n            name: \"\",\n            message: \"For use by libraries, frameworks, and applications. These status codes are registered directly with IANA. The interpretation of these codes is undefined by the WebSocket protocol.\"\n          },\n          \"4000-4999\": {\n            name: \"\",\n            message: \"For private use, and thus can't be registered. Such codes can be used by prior agreements between WebSocket applications. The interpretation of these codes is undefined by the WebSocket protocol.\"\n          }\n        };\n      },\n      655: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.rpcErrorsMap = t.LimitExceededError = t.TransactionRejectedError = t.VersionNotSupportedError = t.ResourcesNotFoundError = t.ResourceUnavailableError = t.MethodNotSupported = t.InvalidInputError = t.InternalError = t.InvalidParamsError = t.MethodNotFoundError = t.InvalidRequestError = t.ParseError = t.EIP1193ProviderRpcError = t.RpcError = void 0;\n        const n = r(3685),\n          o = r(7639),\n          i = r(4032);\n        class s extends n.BaseWeb3Error {\n          constructor(e, t) {\n            super(null != t ? t : i.genericRpcErrorMessageTemplate.replace(\"*code*\", e.error.code.toString())), this.code = e.error.code, this.id = e.id, this.jsonrpc = e.jsonrpc, this.jsonRpcError = e.error;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              error: this.jsonRpcError,\n              id: this.id,\n              jsonRpc: this.jsonrpc\n            });\n          }\n        }\n        t.RpcError = s;\n        class a extends n.BaseWeb3Error {\n          constructor(e, t) {\n            var r, n, o, s;\n            if (e) {\n              if (null === (r = i.RpcErrorMessages[e]) || void 0 === r ? void 0 : r.message) super(i.RpcErrorMessages[e].message);else {\n                const t = Object.keys(i.RpcErrorMessages).find(t => \"string\" == typeof t && e >= parseInt(t.split(\"-\")[0], 10) && e <= parseInt(t.split(\"-\")[1], 10));\n                super(null !== (o = null === (n = i.RpcErrorMessages[null != t ? t : \"\"]) || void 0 === n ? void 0 : n.message) && void 0 !== o ? o : i.genericRpcErrorMessageTemplate.replace(\"*code*\", null !== (s = null == e ? void 0 : e.toString()) && void 0 !== s ? s : '\"\"'));\n              }\n            } else super();\n            this.code = e, this.data = t;\n          }\n        }\n        t.EIP1193ProviderRpcError = a;\n        class c extends s {\n          constructor(e) {\n            super(e, i.RpcErrorMessages[o.ERR_RPC_INVALID_JSON].message), this.code = o.ERR_RPC_INVALID_JSON;\n          }\n        }\n        t.ParseError = c;\n        class u extends s {\n          constructor(e) {\n            super(e, i.RpcErrorMessages[o.ERR_RPC_INVALID_REQUEST].message), this.code = o.ERR_RPC_INVALID_REQUEST;\n          }\n        }\n        t.InvalidRequestError = u;\n        class d extends s {\n          constructor(e) {\n            super(e, i.RpcErrorMessages[o.ERR_RPC_INVALID_METHOD].message), this.code = o.ERR_RPC_INVALID_METHOD;\n          }\n        }\n        t.MethodNotFoundError = d;\n        class l extends s {\n          constructor(e) {\n            super(e, i.RpcErrorMessages[o.ERR_RPC_INVALID_PARAMS].message), this.code = o.ERR_RPC_INVALID_PARAMS;\n          }\n        }\n        t.InvalidParamsError = l;\n        class h extends s {\n          constructor(e) {\n            super(e, i.RpcErrorMessages[o.ERR_RPC_INTERNAL_ERROR].message), this.code = o.ERR_RPC_INTERNAL_ERROR;\n          }\n        }\n        t.InternalError = h;\n        class f extends s {\n          constructor(e) {\n            super(e, i.RpcErrorMessages[o.ERR_RPC_INVALID_INPUT].message), this.code = o.ERR_RPC_INVALID_INPUT;\n          }\n        }\n        t.InvalidInputError = f;\n        class p extends s {\n          constructor(e) {\n            super(e, i.RpcErrorMessages[o.ERR_RPC_UNSUPPORTED_METHOD].message), this.code = o.ERR_RPC_UNSUPPORTED_METHOD;\n          }\n        }\n        t.MethodNotSupported = p;\n        class m extends s {\n          constructor(e) {\n            super(e, i.RpcErrorMessages[o.ERR_RPC_UNAVAILABLE_RESOURCE].message), this.code = o.ERR_RPC_UNAVAILABLE_RESOURCE;\n          }\n        }\n        t.ResourceUnavailableError = m;\n        class g extends s {\n          constructor(e) {\n            super(e, i.RpcErrorMessages[o.ERR_RPC_MISSING_RESOURCE].message), this.code = o.ERR_RPC_MISSING_RESOURCE;\n          }\n        }\n        t.ResourcesNotFoundError = g;\n        class y extends s {\n          constructor(e) {\n            super(e, i.RpcErrorMessages[o.ERR_RPC_NOT_SUPPORTED].message), this.code = o.ERR_RPC_NOT_SUPPORTED;\n          }\n        }\n        t.VersionNotSupportedError = y;\n        class v extends s {\n          constructor(e) {\n            super(e, i.RpcErrorMessages[o.ERR_RPC_TRANSACTION_REJECTED].message), this.code = o.ERR_RPC_TRANSACTION_REJECTED;\n          }\n        }\n        t.TransactionRejectedError = v;\n        class b extends s {\n          constructor(e) {\n            super(e, i.RpcErrorMessages[o.ERR_RPC_LIMIT_EXCEEDED].message), this.code = o.ERR_RPC_LIMIT_EXCEEDED;\n          }\n        }\n        t.LimitExceededError = b, t.rpcErrorsMap = new Map(), t.rpcErrorsMap.set(o.ERR_RPC_INVALID_JSON, {\n          error: c\n        }), t.rpcErrorsMap.set(o.ERR_RPC_INVALID_REQUEST, {\n          error: u\n        }), t.rpcErrorsMap.set(o.ERR_RPC_INVALID_METHOD, {\n          error: d\n        }), t.rpcErrorsMap.set(o.ERR_RPC_INVALID_PARAMS, {\n          error: l\n        }), t.rpcErrorsMap.set(o.ERR_RPC_INTERNAL_ERROR, {\n          error: h\n        }), t.rpcErrorsMap.set(o.ERR_RPC_INVALID_INPUT, {\n          error: f\n        }), t.rpcErrorsMap.set(o.ERR_RPC_UNSUPPORTED_METHOD, {\n          error: p\n        }), t.rpcErrorsMap.set(o.ERR_RPC_UNAVAILABLE_RESOURCE, {\n          error: m\n        }), t.rpcErrorsMap.set(o.ERR_RPC_TRANSACTION_REJECTED, {\n          error: v\n        }), t.rpcErrorsMap.set(o.ERR_RPC_MISSING_RESOURCE, {\n          error: g\n        }), t.rpcErrorsMap.set(o.ERR_RPC_NOT_SUPPORTED, {\n          error: y\n        }), t.rpcErrorsMap.set(o.ERR_RPC_LIMIT_EXCEEDED, {\n          error: b\n        });\n      },\n      1066: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SchemaFormatError = void 0;\n        const n = r(7639),\n          o = r(3685);\n        class i extends o.BaseWeb3Error {\n          constructor(e) {\n            super(`Format for the type ${e} is unsupported`), this.type = e, this.code = n.ERR_SCHEMA_FORMAT;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              type: this.type\n            });\n          }\n        }\n        t.SchemaFormatError = i;\n      },\n      1075: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SignatureError = void 0;\n        const n = r(7639),\n          o = r(3685);\n        class i extends o.InvalidValueError {\n          constructor() {\n            super(...arguments), this.code = n.ERR_SIGNATURE_FAILED;\n          }\n        }\n        t.SignatureError = i;\n      },\n      8450: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.InvalidPropertiesForTransactionTypeError = t.LocalWalletNotAvailableError = t.TransactionSigningError = t.TransactionReceiptMissingBlockNumberError = t.TransactionMissingReceiptOrBlockHashError = t.TransactionBlockTimeoutError = t.TransactionPollingTimeoutError = t.TransactionSendTimeoutError = t.TransactionDataAndInputError = t.UnsupportedTransactionTypeError = t.Eip1559NotSupportedError = t.UnableToPopulateNonceError = t.InvalidNonceOrChainIdError = t.InvalidTransactionObjectError = t.UnsupportedFeeMarketError = t.Eip1559GasPriceError = t.InvalidMaxPriorityFeePerGasOrMaxFeePerGas = t.InvalidGasOrGasPrice = t.TransactionGasMismatchError = t.TransactionGasMismatchInnerError = t.MissingGasError = t.MissingGasInnerError = t.MissingChainOrHardforkError = t.CommonOrChainAndHardforkError = t.HardforkMismatchError = t.ChainMismatchError = t.ChainIdMismatchError = t.MissingCustomChainIdError = t.MissingCustomChainError = t.InvalidTransactionCall = t.InvalidTransactionWithReceiver = t.InvalidTransactionWithSender = t.TransactionNotFound = t.UndefinedRawTransactionError = t.TransactionOutOfGasError = t.TransactionRevertedWithoutReasonError = t.ContractCodeNotStoredError = t.NoContractAddressFoundError = t.TransactionRevertWithCustomError = t.TransactionRevertInstructionError = t.RevertInstructionError = t.TransactionError = void 0;\n        const n = r(7639),\n          o = r(3685);\n        class i extends o.BaseWeb3Error {\n          constructor(e, t) {\n            super(e), this.receipt = t, this.code = n.ERR_TX;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              receipt: this.receipt\n            });\n          }\n        }\n        t.TransactionError = i;\n        class s extends o.BaseWeb3Error {\n          constructor(e, t) {\n            super(`Your request got reverted with the following reason string: ${e}`), this.reason = e, this.signature = t, this.code = n.ERR_TX_REVERT_INSTRUCTION;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              reason: this.reason,\n              signature: this.signature\n            });\n          }\n        }\n        t.RevertInstructionError = s;\n        class a extends o.BaseWeb3Error {\n          constructor(e, t, r, i) {\n            super(\"Transaction has been reverted by the EVM\" + (void 0 === r ? \"\" : `:\\n ${o.BaseWeb3Error.convertToString(r)}`)), this.reason = e, this.signature = t, this.receipt = r, this.data = i, this.code = n.ERR_TX_REVERT_TRANSACTION;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              reason: this.reason,\n              signature: this.signature,\n              receipt: this.receipt,\n              data: this.data\n            });\n          }\n        }\n        t.TransactionRevertInstructionError = a, t.TransactionRevertWithCustomError = class extends a {\n          constructor(e, t, r, o, i, s, a) {\n            super(e), this.reason = e, this.customErrorName = t, this.customErrorDecodedSignature = r, this.customErrorArguments = o, this.signature = i, this.receipt = s, this.data = a, this.code = n.ERR_TX_REVERT_TRANSACTION_CUSTOM_ERROR;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              reason: this.reason,\n              customErrorName: this.customErrorName,\n              customErrorDecodedSignature: this.customErrorDecodedSignature,\n              customErrorArguments: this.customErrorArguments,\n              signature: this.signature,\n              receipt: this.receipt,\n              data: this.data\n            });\n          }\n        }, t.NoContractAddressFoundError = class extends i {\n          constructor(e) {\n            super(\"The transaction receipt didn't contain a contract address.\", e), this.code = n.ERR_TX_NO_CONTRACT_ADDRESS;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              receipt: this.receipt\n            });\n          }\n        }, t.ContractCodeNotStoredError = class extends i {\n          constructor(e) {\n            super(\"The contract code couldn't be stored, please check your gas limit.\", e), this.code = n.ERR_TX_CONTRACT_NOT_STORED;\n          }\n        }, t.TransactionRevertedWithoutReasonError = class extends i {\n          constructor(e) {\n            super(\"Transaction has been reverted by the EVM\" + (void 0 === e ? \"\" : `:\\n ${o.BaseWeb3Error.convertToString(e)}`), e), this.code = n.ERR_TX_REVERT_WITHOUT_REASON;\n          }\n        }, t.TransactionOutOfGasError = class extends i {\n          constructor(e) {\n            super(`Transaction ran out of gas. Please provide more gas:\\n ${JSON.stringify(e, void 0, 2)}`, e), this.code = n.ERR_TX_OUT_OF_GAS;\n          }\n        }, t.UndefinedRawTransactionError = class extends i {\n          constructor() {\n            super(\"Raw transaction undefined\"), this.code = n.ERR_RAW_TX_UNDEFINED;\n          }\n        }, t.TransactionNotFound = class extends i {\n          constructor() {\n            super(\"Transaction not found\"), this.code = n.ERR_TX_NOT_FOUND;\n          }\n        };\n        class c extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"invalid transaction with invalid sender\"), this.code = n.ERR_TX_INVALID_SENDER;\n          }\n        }\n        t.InvalidTransactionWithSender = c;\n        class u extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"invalid transaction with invalid receiver\"), this.code = n.ERR_TX_INVALID_RECEIVER;\n          }\n        }\n        t.InvalidTransactionWithReceiver = u;\n        class d extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"invalid transaction call\"), this.code = n.ERR_TX_INVALID_CALL;\n          }\n        }\n        t.InvalidTransactionCall = d;\n        class l extends o.InvalidValueError {\n          constructor() {\n            super(\"MissingCustomChainError\", \"If tx.common is provided it must have tx.common.customChain\"), this.code = n.ERR_TX_MISSING_CUSTOM_CHAIN;\n          }\n        }\n        t.MissingCustomChainError = l;\n        class h extends o.InvalidValueError {\n          constructor() {\n            super(\"MissingCustomChainIdError\", \"If tx.common is provided it must have tx.common.customChain and tx.common.customChain.chainId\"), this.code = n.ERR_TX_MISSING_CUSTOM_CHAIN_ID;\n          }\n        }\n        t.MissingCustomChainIdError = h;\n        class f extends o.InvalidValueError {\n          constructor(e) {\n            super(JSON.stringify(e), \"Chain Id doesnt match in tx.chainId tx.common.customChain.chainId\"), this.code = n.ERR_TX_CHAIN_ID_MISMATCH;\n          }\n        }\n        t.ChainIdMismatchError = f;\n        class p extends o.InvalidValueError {\n          constructor(e) {\n            super(JSON.stringify(e), \"Chain doesnt match in tx.chain tx.common.basechain\"), this.code = n.ERR_TX_CHAIN_MISMATCH;\n          }\n        }\n        t.ChainMismatchError = p;\n        class m extends o.InvalidValueError {\n          constructor(e) {\n            super(JSON.stringify(e), \"hardfork doesnt match in tx.hardfork tx.common.hardfork\"), this.code = n.ERR_TX_HARDFORK_MISMATCH;\n          }\n        }\n        t.HardforkMismatchError = m;\n        class g extends o.InvalidValueError {\n          constructor() {\n            super(\"CommonOrChainAndHardforkError\", \"Please provide the common object or the chain and hardfork property but not all together.\"), this.code = n.ERR_TX_INVALID_CHAIN_INFO;\n          }\n        }\n        t.CommonOrChainAndHardforkError = g;\n        class y extends o.InvalidValueError {\n          constructor(e) {\n            var t, r;\n            super(\"MissingChainOrHardforkError\", `When specifying chain and hardfork, both values must be defined. Received \"chain\": ${null !== (t = e.chain) && void 0 !== t ? t : \"undefined\"}, \"hardfork\": ${null !== (r = e.hardfork) && void 0 !== r ? r : \"undefined\"}`), this.code = n.ERR_TX_MISSING_CHAIN_INFO;\n          }\n        }\n        t.MissingChainOrHardforkError = y;\n        class v extends o.BaseWeb3Error {\n          constructor() {\n            super('Missing properties in transaction, either define \"gas\" and \"gasPrice\" for type 0 transactions or \"gas\", \"maxPriorityFeePerGas\" and \"maxFeePerGas\" for type 2 transactions'), this.code = n.ERR_TX_MISSING_GAS_INNER_ERROR;\n          }\n        }\n        t.MissingGasInnerError = v;\n        class b extends o.InvalidValueError {\n          constructor(e) {\n            var t, r, o, i;\n            super(`gas: ${null !== (t = e.gas) && void 0 !== t ? t : \"undefined\"}, gasPrice: ${null !== (r = e.gasPrice) && void 0 !== r ? r : \"undefined\"}, maxPriorityFeePerGas: ${null !== (o = e.maxPriorityFeePerGas) && void 0 !== o ? o : \"undefined\"}, maxFeePerGas: ${null !== (i = e.maxFeePerGas) && void 0 !== i ? i : \"undefined\"}`, '\"gas\" is missing'), this.code = n.ERR_TX_MISSING_GAS, this.cause = new v();\n          }\n        }\n        t.MissingGasError = b;\n        class E extends o.BaseWeb3Error {\n          constructor() {\n            super('Missing properties in transaction, either define \"gas\" and \"gasPrice\" for type 0 transactions or \"gas\", \"maxPriorityFeePerGas\" and \"maxFeePerGas\" for type 2 transactions, not both'), this.code = n.ERR_TX_GAS_MISMATCH_INNER_ERROR;\n          }\n        }\n        t.TransactionGasMismatchInnerError = E;\n        class _ extends o.InvalidValueError {\n          constructor(e) {\n            var t, r, o, i;\n            super(`gas: ${null !== (t = e.gas) && void 0 !== t ? t : \"undefined\"}, gasPrice: ${null !== (r = e.gasPrice) && void 0 !== r ? r : \"undefined\"}, maxPriorityFeePerGas: ${null !== (o = e.maxPriorityFeePerGas) && void 0 !== o ? o : \"undefined\"}, maxFeePerGas: ${null !== (i = e.maxFeePerGas) && void 0 !== i ? i : \"undefined\"}`, \"transaction must specify legacy or fee market gas properties, not both\"), this.code = n.ERR_TX_GAS_MISMATCH, this.cause = new E();\n          }\n        }\n        t.TransactionGasMismatchError = _;\n        class A extends o.InvalidValueError {\n          constructor(e) {\n            var t, r;\n            super(`gas: ${null !== (t = e.gas) && void 0 !== t ? t : \"undefined\"}, gasPrice: ${null !== (r = e.gasPrice) && void 0 !== r ? r : \"undefined\"}`, \"Gas or gasPrice is lower than 0\"), this.code = n.ERR_TX_INVALID_LEGACY_GAS;\n          }\n        }\n        t.InvalidGasOrGasPrice = A;\n        class T extends o.InvalidValueError {\n          constructor(e) {\n            var t, r;\n            super(`maxPriorityFeePerGas: ${null !== (t = e.maxPriorityFeePerGas) && void 0 !== t ? t : \"undefined\"}, maxFeePerGas: ${null !== (r = e.maxFeePerGas) && void 0 !== r ? r : \"undefined\"}`, \"maxPriorityFeePerGas or maxFeePerGas is lower than 0\"), this.code = n.ERR_TX_INVALID_FEE_MARKET_GAS;\n          }\n        }\n        t.InvalidMaxPriorityFeePerGasOrMaxFeePerGas = T;\n        class w extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"eip-1559 transactions don't support gasPrice\"), this.code = n.ERR_TX_INVALID_FEE_MARKET_GAS_PRICE;\n          }\n        }\n        t.Eip1559GasPriceError = w;\n        class I extends o.InvalidValueError {\n          constructor(e) {\n            var t, r;\n            super(`maxPriorityFeePerGas: ${null !== (t = e.maxPriorityFeePerGas) && void 0 !== t ? t : \"undefined\"}, maxFeePerGas: ${null !== (r = e.maxFeePerGas) && void 0 !== r ? r : \"undefined\"}`, \"pre-eip-1559 transaction don't support maxFeePerGas/maxPriorityFeePerGas\"), this.code = n.ERR_TX_INVALID_LEGACY_FEE_MARKET;\n          }\n        }\n        t.UnsupportedFeeMarketError = I;\n        class R extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"invalid transaction object\"), this.code = n.ERR_TX_INVALID_OBJECT;\n          }\n        }\n        t.InvalidTransactionObjectError = R;\n        class P extends o.InvalidValueError {\n          constructor(e) {\n            var t, r;\n            super(`nonce: ${null !== (t = e.nonce) && void 0 !== t ? t : \"undefined\"}, chainId: ${null !== (r = e.chainId) && void 0 !== r ? r : \"undefined\"}`, \"Nonce or chainId is lower than 0\"), this.code = n.ERR_TX_INVALID_NONCE_OR_CHAIN_ID;\n          }\n        }\n        t.InvalidNonceOrChainIdError = P;\n        class x extends o.InvalidValueError {\n          constructor() {\n            super(\"UnableToPopulateNonceError\", \"unable to populate nonce, no from address available\"), this.code = n.ERR_TX_UNABLE_TO_POPULATE_NONCE;\n          }\n        }\n        t.UnableToPopulateNonceError = x;\n        class O extends o.InvalidValueError {\n          constructor() {\n            super(\"Eip1559NotSupportedError\", \"Network doesn't support eip-1559\"), this.code = n.ERR_TX_UNSUPPORTED_EIP_1559;\n          }\n        }\n        t.Eip1559NotSupportedError = O;\n        class S extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"unsupported transaction type\"), this.code = n.ERR_TX_UNSUPPORTED_TYPE;\n          }\n        }\n        t.UnsupportedTransactionTypeError = S;\n        class C extends o.InvalidValueError {\n          constructor(e) {\n            var t, r;\n            super(`data: ${null !== (t = e.data) && void 0 !== t ? t : \"undefined\"}, input: ${null !== (r = e.input) && void 0 !== r ? r : \"undefined\"}`, 'You can\\'t have \"data\" and \"input\" as properties of transactions at the same time, please use either \"data\" or \"input\" instead.'), this.code = n.ERR_TX_DATA_AND_INPUT;\n          }\n        }\n        t.TransactionDataAndInputError = C;\n        class B extends o.BaseWeb3Error {\n          constructor(e) {\n            super(`The connected Ethereum Node did not respond within ${e.numberOfSeconds} seconds, please make sure your transaction was properly sent and you are connected to a healthy Node. Be aware that transaction might still be pending or mined!\\n\\tTransaction Hash: ${e.transactionHash ? e.transactionHash.toString() : \"not available\"}`), this.code = n.ERR_TX_SEND_TIMEOUT;\n          }\n        }\n        function k(e) {\n          return `Please make sure your transaction was properly sent and there are no previous pending transaction for the same account. However, be aware that it might still be mined!\\n\\tTransaction Hash: ${e ? e.toString() : \"not available\"}`;\n        }\n        t.TransactionSendTimeoutError = B;\n        class N extends o.BaseWeb3Error {\n          constructor(e) {\n            super(`Transaction was not mined within ${e.numberOfSeconds} seconds. ${k(e.transactionHash)}`), this.code = n.ERR_TX_POLLING_TIMEOUT;\n          }\n        }\n        t.TransactionPollingTimeoutError = N;\n        class M extends o.BaseWeb3Error {\n          constructor(e) {\n            super(`Transaction started at ${e.starterBlockNumber} but was not mined within ${e.numberOfBlocks} blocks. ${k(e.transactionHash)}`), this.code = n.ERR_TX_BLOCK_TIMEOUT;\n          }\n        }\n        t.TransactionBlockTimeoutError = M;\n        class L extends o.InvalidValueError {\n          constructor(e) {\n            var t, r;\n            super(`receipt: ${JSON.stringify(e.receipt)}, blockHash: ${null === (t = e.blockHash) || void 0 === t ? void 0 : t.toString()}, transactionHash: ${null === (r = e.transactionHash) || void 0 === r ? void 0 : r.toString()}`, \"Receipt missing or blockHash null\"), this.code = n.ERR_TX_RECEIPT_MISSING_OR_BLOCKHASH_NULL;\n          }\n        }\n        t.TransactionMissingReceiptOrBlockHashError = L;\n        class D extends o.InvalidValueError {\n          constructor(e) {\n            super(`receipt: ${JSON.stringify(e.receipt)}`, \"Receipt missing block number\"), this.code = n.ERR_TX_RECEIPT_MISSING_BLOCK_NUMBER;\n          }\n        }\n        t.TransactionReceiptMissingBlockNumberError = D;\n        class F extends o.BaseWeb3Error {\n          constructor(e) {\n            super(`Invalid signature. \"${e}\"`), this.code = n.ERR_TX_SIGNING;\n          }\n        }\n        t.TransactionSigningError = F;\n        class H extends o.InvalidValueError {\n          constructor() {\n            super(\"LocalWalletNotAvailableError\", \"Attempted to index account in local wallet, but no wallet is available\"), this.code = n.ERR_TX_LOCAL_WALLET_NOT_AVAILABLE;\n          }\n        }\n        t.LocalWalletNotAvailableError = H;\n        class j extends o.BaseWeb3Error {\n          constructor(e, t) {\n            const r = [];\n            e.forEach(e => r.push(e.keyword)), super(`The following properties are invalid for the transaction type ${t}: ${r.join(\", \")}`), this.code = n.ERR_TX_INVALID_PROPERTIES_FOR_TYPE;\n          }\n        }\n        t.InvalidPropertiesForTransactionTypeError = j;\n      },\n      4618: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.InvalidTypeAbiInputError = t.InvalidBlockError = t.InvalidLargeValueError = t.InvalidSizeError = t.InvalidUnsignedIntegerError = t.InvalidBooleanError = t.InvalidTypeError = t.NibbleWidthError = t.HexProcessingError = t.InvalidIntegerError = t.InvalidUnitError = t.InvalidStringError = t.InvalidAddressError = t.InvalidNumberError = t.InvalidBytesError = void 0;\n        const n = r(7639),\n          o = r(3685);\n        class i extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"can not parse as byte data\"), this.code = n.ERR_INVALID_BYTES;\n          }\n        }\n        t.InvalidBytesError = i;\n        class s extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"can not parse as number data\"), this.code = n.ERR_INVALID_NUMBER;\n          }\n        }\n        t.InvalidNumberError = s;\n        class a extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"invalid ethereum address\"), this.code = n.ERR_INVALID_ADDRESS;\n          }\n        }\n        t.InvalidAddressError = a;\n        class c extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"not a valid string\"), this.code = n.ERR_INVALID_STRING;\n          }\n        }\n        t.InvalidStringError = c;\n        class u extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"invalid unit\"), this.code = n.ERR_INVALID_UNIT;\n          }\n        }\n        t.InvalidUnitError = u;\n        class d extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"not a valid unit. Must be a positive integer\"), this.code = n.ERR_INVALID_INTEGER;\n          }\n        }\n        t.InvalidIntegerError = d;\n        class l extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"can not be converted to hex\"), this.code = n.ERR_INVALID_HEX;\n          }\n        }\n        t.HexProcessingError = l;\n        class h extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"value greater than the nibble width\"), this.code = n.ERR_INVALID_NIBBLE_WIDTH;\n          }\n        }\n        t.NibbleWidthError = h;\n        class f extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"invalid type, type not supported\"), this.code = n.ERR_INVALID_TYPE;\n          }\n        }\n        t.InvalidTypeError = f;\n        class p extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"not a valid boolean.\"), this.code = n.ERR_INVALID_BOOLEAN;\n          }\n        }\n        t.InvalidBooleanError = p;\n        class m extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"not a valid unsigned integer.\"), this.code = n.ERR_INVALID_UNSIGNED_INTEGER;\n          }\n        }\n        t.InvalidUnsignedIntegerError = m;\n        class g extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"invalid size given.\"), this.code = n.ERR_INVALID_SIZE;\n          }\n        }\n        t.InvalidSizeError = g;\n        class y extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"value is larger than size.\"), this.code = n.ERR_INVALID_LARGE_VALUE;\n          }\n        }\n        t.InvalidLargeValueError = y;\n        class v extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"invalid string given\"), this.code = n.ERR_INVALID_BLOCK;\n          }\n        }\n        t.InvalidBlockError = v;\n        class b extends o.InvalidValueError {\n          constructor(e) {\n            super(e, \"components found but type is not tuple\"), this.code = n.ERR_INVALID_TYPE_ABI;\n          }\n        }\n        t.InvalidTypeAbiInputError = b;\n      },\n      5071: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), o(r(7639), t), o(r(3685), t), o(r(8105), t), o(r(3789), t), o(r(510), t), o(r(1591), t), o(r(7297), t), o(r(7108), t), o(r(1075), t), o(r(8450), t), o(r(4618), t), o(r(9491), t), o(r(3628), t), o(r(655), t), o(r(4032), t), o(r(1066), t);\n      },\n      3685: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.InvalidValueError = t.MultipleErrors = t.BaseWeb3Error = void 0;\n        const n = r(7639);\n        class o extends Error {\n          constructor(e, t) {\n            super(e), Array.isArray(t) ? this.cause = new i(t) : this.cause = t, this.name = this.constructor.name, \"function\" == typeof Error.captureStackTrace ? Error.captureStackTrace(new.target.constructor) : this.stack = new Error().stack;\n          }\n          get innerError() {\n            return this.cause instanceof i ? this.cause.errors : this.cause;\n          }\n          set innerError(e) {\n            Array.isArray(e) ? this.cause = new i(e) : this.cause = e;\n          }\n          static convertToString(e, t = !1) {\n            if (null == e) return \"undefined\";\n            const r = JSON.stringify(e, (e, t) => \"bigint\" == typeof t ? t.toString() : t);\n            return t && [\"bigint\", \"string\"].includes(typeof e) ? r.replace(/['\\\\\"]+/g, \"\") : r;\n          }\n          toJSON() {\n            return {\n              name: this.name,\n              code: this.code,\n              message: this.message,\n              cause: this.cause,\n              innerError: this.cause\n            };\n          }\n        }\n        t.BaseWeb3Error = o;\n        class i extends o {\n          constructor(e) {\n            super(`Multiple errors occurred: [${e.map(e => e.message).join(\"], [\")}]`), this.code = n.ERR_MULTIPLE_ERRORS, this.errors = e;\n          }\n        }\n        t.MultipleErrors = i, t.InvalidValueError = class extends o {\n          constructor(e, t) {\n            super(`Invalid value given \"${o.convertToString(e, !0)}\". Error: ${t}.`), this.name = this.constructor.name;\n          }\n        };\n      },\n      9722: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.encodeErrorSignature = void 0;\n        const n = r(9634),\n          o = r(5071),\n          i = r(1583);\n        t.encodeErrorSignature = e => {\n          if (\"string\" != typeof e && !(0, i.isAbiErrorFragment)(e)) throw new o.AbiError(\"Invalid parameter value in encodeErrorSignature\");\n          let t;\n          return t = !e || \"function\" != typeof e && \"object\" != typeof e ? e : (0, i.jsonInterfaceMethodToString)(e), (0, n.sha3Raw)(t);\n        };\n      },\n      5893: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.encodeEventSignature = void 0;\n        const n = r(9634),\n          o = r(5071),\n          i = r(1583);\n        t.encodeEventSignature = e => {\n          if (\"string\" != typeof e && !(0, i.isAbiEventFragment)(e)) throw new o.AbiError(\"Invalid parameter value in encodeEventSignature\");\n          let t;\n          return t = !e || \"function\" != typeof e && \"object\" != typeof e ? e : (0, i.jsonInterfaceMethodToString)(e), (0, n.sha3Raw)(t);\n        };\n      },\n      3249: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.encodeFunctionCall = t.encodeFunctionSignature = void 0;\n        const n = r(5071),\n          o = r(9634),\n          i = r(1583),\n          s = r(4566);\n        t.encodeFunctionSignature = e => {\n          if (\"string\" != typeof e && !(0, i.isAbiFunctionFragment)(e)) throw new n.AbiError(\"Invalid parameter value in encodeFunctionSignature\");\n          let t;\n          return t = !e || \"function\" != typeof e && \"object\" != typeof e ? e : (0, i.jsonInterfaceMethodToString)(e), (0, o.sha3Raw)(t).slice(0, 10);\n        }, t.encodeFunctionCall = (e, r) => {\n          var o;\n          if (!(0, i.isAbiFunctionFragment)(e)) throw new n.AbiError(\"Invalid parameter value in encodeFunctionCall\");\n          return `${(0, t.encodeFunctionSignature)(e)}${(0, s.encodeParameters)(null !== (o = e.inputs) && void 0 !== o ? o : [], null != r ? r : []).replace(\"0x\", \"\")}`;\n        };\n      },\n      734: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeLog = void 0;\n        const n = r(4566),\n          o = [\"bool\", \"string\", \"int\", \"uint\", \"address\", \"fixed\", \"ufixed\"];\n        t.decodeLog = (e, t, r) => {\n          const i = Array.isArray(r) ? r : [r],\n            s = {},\n            a = {};\n          for (const [t, r] of e.entries()) r.indexed ? s[t] = r : a[t] = r;\n          const c = t ? (0, n.decodeParametersWith)(Object.values(a), t, !0) : {\n              __length__: 0\n            },\n            u = i.length - Object.keys(s).length,\n            d = Object.values(s).map((e, t) => {\n              return o.some(t => e.type.startsWith(t)) ? (r = e.type, s = i[t + u], \"string\" === r ? s : (0, n.decodeParameter)(r, s)) : i[t + u];\n              var r, s;\n            }),\n            l = {\n              __length__: 0\n            };\n          let h = 0,\n            f = 0;\n          for (const [t, r] of e.entries()) l[t] = \"string\" === r.type ? \"\" : void 0, s[t] && (l[t] = d[h], h += 1), a[t] && (l[t] = c[String(f)], f += 1), r.name && (l[r.name] = l[t]), l.__length__ += 1;\n          return l;\n        };\n      },\n      4566: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeParameter = t.decodeParameters = t.decodeParametersWith = t.encodeParameter = t.inferTypesAndEncodeParameters = t.encodeParameters = void 0;\n        const n = r(5071),\n          o = r(6729),\n          i = r(4581);\n        var s = r(4581);\n        Object.defineProperty(t, \"encodeParameters\", {\n          enumerable: !0,\n          get: function () {\n            return s.encodeParameters;\n          }\n        }), Object.defineProperty(t, \"inferTypesAndEncodeParameters\", {\n          enumerable: !0,\n          get: function () {\n            return s.inferTypesAndEncodeParameters;\n          }\n        }), t.encodeParameter = (e, t) => (0, i.encodeParameters)([e], [t]), t.decodeParametersWith = (e, t, r) => {\n          try {\n            if (e.length > 0 && (!t || \"0x\" === t || \"0X\" === t)) throw new n.AbiError(\"Returned values aren't valid, did it run Out of Gas? You might also see this error if you are not using the correct ABI for the contract you are retrieving data from, requesting data from a block number that does not exist, or querying a node which is not fully synced.\");\n            return (0, o.decodeParameters)(e, `0x${t.replace(/0x/i, \"\")}`, r);\n          } catch (e) {\n            throw new n.AbiError(`Parameter decoding error: ${e.message}`, {\n              internalErr: e\n            });\n          }\n        }, t.decodeParameters = (e, r) => (0, t.decodeParametersWith)(e, r, !1), t.decodeParameter = (e, r) => (0, t.decodeParameters)([e], r)[0];\n      },\n      1691: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeAddress = t.encodeAddress = void 0;\n        const n = r(5071),\n          o = r(9634),\n          i = r(7345),\n          s = r(3852),\n          a = s.WORD_SIZE - 20;\n        t.encodeAddress = function (e, t) {\n          if (\"string\" != typeof t) throw new n.AbiError(\"address type expects string as input type\", {\n            value: t,\n            name: e.name,\n            type: e.type\n          });\n          let r = t.toLowerCase();\n          if (r.startsWith(\"0x\") || (r = `0x${r}`), !(0, i.isAddress)(r)) throw new n.AbiError(\"provided input is not valid address\", {\n            value: t,\n            name: e.name,\n            type: e.type\n          });\n          const o = i.utils.hexToUint8Array(r),\n            c = (0, s.alloc)(s.WORD_SIZE);\n          return c.set(o, a), {\n            dynamic: !1,\n            encoded: c\n          };\n        }, t.decodeAddress = function (e, t) {\n          const r = t.subarray(a, s.WORD_SIZE);\n          if (20 !== r.length) throw new n.AbiError(\"Invalid decoding input, not enough bytes to decode address\", {\n            bytes: t\n          });\n          const c = i.utils.uint8ArrayToHexString(r);\n          return {\n            result: (0, o.toChecksumAddress)(c),\n            encoded: t.subarray(s.WORD_SIZE),\n            consumed: s.WORD_SIZE\n          };\n        };\n      },\n      7064: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeArray = t.encodeArray = void 0;\n        const n = r(5071),\n          o = r(9634),\n          i = r(5555),\n          s = r(3852),\n          a = r(8809),\n          c = r(5433);\n        t.encodeArray = function (e, t) {\n          if (!Array.isArray(t)) throw new n.AbiError(\"Expected value to be array\", {\n            abi: e,\n            values: t\n          });\n          const {\n              size: r,\n              param: a\n            } = (0, s.extractArrayType)(e),\n            u = t.map(e => (0, i.encodeParamFromAbiParameter)(a, e)),\n            d = -1 === r,\n            l = u.length > 0 && u[0].dynamic;\n          if (!d && t.length !== r) throw new n.AbiError(\"Given arguments count doesn't match array length\", {\n            arrayLength: r,\n            argumentsLength: t.length\n          });\n          if (d || l) {\n            const e = (0, c.encodeDynamicParams)(u);\n            if (d) {\n              const t = (0, i.encodeNumber)({\n                type: \"uint256\",\n                name: \"\"\n              }, u.length).encoded;\n              return {\n                dynamic: !0,\n                encoded: u.length > 0 ? (0, o.uint8ArrayConcat)(t, e) : t\n              };\n            }\n            return {\n              dynamic: !0,\n              encoded: e\n            };\n          }\n          return {\n            dynamic: !1,\n            encoded: (0, o.uint8ArrayConcat)(...u.map(e => e.encoded))\n          };\n        }, t.decodeArray = function (e, t) {\n          let {\n              size: r,\n              param: n\n            } = (0, s.extractArrayType)(e),\n            o = 0;\n          const c = [];\n          let u = t;\n          if (-1 === r) {\n            const e = (0, a.decodeNumber)({\n              type: \"uint32\",\n              name: \"\"\n            }, t);\n            r = Number(e.result), o = e.consumed, u = e.encoded;\n          }\n          if ((0, s.isDynamic)(n)) {\n            for (let e = 0; e < r; e += 1) {\n              const t = (0, a.decodeNumber)({\n                type: \"uint32\",\n                name: \"\"\n              }, u.subarray(e * s.WORD_SIZE));\n              o += t.consumed;\n              const r = (0, i.decodeParamFromAbiParameter)(n, u.subarray(Number(t.result)));\n              o += r.consumed, c.push(r.result);\n            }\n            return {\n              result: c,\n              encoded: u.subarray(o),\n              consumed: o\n            };\n          }\n          for (let e = 0; e < r; e += 1) {\n            const e = (0, i.decodeParamFromAbiParameter)(n, t.subarray(o));\n            o += e.consumed, c.push(e.result);\n          }\n          return {\n            result: c,\n            encoded: t.subarray(o),\n            consumed: o\n          };\n        };\n      },\n      2252: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeBool = t.encodeBoolean = void 0;\n        const n = r(5071),\n          o = r(9634),\n          i = r(3852),\n          s = r(8809);\n        t.encodeBoolean = function (e, t) {\n          let r;\n          try {\n            r = (0, o.toBool)(t);\n          } catch (r) {\n            if (r instanceof n.InvalidBooleanError) throw new n.AbiError(\"provided input is not valid boolean value\", {\n              type: e.type,\n              value: t,\n              name: e.name\n            });\n          }\n          return (0, s.encodeNumber)({\n            type: \"uint8\",\n            name: \"\"\n          }, Number(r));\n        }, t.decodeBool = function (e, t) {\n          const r = (0, s.decodeNumber)({\n            type: \"uint8\",\n            name: \"\"\n          }, t);\n          if (r.result > 1 || r.result < 0) throw new n.AbiError(\"Invalid boolean value encoded\", {\n            boolBytes: t.subarray(0, i.WORD_SIZE),\n            numberResult: r\n          });\n          return {\n            result: r.result === BigInt(1),\n            encoded: r.encoded,\n            consumed: i.WORD_SIZE\n          };\n        };\n      },\n      7144: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeBytes = t.encodeBytes = void 0;\n        const n = r(5071),\n          o = r(9634),\n          i = r(7345),\n          s = r(3852),\n          a = r(8809);\n        t.encodeBytes = function (e, t) {\n          if (\"string\" == typeof t && t.length % 2 != 0 && (t += \"0\"), !(0, i.isBytes)(t)) throw new n.AbiError(\"provided input is not valid bytes value\", {\n            type: e.type,\n            value: t,\n            name: e.name\n          });\n          const r = (0, o.bytesToUint8Array)(t),\n            [, c] = e.type.split(\"bytes\");\n          if (c) {\n            if (Number(c) > 32 || Number(c) < 1) throw new n.AbiError(\"invalid bytes type. Static byte type can have between 1 and 32 bytes\", {\n              type: e.type\n            });\n            if (Number(c) < r.length) throw new n.AbiError(\"provided input size is different than type size\", {\n              type: e.type,\n              value: t,\n              name: e.name\n            });\n            const o = (0, s.alloc)(s.WORD_SIZE);\n            return o.set(r), {\n              dynamic: !1,\n              encoded: o\n            };\n          }\n          const u = Math.ceil(r.length / s.WORD_SIZE),\n            d = (0, s.alloc)(s.WORD_SIZE + u * s.WORD_SIZE);\n          return d.set((0, a.encodeNumber)({\n            type: \"uint32\",\n            name: \"\"\n          }, r.length).encoded), d.set(r, s.WORD_SIZE), {\n            dynamic: !0,\n            encoded: d\n          };\n        }, t.decodeBytes = function (e, t) {\n          const [, r] = e.type.split(\"bytes\");\n          let i = Number(r),\n            c = t,\n            u = 1,\n            d = 0;\n          if (!i) {\n            const e = (0, a.decodeNumber)({\n              type: \"uint32\",\n              name: \"\"\n            }, c);\n            i = Number(e.result), d += e.consumed, c = e.encoded, u = Math.ceil(i / s.WORD_SIZE);\n          }\n          if (i > t.length) throw new n.AbiError(\"there is not enough data to decode\", {\n            type: e.type,\n            encoded: t,\n            size: i\n          });\n          return {\n            result: (0, o.bytesToHex)(c.subarray(0, i)),\n            encoded: c.subarray(u * s.WORD_SIZE),\n            consumed: d + u * s.WORD_SIZE\n          };\n        };\n      },\n      5555: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeParamFromAbiParameter = t.encodeParamFromAbiParameter = t.decodeArray = t.encodeArray = t.decodeTuple = t.encodeTuple = t.decodeString = t.encodeString = t.decodeNumber = t.encodeNumber = t.decodeBytes = t.encodeBytes = t.decodeBool = t.encodeBoolean = t.decodeAddress = t.encodeAddress = void 0;\n        const n = r(5071),\n          o = r(1691),\n          i = r(2252),\n          s = r(7144),\n          a = r(8809),\n          c = r(8574),\n          u = r(4759),\n          d = r(7064);\n        var l = r(1691);\n        Object.defineProperty(t, \"encodeAddress\", {\n          enumerable: !0,\n          get: function () {\n            return l.encodeAddress;\n          }\n        }), Object.defineProperty(t, \"decodeAddress\", {\n          enumerable: !0,\n          get: function () {\n            return l.decodeAddress;\n          }\n        });\n        var h = r(2252);\n        Object.defineProperty(t, \"encodeBoolean\", {\n          enumerable: !0,\n          get: function () {\n            return h.encodeBoolean;\n          }\n        }), Object.defineProperty(t, \"decodeBool\", {\n          enumerable: !0,\n          get: function () {\n            return h.decodeBool;\n          }\n        });\n        var f = r(7144);\n        Object.defineProperty(t, \"encodeBytes\", {\n          enumerable: !0,\n          get: function () {\n            return f.encodeBytes;\n          }\n        }), Object.defineProperty(t, \"decodeBytes\", {\n          enumerable: !0,\n          get: function () {\n            return f.decodeBytes;\n          }\n        });\n        var p = r(8809);\n        Object.defineProperty(t, \"encodeNumber\", {\n          enumerable: !0,\n          get: function () {\n            return p.encodeNumber;\n          }\n        }), Object.defineProperty(t, \"decodeNumber\", {\n          enumerable: !0,\n          get: function () {\n            return p.decodeNumber;\n          }\n        });\n        var m = r(8574);\n        Object.defineProperty(t, \"encodeString\", {\n          enumerable: !0,\n          get: function () {\n            return m.encodeString;\n          }\n        }), Object.defineProperty(t, \"decodeString\", {\n          enumerable: !0,\n          get: function () {\n            return m.decodeString;\n          }\n        });\n        var g = r(4759);\n        Object.defineProperty(t, \"encodeTuple\", {\n          enumerable: !0,\n          get: function () {\n            return g.encodeTuple;\n          }\n        }), Object.defineProperty(t, \"decodeTuple\", {\n          enumerable: !0,\n          get: function () {\n            return g.decodeTuple;\n          }\n        });\n        var y = r(7064);\n        Object.defineProperty(t, \"encodeArray\", {\n          enumerable: !0,\n          get: function () {\n            return y.encodeArray;\n          }\n        }), Object.defineProperty(t, \"decodeArray\", {\n          enumerable: !0,\n          get: function () {\n            return y.decodeArray;\n          }\n        }), t.encodeParamFromAbiParameter = function (e, t) {\n          if (\"string\" === e.type) return (0, c.encodeString)(e, t);\n          if (\"bool\" === e.type) return (0, i.encodeBoolean)(e, t);\n          if (\"address\" === e.type) return (0, o.encodeAddress)(e, t);\n          if (\"tuple\" === e.type) return (0, u.encodeTuple)(e, t);\n          if (e.type.endsWith(\"]\")) return (0, d.encodeArray)(e, t);\n          if (e.type.startsWith(\"bytes\")) return (0, s.encodeBytes)(e, t);\n          if (e.type.startsWith(\"uint\") || e.type.startsWith(\"int\")) return (0, a.encodeNumber)(e, t);\n          throw new n.AbiError(\"Unsupported\", {\n            param: e,\n            value: t\n          });\n        }, t.decodeParamFromAbiParameter = function (e, t) {\n          if (\"string\" === e.type) return (0, c.decodeString)(e, t);\n          if (\"bool\" === e.type) return (0, i.decodeBool)(e, t);\n          if (\"address\" === e.type) return (0, o.decodeAddress)(e, t);\n          if (\"tuple\" === e.type) return (0, u.decodeTuple)(e, t);\n          if (e.type.endsWith(\"]\")) return (0, d.decodeArray)(e, t);\n          if (e.type.startsWith(\"bytes\")) return (0, s.decodeBytes)(e, t);\n          if (e.type.startsWith(\"uint\") || e.type.startsWith(\"int\")) return (0, a.decodeNumber)(e, t);\n          throw new n.AbiError(\"Unsupported\", {\n            param: e,\n            bytes: t\n          });\n        };\n      },\n      8809: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeNumber = t.encodeNumber = void 0;\n        const n = r(5071),\n          o = r(9634),\n          i = r(7345),\n          s = r(3852),\n          a = r(5978),\n          c = BigInt(1) << BigInt(256);\n        function u(e, t = s.WORD_SIZE) {\n          let r;\n          return r = e < 0 ? (c + e).toString(16) : e.toString(16), r = (0, o.padLeft)(r, 2 * t), i.utils.hexToUint8Array(r);\n        }\n        t.encodeNumber = function (e, t) {\n          let r;\n          try {\n            r = (0, o.toBigInt)(t);\n          } catch (r) {\n            throw new n.AbiError(\"provided input is not number value\", {\n              type: e.type,\n              value: t,\n              name: e.name\n            });\n          }\n          const i = a.numberLimits.get(e.type);\n          if (!i) throw new n.AbiError(\"provided abi contains invalid number datatype\", {\n            type: e.type\n          });\n          if (r < i.min) throw new n.AbiError(\"provided input is less then minimum for given type\", {\n            type: e.type,\n            value: t,\n            name: e.name,\n            minimum: i.min.toString()\n          });\n          if (r > i.max) throw new n.AbiError(\"provided input is greater then maximum for given type\", {\n            type: e.type,\n            value: t,\n            name: e.name,\n            maximum: i.max.toString()\n          });\n          return {\n            dynamic: !1,\n            encoded: u(r)\n          };\n        }, t.decodeNumber = function (e, t) {\n          if (t.length < s.WORD_SIZE) throw new n.AbiError(\"Not enough bytes left to decode\", {\n            param: e,\n            bytesLeft: t.length\n          });\n          const r = t.subarray(0, s.WORD_SIZE),\n            o = a.numberLimits.get(e.type);\n          if (!o) throw new n.AbiError(\"provided abi contains invalid number datatype\", {\n            type: e.type\n          });\n          const u = function (e, t) {\n            const r = i.utils.uint8ArrayToHexString(e),\n              n = BigInt(r);\n            return n <= t ? n : n - c;\n          }(r, o.max);\n          if (u < o.min) throw new n.AbiError(\"decoded value is less then minimum for given type\", {\n            type: e.type,\n            value: u,\n            name: e.name,\n            minimum: o.min.toString()\n          });\n          if (u > o.max) throw new n.AbiError(\"decoded value is greater then maximum for given type\", {\n            type: e.type,\n            value: u,\n            name: e.name,\n            maximum: o.max.toString()\n          });\n          return {\n            result: u,\n            encoded: t.subarray(s.WORD_SIZE),\n            consumed: s.WORD_SIZE\n          };\n        };\n      },\n      5978: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.numberLimits = void 0, t.numberLimits = new Map();\n        let r = BigInt(256);\n        for (let e = 8; e <= 256; e += 8) t.numberLimits.set(`uint${e}`, {\n          min: BigInt(0),\n          max: r - BigInt(1)\n        }), t.numberLimits.set(`int${e}`, {\n          min: -r / BigInt(2),\n          max: r / BigInt(2) - BigInt(1)\n        }), r *= BigInt(256);\n        t.numberLimits.set(\"int\", t.numberLimits.get(\"int256\")), t.numberLimits.set(\"uint\", t.numberLimits.get(\"uint256\"));\n      },\n      8574: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeString = t.encodeString = void 0;\n        const n = r(5071),\n          o = r(9634),\n          i = r(7144);\n        t.encodeString = function (e, t) {\n          if (\"string\" != typeof t) throw new n.AbiError(\"invalid input, should be string\", {\n            input: t\n          });\n          const r = (0, o.utf8ToBytes)(t);\n          return (0, i.encodeBytes)({\n            type: \"bytes\",\n            name: \"\"\n          }, r);\n        }, t.decodeString = function (e, t) {\n          const r = (0, i.decodeBytes)({\n            type: \"bytes\",\n            name: \"\"\n          }, t);\n          return {\n            result: (0, o.hexToUtf8)(r.result),\n            encoded: r.encoded,\n            consumed: r.consumed\n          };\n        };\n      },\n      4759: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeTuple = t.encodeTuple = void 0;\n        const n = r(5071),\n          o = r(9634),\n          i = r(5555),\n          s = r(5433),\n          a = r(3852),\n          c = r(8809);\n        t.encodeTuple = function (e, t) {\n          var r, a, c;\n          let u = !1;\n          if (!Array.isArray(t) && \"object\" != typeof t) throw new n.AbiError(\"param must be either Array or Object\", {\n            param: e,\n            input: t\n          });\n          const d = t,\n            l = [];\n          for (let o = 0; o < (null !== (a = null === (r = e.components) || void 0 === r ? void 0 : r.length) && void 0 !== a ? a : 0); o += 1) {\n            const r = e.components[o];\n            let s;\n            if (Array.isArray(d)) {\n              if (o >= d.length) throw new n.AbiError(\"input param length missmatch\", {\n                param: e,\n                input: t\n              });\n              s = (0, i.encodeParamFromAbiParameter)(r, d[o]);\n            } else {\n              const o = d[null !== (c = r.name) && void 0 !== c ? c : \"\"];\n              if (null == o) throw new n.AbiError(\"missing input defined in abi\", {\n                param: e,\n                input: t,\n                paramName: r.name\n              });\n              s = (0, i.encodeParamFromAbiParameter)(r, o);\n            }\n            s.dynamic && (u = !0), l.push(s);\n          }\n          return u ? {\n            dynamic: !0,\n            encoded: (0, s.encodeDynamicParams)(l)\n          } : {\n            dynamic: !1,\n            encoded: (0, o.uint8ArrayConcat)(...l.map(e => e.encoded))\n          };\n        }, t.decodeTuple = function (e, t) {\n          const r = {\n            __length__: 0\n          };\n          let n = 0;\n          if (!e.components) return {\n            result: r,\n            encoded: t,\n            consumed: n\n          };\n          let o = 0;\n          for (const [s, u] of e.components.entries()) {\n            let e;\n            if ((0, a.isDynamic)(u)) {\n              const r = (0, c.decodeNumber)({\n                type: \"uint32\",\n                name: \"\"\n              }, t.subarray(n));\n              e = (0, i.decodeParamFromAbiParameter)(u, t.subarray(Number(r.result))), n += r.consumed, o += e.consumed;\n            } else e = (0, i.decodeParamFromAbiParameter)(u, t.subarray(n)), n += e.consumed;\n            r.__length__ += 1, r[s] = e.result, u.name && \"\" !== u.name && (r[u.name] = e.result);\n          }\n          return {\n            encoded: t.subarray(n + o),\n            result: r,\n            consumed: n + o\n          };\n        };\n      },\n      5433: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.encodeDynamicParams = void 0;\n        const n = r(9634),\n          o = r(3852),\n          i = r(8809);\n        t.encodeDynamicParams = function (e) {\n          let t = 0,\n            r = 0;\n          const s = [],\n            a = [];\n          for (const r of e) r.dynamic ? t += o.WORD_SIZE : t += r.encoded.length;\n          for (const n of e) n.dynamic ? (s.push((0, i.encodeNumber)({\n            type: \"uint256\",\n            name: \"\"\n          }, t + r)), a.push(n), r += n.encoded.length) : s.push(n);\n          return (0, n.uint8ArrayConcat)(...s.map(e => e.encoded), ...a.map(e => e.encoded));\n        };\n      },\n      6729: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeParameters = void 0;\n        const n = r(7345),\n          o = r(4759),\n          i = r(3852);\n        t.decodeParameters = function (e, t, r) {\n          const s = (0, i.toAbiParams)(e),\n            a = n.utils.hexToUint8Array(t);\n          return (0, o.decodeTuple)({\n            type: \"tuple\",\n            name: \"\",\n            components: s\n          }, a).result;\n        };\n      },\n      4581: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.inferTypesAndEncodeParameters = t.encodeParameters = void 0;\n        const n = r(5071),\n          o = r(9634),\n          i = r(7345),\n          s = r(5555),\n          a = r(3852);\n        function c(e) {\n          const t = [];\n          return e.forEach(e => {\n            if (Array.isArray(e)) {\n              const r = c(e);\n              t.push({\n                type: \"tuple\",\n                components: r,\n                name: \"\"\n              });\n            } else t.push({\n              type: (0, o.toHex)(e, !0)\n            });\n          }), t;\n        }\n        t.encodeParameters = function (e, t) {\n          if ((null == e ? void 0 : e.length) !== t.length) throw new n.AbiError(\"Invalid number of values received for given ABI\", {\n            expected: null == e ? void 0 : e.length,\n            received: t.length\n          });\n          const r = (0, a.toAbiParams)(e);\n          return i.utils.uint8ArrayToHexString((0, s.encodeTuple)({\n            type: \"tuple\",\n            name: \"\",\n            components: r\n          }, t).encoded);\n        }, t.inferTypesAndEncodeParameters = function (e) {\n          try {\n            const t = c(e);\n            return i.utils.uint8ArrayToHexString((0, s.encodeTuple)({\n              type: \"tuple\",\n              name: \"\",\n              components: t\n            }, e).encoded);\n          } catch (t) {\n            throw new n.AbiError(\"Could not infer types from given params\", {\n              params: e\n            });\n          }\n        };\n      },\n      3852: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isDynamic = t.extractArrayType = t.toAbiParams = t.isAbiParameter = t.convertExternalAbiParameter = t.allocUnsafe = t.alloc = t.WORD_SIZE = void 0;\n        const n = r(1655),\n          o = r(5071),\n          i = r(9634),\n          s = r(1583);\n        function a(e) {\n          var t, r;\n          return Object.assign(Object.assign({}, e), {\n            name: null !== (t = e.name) && void 0 !== t ? t : \"\",\n            components: null === (r = e.components) || void 0 === r ? void 0 : r.map(e => a(e))\n          });\n        }\n        function c(e) {\n          return !(0, i.isNullish)(e) && \"object\" == typeof e && !(0, i.isNullish)(e.type) && \"string\" == typeof e.type;\n        }\n        function u(e) {\n          const t = e.type.lastIndexOf(\"[\"),\n            r = e.type.substring(0, t),\n            n = e.type.substring(t);\n          let i = -1;\n          if (\"[]\" !== n && (i = Number(n.slice(1, -1)), isNaN(i))) throw new o.AbiError(\"Invalid fixed array size\", {\n            size: n\n          });\n          return {\n            param: {\n              type: r,\n              name: \"\",\n              components: e.components\n            },\n            size: i\n          };\n        }\n        t.WORD_SIZE = 32, t.alloc = function (e = 0) {\n          var t;\n          if (void 0 !== (null === (t = globalThis.Buffer) || void 0 === t ? void 0 : t.alloc)) {\n            const t = globalThis.Buffer.alloc(e);\n            return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);\n          }\n          return new Uint8Array(e);\n        }, t.allocUnsafe = function (e = 0) {\n          var t;\n          if (void 0 !== (null === (t = globalThis.Buffer) || void 0 === t ? void 0 : t.allocUnsafe)) {\n            const t = globalThis.Buffer.allocUnsafe(e);\n            return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);\n          }\n          return new Uint8Array(e);\n        }, t.convertExternalAbiParameter = a, t.isAbiParameter = c, t.toAbiParams = function (e) {\n          return e.map(e => {\n            var t;\n            if (c(e)) return e;\n            if (\"string\" == typeof e) return a((0, n.parseAbiParameter)(e.replace(/tuple/, \"\")));\n            if ((0, s.isSimplifiedStructFormat)(e)) {\n              const r = Object.keys(e)[0],\n                n = (0, s.mapStructNameAndType)(r);\n              return n.name = null !== (t = n.name) && void 0 !== t ? t : \"\", Object.assign(Object.assign({}, n), {\n                components: (0, s.mapStructToCoderFormat)(e[r])\n              });\n            }\n            throw new o.AbiError(\"Invalid abi\");\n          });\n        }, t.extractArrayType = u, t.isDynamic = function e(t) {\n          var r, n;\n          return !(\"string\" !== t.type && \"bytes\" !== t.type && !t.type.endsWith(\"[]\")) || (\"tuple\" === t.type ? null !== (n = null === (r = t.components) || void 0 === r ? void 0 : r.some(e)) && void 0 !== n && n : !!t.type.endsWith(\"]\") && e(u(t).param));\n        };\n      },\n      5610: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeContractErrorData = void 0;\n        const n = r(9722),\n          o = r(4566),\n          i = r(1583);\n        t.decodeContractErrorData = (e, t) => {\n          if (null == t ? void 0 : t.data) {\n            let r, s, a;\n            try {\n              const c = t.data.slice(0, 10),\n                u = e.find(e => (0, n.encodeErrorSignature)(e).startsWith(c));\n              (null == u ? void 0 : u.inputs) && (r = u.name, s = (0, i.jsonInterfaceMethodToString)(u), a = (0, o.decodeParameters)([...u.inputs], t.data.substring(10)));\n            } catch (e) {\n              console.error(e);\n            }\n            r && t.setDecodedProperties(r, s, a);\n          }\n        };\n      },\n      6329: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getMessage = void 0;\n        const n = r(9634),\n          o = r(5071),\n          i = r(4581),\n          s = /^\\w+/,\n          a = /^(.*)\\[([0-9]*?)]$/,\n          c = (e, t, r = []) => {\n            const n = t.match(s)[0];\n            return r.includes(n) ? r : e.types[n] ? [n, ...e.types[n].reduce((t, r) => [...t, ...c(e, r.type, t).filter(e => !t.includes(e))], [])] : r;\n          },\n          u = (e, t) => (0, n.keccak256)(((e, t) => {\n            const [r, ...n] = c(e, t);\n            return [r, ...n.sort()].map(t => `${t}(${e.types[t].map(e => `${e.type} ${e.name}`)})`).join(\"\");\n          })(e, t)),\n          d = (e, t, r) => (0, n.keccak256)(h(e, t, r));\n        t.getMessage = (e, t) => {\n          const r = `0x1901${d(e, \"EIP712Domain\", e.domain).substring(2)}${d(e, e.primaryType, e.message).substring(2)}`;\n          return t ? (0, n.keccak256)(r) : r;\n        };\n        const l = (e, t, r) => {\n            const s = t.match(a);\n            if (s) {\n              const t = s[1],\n                a = Number(s[2]) || void 0;\n              if (!Array.isArray(r)) throw new o.AbiError(\"Cannot encode data: value is not of array type\", {\n                data: r\n              });\n              if (a && r.length !== a) throw new o.AbiError(`Cannot encode data: expected length of ${a}, but got ${r.length}`, {\n                data: r\n              });\n              const c = r.map(r => l(e, t, r)),\n                u = c.map(e => e[0]),\n                d = c.map(e => e[1]);\n              return [\"bytes32\", (0, n.keccak256)((0, i.encodeParameters)(u, d))];\n            }\n            return e.types[t] ? [\"bytes32\", d(e, t, r)] : \"string\" === t || \"bytes\" === t ? [\"bytes32\", (0, n.keccak256)(r)] : [t, r];\n          },\n          h = (e, t, r) => {\n            const [s, a] = e.types[t].reduce(([t, i], s) => {\n              if ((0, n.isNullish)(r[s.name]) || (0, n.isNullish)(r[s.name])) throw new o.AbiError(`Cannot encode data: missing data for '${s.name}'`, {\n                data: r,\n                field: s\n              });\n              const a = r[s.name],\n                [c, u] = l(e, s.type, a);\n              return [[...t, c], [...i, u]];\n            }, [[\"bytes32\"], [u(e, t)]]);\n            return (0, i.encodeParameters)(s, a);\n          };\n      },\n      8381: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getEncodedEip712Data = void 0, o(r(9722), t), o(r(5893), t), o(r(3249), t), o(r(734), t), o(r(4566), t), o(r(1583), t), o(r(5610), t);\n        var i = r(6329);\n        Object.defineProperty(t, \"getEncodedEip712Data\", {\n          enumerable: !0,\n          get: function () {\n            return i.getMessage;\n          }\n        });\n      },\n      1583: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.jsonInterfaceMethodToString = t.flattenTypes = t.formatParam = t.formatOddHexstrings = t.isOddHexstring = t.mapTypes = t.mapStructToCoderFormat = t.mapStructNameAndType = t.isSimplifiedStructFormat = t.isAbiConstructorFragment = t.isAbiFunctionFragment = t.isAbiEventFragment = t.isAbiErrorFragment = t.isAbiFragment = void 0;\n        const n = r(5071),\n          o = r(9634);\n        t.isAbiFragment = e => !(0, o.isNullish)(e) && \"object\" == typeof e && !(0, o.isNullish)(e.type) && [\"function\", \"event\", \"constructor\", \"error\"].includes(e.type), t.isAbiErrorFragment = e => !(0, o.isNullish)(e) && \"object\" == typeof e && !(0, o.isNullish)(e.type) && \"error\" === e.type, t.isAbiEventFragment = e => !(0, o.isNullish)(e) && \"object\" == typeof e && !(0, o.isNullish)(e.type) && \"event\" === e.type, t.isAbiFunctionFragment = e => !(0, o.isNullish)(e) && \"object\" == typeof e && !(0, o.isNullish)(e.type) && \"function\" === e.type, t.isAbiConstructorFragment = e => !(0, o.isNullish)(e) && \"object\" == typeof e && !(0, o.isNullish)(e.type) && \"constructor\" === e.type, t.isSimplifiedStructFormat = e => \"object\" == typeof e && void 0 === e.components && void 0 === e.name, t.mapStructNameAndType = e => e.includes(\"[]\") ? {\n          type: \"tuple[]\",\n          name: e.slice(0, -2)\n        } : {\n          type: \"tuple\",\n          name: e\n        }, t.mapStructToCoderFormat = e => {\n          const r = [];\n          for (const n of Object.keys(e)) {\n            const o = e[n];\n            \"object\" == typeof o ? r.push(Object.assign(Object.assign({}, (0, t.mapStructNameAndType)(n)), {\n              components: (0, t.mapStructToCoderFormat)(o)\n            })) : r.push({\n              name: n,\n              type: e[n]\n            });\n          }\n          return r;\n        }, t.mapTypes = e => {\n          const r = [];\n          for (const n of e) {\n            let e = n;\n            if (\"object\" == typeof n && (e = Object.assign({}, n)), \"object\" == typeof n && \"function\" === n.type && (e = Object.assign(Object.assign({}, n), {\n              type: \"bytes24\"\n            })), (0, t.isSimplifiedStructFormat)(e)) {\n              const n = Object.keys(e)[0];\n              r.push(Object.assign(Object.assign({}, (0, t.mapStructNameAndType)(n)), {\n                components: (0, t.mapStructToCoderFormat)(e[n])\n              }));\n            } else r.push(e);\n          }\n          return r;\n        }, t.isOddHexstring = e => \"string\" == typeof e && /^(-)?0x[0-9a-f]*$/i.test(e) && e.length % 2 == 1, t.formatOddHexstrings = e => (0, t.isOddHexstring)(e) ? `0x0${e.substring(2)}` : e;\n        const i = /^bytes([0-9]*)$/,\n          s = /^bytes([0-9]*)\\[\\]$/,\n          a = /^(u?int)([0-9]*)$/,\n          c = /^(u?int)([0-9]*)\\[\\]$/;\n        t.formatParam = (e, r) => {\n          const n = \"object\" != typeof r || Array.isArray(r) ? r : Object.assign({}, r);\n          if (n instanceof BigInt || \"bigint\" == typeof n) return n.toString(10);\n          if (s.exec(e) || c.exec(e)) return [...n].map(r => (0, t.formatParam)(e.replace(\"[]\", \"\"), r));\n          let u = a.exec(e);\n          if (u) {\n            const e = parseInt(u[2] ? u[2] : \"256\", 10);\n            if (e / 8 < n.length) return (0, o.leftPad)(n, e);\n          }\n          if (u = i.exec(e), u) {\n            const e = (0, o.isUint8Array)(n) ? (0, o.toHex)(n) : n,\n              r = parseInt(u[1], 10);\n            if (r) {\n              let i = 2 * r;\n              n.startsWith(\"0x\") && (i += 2);\n              const s = e.length < i ? (0, o.rightPad)(n, 2 * r) : e;\n              return (0, t.formatOddHexstrings)(s);\n            }\n            return (0, t.formatOddHexstrings)(e);\n          }\n          return n;\n        }, t.flattenTypes = (e, r) => {\n          const o = [];\n          return r.forEach(r => {\n            if (\"object\" == typeof r.components) {\n              if (!r.type.startsWith(\"tuple\")) throw new n.AbiError(`Invalid value given \"${r.type}\". Error: components found but type is not tuple.`);\n              const i = r.type.indexOf(\"[\"),\n                s = i >= 0 ? r.type.substring(i) : \"\",\n                a = (0, t.flattenTypes)(e, r.components);\n              Array.isArray(a) && e ? o.push(`tuple(${a.join(\",\")})${s}`) : e ? o.push(`(${a.join()})`) : o.push(`(${a.join(\",\")})${s}`);\n            } else o.push(r.type);\n          }), o;\n        }, t.jsonInterfaceMethodToString = e => {\n          var r, n, o, i;\n          return (0, t.isAbiErrorFragment)(e) || (0, t.isAbiEventFragment)(e) || (0, t.isAbiFunctionFragment)(e) ? (null === (r = e.name) || void 0 === r ? void 0 : r.includes(\"(\")) ? e.name : `${null !== (n = e.name) && void 0 !== n ? n : \"\"}(${(0, t.flattenTypes)(!1, null !== (o = e.inputs) && void 0 !== o ? o : []).join(\",\")})` : `(${(0, t.flattenTypes)(!1, null !== (i = e.inputs) && void 0 !== i ? i : []).join(\",\")})`;\n        };\n      },\n      1560: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decrypt = t.create = t.privateKeyToAccount = t.encrypt = t.privateKeyToPublicKey = t.privateKeyToAddress = t.recover = t.recoverTransaction = t.signTransaction = t.sign = t.hashMessage = t.parseAndValidatePrivateKey = void 0;\n        const o = r(3072),\n          i = r(8109),\n          s = r(7002),\n          a = r(5071),\n          c = r(9634),\n          u = r(7345),\n          d = r(4555),\n          l = r(5774),\n          h = r(7668);\n        t.parseAndValidatePrivateKey = (e, t) => {\n          let r;\n          if (!t && \"string\" == typeof e && (0, u.isHexStrict)(e) && 66 !== e.length) throw new a.PrivateKeyLengthError();\n          try {\n            r = (0, c.isUint8Array)(e) ? e : (0, c.bytesToUint8Array)(e);\n          } catch (e) {\n            throw new a.InvalidPrivateKeyError();\n          }\n          if (!t && 32 !== r.byteLength) throw new a.PrivateKeyLengthError();\n          return r;\n        }, t.hashMessage = e => {\n          const t = (0, u.isHexStrict)(e) ? e : (0, c.utf8ToHex)(e),\n            r = (0, c.hexToBytes)(t),\n            n = (0, c.hexToBytes)((0, c.fromUtf8)(`\u0019Ethereum Signed Message:\\n${r.byteLength}`)),\n            o = (0, c.uint8ArrayConcat)(n, r);\n          return (0, c.sha3Raw)(o);\n        }, t.sign = (e, r) => {\n          const n = (0, t.parseAndValidatePrivateKey)(r),\n            o = (0, t.hashMessage)(e),\n            i = d.secp256k1.sign(o.substring(2), n),\n            s = i.toCompactRawBytes(),\n            a = i.r.toString(16).padStart(64, \"0\"),\n            u = i.s.toString(16).padStart(64, \"0\"),\n            l = i.recovery + 27;\n          return {\n            message: e,\n            messageHash: o,\n            v: (0, c.numberToHex)(l),\n            r: `0x${a}`,\n            s: `0x${u}`,\n            signature: `${(0, c.bytesToHex)(s)}${l.toString(16)}`\n          };\n        }, t.signTransaction = (e, t) => n(void 0, void 0, void 0, function* () {\n          const r = e.sign((0, c.hexToBytes)(t));\n          if ((0, u.isNullish)(r.v) || (0, u.isNullish)(r.r) || (0, u.isNullish)(r.s)) throw new a.TransactionSigningError(\"Signer Error\");\n          const n = r.validate(!0);\n          if (n.length > 0) {\n            let e = \"Signer Error \";\n            for (const t of n) e += `${e} ${t}.`;\n            throw new a.TransactionSigningError(e);\n          }\n          const o = (0, c.bytesToHex)(r.serialize()),\n            i = (0, c.sha3Raw)(o);\n          return {\n            messageHash: (0, c.bytesToHex)(r.getMessageToSign(!0)),\n            v: `0x${r.v.toString(16)}`,\n            r: `0x${r.r.toString(16).padStart(64, \"0\")}`,\n            s: `0x${r.s.toString(16).padStart(64, \"0\")}`,\n            rawTransaction: o,\n            transactionHash: (0, c.bytesToHex)(i)\n          };\n        }), t.recoverTransaction = e => {\n          if ((0, u.isNullish)(e)) throw new a.UndefinedRawTransactionError();\n          const t = h.TransactionFactory.fromSerializedData((0, c.hexToBytes)(e));\n          return (0, c.toChecksumAddress)(t.getSenderAddress().toString());\n        }, t.recover = (e, r, n, o, i) => {\n          if (\"object\" == typeof e) {\n            const r = `${e.r}${e.s.slice(2)}${e.v.slice(2)}`;\n            return (0, t.recover)(e.messageHash, r, n);\n          }\n          if (\"string\" == typeof r && \"string\" == typeof n && !(0, u.isNullish)(o)) {\n            const s = `${n}${o.slice(2)}${r.slice(2)}`;\n            return (0, t.recover)(e, s, i);\n          }\n          if ((0, u.isNullish)(r)) throw new a.InvalidSignatureError(\"signature string undefined\");\n          const s = n ? e : (0, t.hashMessage)(e);\n          let l = parseInt(r.substring(130), 16);\n          l > 26 && (l -= 27);\n          const h = d.secp256k1.Signature.fromCompact(r.slice(2, 130)).addRecoveryBit(l).recoverPublicKey(s.replace(\"0x\", \"\")).toRawBytes(!1),\n            f = (0, c.sha3Raw)(h.subarray(1));\n          return (0, c.toChecksumAddress)(`0x${f.slice(-40)}`);\n        }, t.privateKeyToAddress = e => {\n          const r = (0, t.parseAndValidatePrivateKey)(e),\n            n = d.secp256k1.getPublicKey(r, !1),\n            o = (0, c.sha3Raw)(n.slice(1)).slice(-40);\n          return (0, c.toChecksumAddress)(`0x${o}`);\n        }, t.privateKeyToPublicKey = (e, r) => {\n          const n = (0, t.parseAndValidatePrivateKey)(e);\n          return `0x${(0, c.bytesToHex)(d.secp256k1.getPublicKey(n, r)).slice(4)}`;\n        }, t.encrypt = (e, r, d) => n(void 0, void 0, void 0, function* () {\n          var n, l, h, f, p, m, g;\n          const y = (0, t.parseAndValidatePrivateKey)(e);\n          let v;\n          if (v = (null == d ? void 0 : d.salt) ? \"string\" == typeof d.salt ? (0, c.hexToBytes)(d.salt) : d.salt : (0, c.randomBytes)(32), !(0, u.isString)(r) && !(0, c.isUint8Array)(r)) throw new a.InvalidPasswordError();\n          const b = \"string\" == typeof r ? (0, c.hexToBytes)((0, c.utf8ToHex)(r)) : r;\n          let E;\n          if (null == d ? void 0 : d.iv) {\n            if (E = \"string\" == typeof d.iv ? (0, c.hexToBytes)(d.iv) : d.iv, 16 !== E.length) throw new a.IVLengthError();\n          } else E = (0, c.randomBytes)(16);\n          const _ = null !== (n = null == d ? void 0 : d.kdf) && void 0 !== n ? n : \"scrypt\";\n          let A, T;\n          if (\"pbkdf2\" === _) {\n            if (T = {\n              dklen: null !== (l = null == d ? void 0 : d.dklen) && void 0 !== l ? l : 32,\n              salt: (0, c.bytesToHex)(v).replace(\"0x\", \"\"),\n              c: null !== (h = null == d ? void 0 : d.c) && void 0 !== h ? h : 262144,\n              prf: \"hmac-sha256\"\n            }, T.c < 1e3) throw new a.PBKDF2IterationsError();\n            A = (0, i.pbkdf2Sync)(b, v, T.c, T.dklen, \"sha256\");\n          } else {\n            if (\"scrypt\" !== _) throw new a.InvalidKdfError();\n            T = {\n              n: null !== (f = null == d ? void 0 : d.n) && void 0 !== f ? f : 8192,\n              r: null !== (p = null == d ? void 0 : d.r) && void 0 !== p ? p : 8,\n              p: null !== (m = null == d ? void 0 : d.p) && void 0 !== m ? m : 1,\n              dklen: null !== (g = null == d ? void 0 : d.dklen) && void 0 !== g ? g : 32,\n              salt: (0, c.bytesToHex)(v).replace(\"0x\", \"\")\n            }, A = (0, s.scryptSync)(b, v, T.n, T.p, T.r, T.dklen);\n          }\n          const w = yield (0, o.encrypt)(y, A.slice(0, 16), E, \"aes-128-ctr\"),\n            I = (0, c.bytesToHex)(w).slice(2),\n            R = (0, c.sha3Raw)((0, c.uint8ArrayConcat)(A.slice(16, 32), w)).replace(\"0x\", \"\");\n          return {\n            version: 3,\n            id: (0, c.uuidV4)(),\n            address: (0, t.privateKeyToAddress)(y).toLowerCase().replace(\"0x\", \"\"),\n            crypto: {\n              ciphertext: I,\n              cipherparams: {\n                iv: (0, c.bytesToHex)(E).replace(\"0x\", \"\")\n              },\n              cipher: \"aes-128-ctr\",\n              kdf: _,\n              kdfparams: T,\n              mac: R\n            }\n          };\n        }), t.privateKeyToAccount = (e, r) => {\n          const o = (0, t.parseAndValidatePrivateKey)(e, r);\n          return {\n            address: (0, t.privateKeyToAddress)(o),\n            privateKey: (0, c.bytesToHex)(o),\n            signTransaction: e => {\n              throw new a.TransactionSigningError(\"Do not have network access to sign the transaction\");\n            },\n            sign: e => (0, t.sign)(\"string\" == typeof e ? e : JSON.stringify(e), o),\n            encrypt: (e, r) => n(void 0, void 0, void 0, function* () {\n              return (0, t.encrypt)(o, e, r);\n            })\n          };\n        }, t.create = () => {\n          const e = d.secp256k1.utils.randomPrivateKey();\n          return (0, t.privateKeyToAccount)(`${(0, c.bytesToHex)(e)}`);\n        }, t.decrypt = (e, r, d) => n(void 0, void 0, void 0, function* () {\n          const n = \"object\" == typeof e ? e : JSON.parse(d ? e.toLowerCase() : e);\n          if (u.validator.validateJSONSchema(l.keyStoreSchema, n), 3 !== n.version) throw new a.KeyStoreVersionError();\n          const h = \"string\" == typeof r ? (0, c.hexToBytes)((0, c.utf8ToHex)(r)) : r;\n          let f;\n          if (u.validator.validate([\"bytes\"], [h]), \"scrypt\" === n.crypto.kdf) {\n            const e = n.crypto.kdfparams,\n              t = \"string\" == typeof e.salt ? (0, c.hexToBytes)(e.salt) : e.salt;\n            f = (0, s.scryptSync)(h, t, e.n, e.p, e.r, e.dklen);\n          } else {\n            if (\"pbkdf2\" !== n.crypto.kdf) throw new a.InvalidKdfError();\n            {\n              const e = n.crypto.kdfparams,\n                t = \"string\" == typeof e.salt ? (0, c.hexToBytes)(e.salt) : e.salt;\n              f = (0, i.pbkdf2Sync)(h, t, e.c, e.dklen, \"sha256\");\n            }\n          }\n          const p = (0, c.hexToBytes)(n.crypto.ciphertext);\n          if ((0, c.sha3Raw)((0, c.uint8ArrayConcat)(f.slice(16, 32), p)).replace(\"0x\", \"\") !== n.crypto.mac) throw new a.KeyDerivationError();\n          const m = yield (0, o.decrypt)((0, c.hexToBytes)(n.crypto.ciphertext), f.slice(0, 16), (0, c.hexToBytes)(n.crypto.cipherparams.iv));\n          return (0, t.privateKeyToAccount)(m);\n        });\n      },\n      7634: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"goerli\",\n          chainId: 5,\n          networkId: 5,\n          defaultHardfork: \"merge\",\n          consensus: {\n            type: \"poa\",\n            algorithm: \"clique\",\n            clique: {\n              period: 15,\n              epoch: 3e4\n            }\n          },\n          comment: \"Cross-client PoA test network\",\n          url: \"https://github.com/goerli/testnet\",\n          genesis: {\n            timestamp: \"0x5c51a607\",\n            gasLimit: 10485760,\n            difficulty: 1,\n            nonce: \"0x0000000000000000\",\n            extraData: \"0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n          },\n          hardforks: [{\n            name: \"chainstart\",\n            block: 0,\n            forkHash: \"0xa3f5ab08\"\n          }, {\n            name: \"homestead\",\n            block: 0,\n            forkHash: \"0xa3f5ab08\"\n          }, {\n            name: \"tangerineWhistle\",\n            block: 0,\n            forkHash: \"0xa3f5ab08\"\n          }, {\n            name: \"spuriousDragon\",\n            block: 0,\n            forkHash: \"0xa3f5ab08\"\n          }, {\n            name: \"byzantium\",\n            block: 0,\n            forkHash: \"0xa3f5ab08\"\n          }, {\n            name: \"constantinople\",\n            block: 0,\n            forkHash: \"0xa3f5ab08\"\n          }, {\n            name: \"petersburg\",\n            block: 0,\n            forkHash: \"0xa3f5ab08\"\n          }, {\n            name: \"istanbul\",\n            block: 1561651,\n            forkHash: \"0xc25efa5c\"\n          }, {\n            name: \"berlin\",\n            block: 4460644,\n            forkHash: \"0x757a1c47\"\n          }, {\n            name: \"london\",\n            block: 5062605,\n            forkHash: \"0xb8c6299d\"\n          }, {\n            \"//_comment\": \"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818\",\n            name: \"merge\",\n            ttd: \"10790000\",\n            block: 7382819,\n            forkHash: \"0xb8c6299d\"\n          }, {\n            name: \"mergeForkIdTransition\",\n            block: null,\n            forkHash: null\n          }, {\n            name: \"shanghai\",\n            block: null,\n            forkHash: null\n          }],\n          bootstrapNodes: [],\n          dnsNetworks: [\"enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net\"]\n        };\n      },\n      3233: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"mainnet\",\n          chainId: 1,\n          networkId: 1,\n          defaultHardfork: \"merge\",\n          consensus: {\n            type: \"pow\",\n            algorithm: \"ethash\",\n            ethash: {}\n          },\n          comment: \"The Ethereum main chain\",\n          url: \"https://ethstats.net/\",\n          genesis: {\n            gasLimit: 5e3,\n            difficulty: 17179869184,\n            nonce: \"0x0000000000000042\",\n            extraData: \"0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa\"\n          },\n          hardforks: [{\n            name: \"chainstart\",\n            block: 0,\n            forkHash: \"0xfc64ec04\"\n          }, {\n            name: \"homestead\",\n            block: 115e4,\n            forkHash: \"0x97c2c34c\"\n          }, {\n            name: \"dao\",\n            block: 192e4,\n            forkHash: \"0x91d1f948\"\n          }, {\n            name: \"tangerineWhistle\",\n            block: 2463e3,\n            forkHash: \"0x7a64da13\"\n          }, {\n            name: \"spuriousDragon\",\n            block: 2675e3,\n            forkHash: \"0x3edd5b10\"\n          }, {\n            name: \"byzantium\",\n            block: 437e4,\n            forkHash: \"0xa00bc324\"\n          }, {\n            name: \"constantinople\",\n            block: 728e4,\n            forkHash: \"0x668db0af\"\n          }, {\n            name: \"petersburg\",\n            block: 728e4,\n            forkHash: \"0x668db0af\"\n          }, {\n            name: \"istanbul\",\n            block: 9069e3,\n            forkHash: \"0x879d6e30\"\n          }, {\n            name: \"muirGlacier\",\n            block: 92e5,\n            forkHash: \"0xe029e991\"\n          }, {\n            name: \"berlin\",\n            block: 12244e3,\n            forkHash: \"0x0eb440f6\"\n          }, {\n            name: \"london\",\n            block: 12965e3,\n            forkHash: \"0xb715077d\"\n          }, {\n            name: \"arrowGlacier\",\n            block: 13773e3,\n            forkHash: \"0x20c327fc\"\n          }, {\n            name: \"grayGlacier\",\n            block: 1505e4,\n            forkHash: \"0xf0afd0e3\"\n          }, {\n            \"//_comment\": \"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393\",\n            name: \"merge\",\n            ttd: \"58750000000000000000000\",\n            block: 15537394,\n            forkHash: \"0xf0afd0e3\"\n          }, {\n            name: \"mergeForkIdTransition\",\n            block: null,\n            forkHash: null\n          }, {\n            name: \"shanghai\",\n            block: null,\n            forkHash: null\n          }],\n          bootstrapNodes: [],\n          dnsNetworks: [\"enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net\"]\n        };\n      },\n      5077: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"sepolia\",\n          chainId: 11155111,\n          networkId: 11155111,\n          defaultHardfork: \"merge\",\n          consensus: {\n            type: \"pow\",\n            algorithm: \"ethash\",\n            ethash: {}\n          },\n          comment: \"PoW test network to replace Ropsten\",\n          url: \"https://github.com/ethereum/go-ethereum/pull/23730\",\n          genesis: {\n            timestamp: \"0x6159af19\",\n            gasLimit: 3e7,\n            difficulty: 131072,\n            nonce: \"0x0000000000000000\",\n            extraData: \"0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521\"\n          },\n          hardforks: [{\n            name: \"chainstart\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"homestead\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"tangerineWhistle\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"spuriousDragon\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"byzantium\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"constantinople\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"petersburg\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"istanbul\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"muirGlacier\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"berlin\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"london\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            \"//_comment\": \"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408\",\n            name: \"merge\",\n            ttd: \"17000000000000000\",\n            block: 1450409,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"mergeForkIdTransition\",\n            block: 1735371,\n            forkHash: \"0xb96cbd13\"\n          }, {\n            name: \"shanghai\",\n            block: null,\n            timestamp: \"1677557088\",\n            forkHash: \"0xf7f9bc08\"\n          }],\n          bootstrapNodes: [],\n          dnsNetworks: [\"enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net\"]\n        };\n      },\n      6664: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Common = void 0;\n        const o = n(r(1238)),\n          i = r(9634),\n          s = r(850),\n          a = r(2290),\n          c = n(r(7634)),\n          u = n(r(3233)),\n          d = n(r(5077)),\n          l = r(5257),\n          h = r(4443),\n          f = r(9137),\n          {\n            buf: p\n          } = o.default;\n        class m extends i.EventEmitter {\n          constructor(e) {\n            var t, r;\n            super(), this._eips = [], this._customChains = null !== (t = e.customChains) && void 0 !== t ? t : [], this._chainParams = this.setChain(e.chain), this.DEFAULT_HARDFORK = null !== (r = this._chainParams.defaultHardfork) && void 0 !== r ? r : h.Hardfork.Merge, this.HARDFORK_CHANGES = this.hardforks().map(e => [e.name, f.hardforks[e.name]]), this._hardfork = this.DEFAULT_HARDFORK, void 0 !== e.hardfork && this.setHardfork(e.hardfork), e.eips && this.setEIPs(e.eips);\n          }\n          static custom(e, t = {}) {\n            var r;\n            const n = null !== (r = t.baseChain) && void 0 !== r ? r : \"mainnet\",\n              o = Object.assign({}, m._getChainParams(n));\n            if (o.name = \"custom-chain\", \"string\" != typeof e) return new m(Object.assign({\n              chain: Object.assign(Object.assign({}, o), e)\n            }, t));\n            if (e === h.CustomChain.PolygonMainnet) return m.custom({\n              name: h.CustomChain.PolygonMainnet,\n              chainId: 137,\n              networkId: 137\n            }, t);\n            if (e === h.CustomChain.PolygonMumbai) return m.custom({\n              name: h.CustomChain.PolygonMumbai,\n              chainId: 80001,\n              networkId: 80001\n            }, t);\n            if (e === h.CustomChain.ArbitrumRinkebyTestnet) return m.custom({\n              name: h.CustomChain.ArbitrumRinkebyTestnet,\n              chainId: 421611,\n              networkId: 421611\n            }, t);\n            if (e === h.CustomChain.ArbitrumOne) return m.custom({\n              name: h.CustomChain.ArbitrumOne,\n              chainId: 42161,\n              networkId: 42161\n            }, t);\n            if (e === h.CustomChain.xDaiChain) return m.custom({\n              name: h.CustomChain.xDaiChain,\n              chainId: 100,\n              networkId: 100\n            }, t);\n            if (e === h.CustomChain.OptimisticKovan) return m.custom({\n              name: h.CustomChain.OptimisticKovan,\n              chainId: 69,\n              networkId: 69\n            }, Object.assign({\n              hardfork: h.Hardfork.Berlin\n            }, t));\n            if (e === h.CustomChain.OptimisticEthereum) return m.custom({\n              name: h.CustomChain.OptimisticEthereum,\n              chainId: 10,\n              networkId: 10\n            }, Object.assign({\n              hardfork: h.Hardfork.Berlin\n            }, t));\n            throw new Error(`Custom chain ${e} not supported`);\n          }\n          static fromGethGenesis(e, {\n            chain: t,\n            eips: r,\n            genesisHash: n,\n            hardfork: o,\n            mergeForkIdPostMerge: i\n          }) {\n            var s;\n            const c = (0, a.parseGethGenesis)(e, t, i),\n              u = new m({\n                chain: null !== (s = c.name) && void 0 !== s ? s : \"custom\",\n                customChains: [c],\n                eips: r,\n                hardfork: null != o ? o : c.hardfork\n              });\n            return void 0 !== n && u.setForkHashes(n), u;\n          }\n          static isSupportedChainId(e) {\n            const t = this._getInitializedChains();\n            return Boolean(t.names[e.toString()]);\n          }\n          static _getChainParams(e, t) {\n            let r = e;\n            const n = this._getInitializedChains(t);\n            if (\"number\" == typeof r || \"bigint\" == typeof r) {\n              if (r = r.toString(), n.names[r]) return n[n.names[r]];\n              throw new Error(`Chain with ID ${r} not supported`);\n            }\n            if (void 0 !== n[r]) return n[r];\n            throw new Error(`Chain with name ${r} not supported`);\n          }\n          setChain(e) {\n            if (\"number\" == typeof e || \"bigint\" == typeof e || \"string\" == typeof e) this._chainParams = m._getChainParams(e, this._customChains);else {\n              if (\"object\" != typeof e) throw new Error(\"Wrong input format\");\n              {\n                if (this._customChains.length > 0) throw new Error(\"Chain must be a string, number, or bigint when initialized with customChains passed in\");\n                const t = [\"networkId\", \"genesis\", \"hardforks\", \"bootstrapNodes\"];\n                for (const r of t) if (!(r in e)) throw new Error(`Missing required chain parameter: ${r}`);\n                this._chainParams = e;\n              }\n            }\n            for (const e of this.hardforks()) if (void 0 === e.block) throw new Error(\"Hardfork cannot have undefined block number\");\n            return this._chainParams;\n          }\n          setHardfork(e) {\n            let t = !1;\n            for (const r of this.HARDFORK_CHANGES) r[0] === e && (this._hardfork !== e && (this._hardfork = e, this.emit(\"hardforkChanged\", e)), t = !0);\n            if (!t) throw new Error(`Hardfork with name ${e} not supported`);\n          }\n          getHardforkByBlockNumber(e, t, r) {\n            const n = (0, a.toType)(e, s.TypeOutput.BigInt),\n              o = (0, a.toType)(t, s.TypeOutput.BigInt),\n              i = (0, a.toType)(r, s.TypeOutput.Number),\n              c = this.hardforks().filter(e => null !== e.block || null !== e.ttd && void 0 !== e.ttd || void 0 !== e.timestamp),\n              u = c.findIndex(e => null !== e.ttd && void 0 !== e.ttd);\n            if (c.slice(u + 1).findIndex(e => null !== e.ttd && void 0 !== e.ttd) >= 0) throw Error(\"More than one merge hardforks found with ttd specified\");\n            let d = c.findIndex(e => null !== e.block && e.block > n || void 0 !== i && Number(e.timestamp) > i);\n            if (-1 === d) d = c.length;else if (0 === d) throw Error(\"Must have at least one hardfork at block 0\");\n            if (void 0 === i && (d -= c.slice(0, d).reverse().findIndex(e => null !== e.block || void 0 !== e.ttd)), d -= 1, null === c[d].block && void 0 === c[d].timestamp) (null == o || BigInt(c[d].ttd) > o) && (d -= 1);else if (u >= 0 && null != o) {\n              if (d >= u && BigInt(c[u].ttd) > o) throw Error(\"Maximum HF determined by total difficulty is lower than the block number HF\");\n              if (d < u && BigInt(c[u].ttd) <= o) throw Error(\"HF determined by block number is lower than the minimum total difficulty HF\");\n            }\n            const l = d;\n            for (; d < c.length - 1 && c[d].block === c[d + 1].block && c[d].timestamp === c[d + 1].timestamp; d += 1);\n            if (i) {\n              if (c.slice(0, l).reduce((e, t) => {\n                var r;\n                return Math.max(Number(null !== (r = t.timestamp) && void 0 !== r ? r : \"0\"), e);\n              }, 0) > i) throw Error(\"Maximum HF determined by timestamp is lower than the block number/ttd HF\");\n              if (c.slice(d + 1).reduce((e, t) => {\n                var r;\n                return Math.min(Number(null !== (r = t.timestamp) && void 0 !== r ? r : i), e);\n              }, i) < i) throw Error(\"Maximum HF determined by block number/ttd is lower than timestamp HF\");\n            }\n            return c[d].name;\n          }\n          setHardforkByBlockNumber(e, t, r) {\n            const n = this.getHardforkByBlockNumber(e, t, r);\n            return this.setHardfork(n), n;\n          }\n          _getHardfork(e) {\n            const t = this.hardforks();\n            for (const r of t) if (r.name === e) return r;\n            return null;\n          }\n          setEIPs(e = []) {\n            for (const t of e) {\n              if (!(t in l.EIPs)) throw new Error(`${t} not supported`);\n              const r = this.gteHardfork(l.EIPs[t].minimumHardfork);\n              if (!r) throw new Error(`${t} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${r}`);\n              if (void 0 !== l.EIPs[t].requiredEIPs) for (const r of l.EIPs[t].requiredEIPs) if (!e.includes(r) && !this.isActivatedEIP(r)) throw new Error(`${t} requires EIP ${r}, but is not included in the EIP list`);\n            }\n            this._eips = e;\n          }\n          param(e, t) {\n            let r;\n            for (const n of this._eips) if (r = this.paramByEIP(e, t, n), void 0 !== r) return r;\n            return this.paramByHardfork(e, t, this._hardfork);\n          }\n          paramByHardfork(e, t, r) {\n            let n = null;\n            for (const o of this.HARDFORK_CHANGES) {\n              if (\"eips\" in o[1]) {\n                const r = o[1].eips;\n                for (const o of r) {\n                  const r = this.paramByEIP(e, t, o);\n                  n = \"bigint\" == typeof r ? r : n;\n                }\n              } else {\n                if (void 0 === o[1][e]) throw new Error(`Topic ${e} not defined`);\n                void 0 !== o[1][e][t] && (n = o[1][e][t].v);\n              }\n              if (o[0] === r) break;\n            }\n            return BigInt(null != n ? n : 0);\n          }\n          paramByEIP(e, t, r) {\n            if (!(r in l.EIPs)) throw new Error(`${r} not supported`);\n            const n = l.EIPs[r];\n            if (!(e in n)) throw new Error(`Topic ${e} not defined`);\n            if (void 0 === n[e][t]) return;\n            const o = n[e][t].v;\n            return BigInt(o);\n          }\n          paramByBlock(e, t, r, n, o) {\n            const i = this.getHardforkByBlockNumber(r, n, o);\n            return this.paramByHardfork(e, t, i);\n          }\n          isActivatedEIP(e) {\n            if (this.eips().includes(e)) return !0;\n            for (const t of this.HARDFORK_CHANGES) {\n              const r = t[1];\n              if (this.gteHardfork(r.name) && \"eips\" in r && r.eips.includes(e)) return !0;\n            }\n            return !1;\n          }\n          hardforkIsActiveOnBlock(e, t) {\n            const r = (0, a.toType)(t, s.TypeOutput.BigInt),\n              n = null != e ? e : this._hardfork,\n              o = this.hardforkBlock(n);\n            return \"bigint\" == typeof o && o !== BigInt(0) && r >= o;\n          }\n          activeOnBlock(e) {\n            return this.hardforkIsActiveOnBlock(null, e);\n          }\n          hardforkGteHardfork(e, t) {\n            const r = null != e ? e : this._hardfork,\n              n = this.hardforks();\n            let o = -1,\n              i = -1,\n              s = 0;\n            for (const e of n) e.name === r && (o = s), e.name === t && (i = s), s += 1;\n            return o >= i && -1 !== i;\n          }\n          gteHardfork(e) {\n            return this.hardforkGteHardfork(null, e);\n          }\n          hardforkBlock(e) {\n            var t;\n            const r = null != e ? e : this._hardfork,\n              n = null === (t = this._getHardfork(r)) || void 0 === t ? void 0 : t.block;\n            return null == n ? null : BigInt(n);\n          }\n          hardforkTimestamp(e) {\n            var t;\n            const r = null != e ? e : this._hardfork,\n              n = null === (t = this._getHardfork(r)) || void 0 === t ? void 0 : t.timestamp;\n            return null == n ? null : BigInt(n);\n          }\n          eipBlock(e) {\n            for (const t of this.HARDFORK_CHANGES) {\n              const r = t[1];\n              if (\"eips\" in r && r.eips.includes(e)) return this.hardforkBlock(\"number\" == typeof t[0] ? String(t[0]) : t[0]);\n            }\n            return null;\n          }\n          hardforkTTD(e) {\n            var t;\n            const r = null != e ? e : this._hardfork,\n              n = null === (t = this._getHardfork(r)) || void 0 === t ? void 0 : t.ttd;\n            return null == n ? null : BigInt(n);\n          }\n          isHardforkBlock(e, t) {\n            const r = (0, a.toType)(e, s.TypeOutput.BigInt),\n              n = null != t ? t : this._hardfork,\n              o = this.hardforkBlock(n);\n            return \"bigint\" == typeof o && o !== BigInt(0) && o === r;\n          }\n          nextHardforkBlockOrTimestamp(e) {\n            var t, r;\n            const n = null != e ? e : this._hardfork,\n              o = this.hardforks();\n            let i = o.findIndex(e => e.name === n);\n            if (n === h.Hardfork.Merge && (i -= 1), i < 0) return null;\n            let s = null !== (t = o[i].timestamp) && void 0 !== t ? t : o[i].block;\n            s = null != s ? Number(s) : null;\n            const a = o.slice(i + 1).find(e => {\n              var t;\n              let r = null !== (t = e.timestamp) && void 0 !== t ? t : e.block;\n              return r = null != r ? Number(r) : null, e.name !== h.Hardfork.Merge && null != r && r !== s;\n            });\n            if (void 0 === a) return null;\n            const c = null !== (r = a.timestamp) && void 0 !== r ? r : a.block;\n            return null == c ? null : BigInt(c);\n          }\n          nextHardforkBlock(e) {\n            const t = null != e ? e : this._hardfork;\n            let r = this.hardforkBlock(t);\n            if (null === r && t === h.Hardfork.Merge) {\n              const e = this.hardforks(),\n                t = e.findIndex(e => null !== e.ttd && void 0 !== e.ttd);\n              if (t < 0) throw Error(\"Merge hardfork should have been found\");\n              r = this.hardforkBlock(e[t - 1].name);\n            }\n            return null === r ? null : this.hardforks().reduce((e, t) => {\n              const n = BigInt(null === t.block || void 0 !== t.ttd && null !== t.ttd ? 0 : t.block);\n              return n > r && null === e ? n : e;\n            }, null);\n          }\n          isNextHardforkBlock(e, t) {\n            const r = (0, a.toType)(e, s.TypeOutput.BigInt),\n              n = null != t ? t : this._hardfork,\n              o = this.nextHardforkBlock(n);\n            return null !== o && o === r;\n          }\n          _calcForkHash(e, t) {\n            let r = new Uint8Array(),\n              n = 0;\n            for (const t of this.hardforks()) {\n              const {\n                block: o,\n                timestamp: s,\n                name: a\n              } = t;\n              let c = null != s ? s : o;\n              if (c = null !== c ? Number(c) : null, \"number\" == typeof c && 0 !== c && c !== n && a !== h.Hardfork.Merge) {\n                const e = (0, i.hexToBytes)(c.toString(16).padStart(16, \"0\"));\n                r = (0, i.uint8ArrayConcat)(r, e), n = c;\n              }\n              if (t.name === e) break;\n            }\n            const o = (0, i.uint8ArrayConcat)(t, r);\n            return (0, i.bytesToHex)((0, a.intToUint8Array)(p(o) >>> 0));\n          }\n          forkHash(e, t) {\n            const r = null != e ? e : this._hardfork,\n              n = this._getHardfork(r);\n            if (null === n || null === (null == n ? void 0 : n.block) && void 0 === (null == n ? void 0 : n.timestamp) && void 0 === (null == n ? void 0 : n.ttd)) throw new Error(\"No fork hash calculation possible for future hardfork\");\n            if (null !== (null == n ? void 0 : n.forkHash) && void 0 !== (null == n ? void 0 : n.forkHash)) return n.forkHash;\n            if (!t) throw new Error(\"genesisHash required for forkHash calculation\");\n            return this._calcForkHash(r, t);\n          }\n          hardforkForForkHash(e) {\n            const t = this.hardforks().filter(t => t.forkHash === e);\n            return t.length >= 1 ? t[t.length - 1] : null;\n          }\n          setForkHashes(e) {\n            var t;\n            for (const r of this.hardforks()) {\n              const n = null !== (t = r.timestamp) && void 0 !== t ? t : r.block;\n              null !== r.forkHash && void 0 !== r.forkHash || null == n && void 0 === r.ttd || (r.forkHash = this.forkHash(r.name, e));\n            }\n          }\n          genesis() {\n            return this._chainParams.genesis;\n          }\n          hardforks() {\n            return this._chainParams.hardforks;\n          }\n          bootstrapNodes() {\n            return this._chainParams.bootstrapNodes;\n          }\n          dnsNetworks() {\n            return this._chainParams.dnsNetworks;\n          }\n          hardfork() {\n            return this._hardfork;\n          }\n          chainId() {\n            return BigInt(this._chainParams.chainId);\n          }\n          chainName() {\n            return this._chainParams.name;\n          }\n          networkId() {\n            return BigInt(this._chainParams.networkId);\n          }\n          eips() {\n            return this._eips;\n          }\n          consensusType() {\n            const e = this.hardfork();\n            let t;\n            for (const r of this.HARDFORK_CHANGES) if (\"consensus\" in r[1] && (t = r[1].consensus.type), r[0] === e) break;\n            return null != t ? t : this._chainParams.consensus.type;\n          }\n          consensusAlgorithm() {\n            const e = this.hardfork();\n            let t;\n            for (const r of this.HARDFORK_CHANGES) if (\"consensus\" in r[1] && (t = r[1].consensus.algorithm), r[0] === e) break;\n            return null != t ? t : this._chainParams.consensus.algorithm;\n          }\n          consensusConfig() {\n            var e;\n            const t = this.hardfork();\n            let r;\n            for (const e of this.HARDFORK_CHANGES) if (\"consensus\" in e[1] && (r = e[1].consensus[e[1].consensus.algorithm]), e[0] === t) break;\n            return null !== (e = null != r ? r : this._chainParams.consensus[this.consensusAlgorithm()]) && void 0 !== e ? e : {};\n          }\n          copy() {\n            const e = Object.assign(Object.create(Object.getPrototypeOf(this)), this);\n            return e.removeAllListeners(), e;\n          }\n          static _getInitializedChains(e) {\n            const t = {};\n            for (const [e, r] of Object.entries(h.Chain)) t[r] = e.toLowerCase();\n            const r = {\n              mainnet: u.default,\n              goerli: c.default,\n              sepolia: d.default\n            };\n            if (e) for (const n of e) {\n              const {\n                name: e\n              } = n;\n              t[n.chainId.toString()] = e, r[e] = n;\n            }\n            return r.names = t, r;\n          }\n        }\n        t.Common = m;\n      },\n      2819: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-1153\",\n          number: 1153,\n          comment: \"Transient Storage\",\n          url: \"https://eips.ethereum.org/EIPS/eip-1153\",\n          status: \"Review\",\n          minimumHardfork: \"chainstart\",\n          requiredEIPs: [],\n          gasConfig: {},\n          gasPrices: {\n            tstore: {\n              v: 100,\n              d: \"Base fee of the TSTORE opcode\"\n            },\n            tload: {\n              v: 100,\n              d: \"Base fee of the TLOAD opcode\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      4013: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-1559\",\n          number: 1559,\n          comment: \"Fee market change for ETH 1.0 chain\",\n          url: \"https://eips.ethereum.org/EIPS/eip-1559\",\n          status: \"Final\",\n          minimumHardfork: \"berlin\",\n          requiredEIPs: [2930],\n          gasConfig: {\n            baseFeeMaxChangeDenominator: {\n              v: 8,\n              d: \"Maximum base fee change denominator\"\n            },\n            elasticityMultiplier: {\n              v: 2,\n              d: \"Maximum block gas target elasticity\"\n            },\n            initialBaseFee: {\n              v: 1e9,\n              d: \"Initial base fee on first EIP1559 block\"\n            }\n          },\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      1933: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-2315\",\n          number: 2315,\n          comment: \"Simple subroutines for the EVM\",\n          url: \"https://eips.ethereum.org/EIPS/eip-2315\",\n          status: \"Draft\",\n          minimumHardfork: \"istanbul\",\n          gasConfig: {},\n          gasPrices: {\n            beginsub: {\n              v: 2,\n              d: \"Base fee of the BEGINSUB opcode\"\n            },\n            returnsub: {\n              v: 5,\n              d: \"Base fee of the RETURNSUB opcode\"\n            },\n            jumpsub: {\n              v: 10,\n              d: \"Base fee of the JUMPSUB opcode\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      4638: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-2537\",\n          number: 2537,\n          comment: \"BLS12-381 precompiles\",\n          url: \"https://eips.ethereum.org/EIPS/eip-2537\",\n          status: \"Draft\",\n          minimumHardfork: \"chainstart\",\n          gasConfig: {},\n          gasPrices: {\n            Bls12381G1AddGas: {\n              v: 600,\n              d: \"Gas cost of a single BLS12-381 G1 addition precompile-call\"\n            },\n            Bls12381G1MulGas: {\n              v: 12e3,\n              d: \"Gas cost of a single BLS12-381 G1 multiplication precompile-call\"\n            },\n            Bls12381G2AddGas: {\n              v: 4500,\n              d: \"Gas cost of a single BLS12-381 G2 addition precompile-call\"\n            },\n            Bls12381G2MulGas: {\n              v: 55e3,\n              d: \"Gas cost of a single BLS12-381 G2 multiplication precompile-call\"\n            },\n            Bls12381PairingBaseGas: {\n              v: 115e3,\n              d: \"Base gas cost of BLS12-381 pairing check\"\n            },\n            Bls12381PairingPerPairGas: {\n              v: 23e3,\n              d: \"Per-pair gas cost of BLS12-381 pairing check\"\n            },\n            Bls12381MapG1Gas: {\n              v: 5500,\n              d: \"Gas cost of BLS12-381 map field element to G1\"\n            },\n            Bls12381MapG2Gas: {\n              v: 11e4,\n              d: \"Gas cost of BLS12-381 map field element to G2\"\n            },\n            Bls12381MultiExpGasDiscount: {\n              v: [[1, 1200], [2, 888], [3, 764], [4, 641], [5, 594], [6, 547], [7, 500], [8, 453], [9, 438], [10, 423], [11, 408], [12, 394], [13, 379], [14, 364], [15, 349], [16, 334], [17, 330], [18, 326], [19, 322], [20, 318], [21, 314], [22, 310], [23, 306], [24, 302], [25, 298], [26, 294], [27, 289], [28, 285], [29, 281], [30, 277], [31, 273], [32, 269], [33, 268], [34, 266], [35, 265], [36, 263], [37, 262], [38, 260], [39, 259], [40, 257], [41, 256], [42, 254], [43, 253], [44, 251], [45, 250], [46, 248], [47, 247], [48, 245], [49, 244], [50, 242], [51, 241], [52, 239], [53, 238], [54, 236], [55, 235], [56, 233], [57, 232], [58, 231], [59, 229], [60, 228], [61, 226], [62, 225], [63, 223], [64, 222], [65, 221], [66, 220], [67, 219], [68, 219], [69, 218], [70, 217], [71, 216], [72, 216], [73, 215], [74, 214], [75, 213], [76, 213], [77, 212], [78, 211], [79, 211], [80, 210], [81, 209], [82, 208], [83, 208], [84, 207], [85, 206], [86, 205], [87, 205], [88, 204], [89, 203], [90, 202], [91, 202], [92, 201], [93, 200], [94, 199], [95, 199], [96, 198], [97, 197], [98, 196], [99, 196], [100, 195], [101, 194], [102, 193], [103, 193], [104, 192], [105, 191], [106, 191], [107, 190], [108, 189], [109, 188], [110, 188], [111, 187], [112, 186], [113, 185], [114, 185], [115, 184], [116, 183], [117, 182], [118, 182], [119, 181], [120, 180], [121, 179], [122, 179], [123, 178], [124, 177], [125, 176], [126, 176], [127, 175], [128, 174]],\n              d: \"Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      6906: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-2565\",\n          number: 2565,\n          comment: \"ModExp gas cost\",\n          url: \"https://eips.ethereum.org/EIPS/eip-2565\",\n          status: \"Final\",\n          minimumHardfork: \"byzantium\",\n          gasConfig: {},\n          gasPrices: {\n            modexpGquaddivisor: {\n              v: 3,\n              d: \"Gquaddivisor from modexp precompile for gas calculation\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      3399: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-2718\",\n          comment: \"Typed Transaction Envelope\",\n          url: \"https://eips.ethereum.org/EIPS/eip-2718\",\n          status: \"Final\",\n          minimumHardfork: \"chainstart\",\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      7387: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-2929\",\n          comment: \"Gas cost increases for state access opcodes\",\n          url: \"https://eips.ethereum.org/EIPS/eip-2929\",\n          status: \"Final\",\n          minimumHardfork: \"chainstart\",\n          gasConfig: {},\n          gasPrices: {\n            coldsload: {\n              v: 2100,\n              d: \"Gas cost of the first read of storage from a given location (per transaction)\"\n            },\n            coldaccountaccess: {\n              v: 2600,\n              d: \"Gas cost of the first read of a given address (per transaction)\"\n            },\n            warmstorageread: {\n              v: 100,\n              d: \"Gas cost of reading storage locations which have already loaded 'cold'\"\n            },\n            sstoreCleanGasEIP2200: {\n              v: 2900,\n              d: \"Once per SSTORE operation from clean non-zero to something else\"\n            },\n            sstoreNoopGasEIP2200: {\n              v: 100,\n              d: \"Once per SSTORE operation if the value doesn't change\"\n            },\n            sstoreDirtyGasEIP2200: {\n              v: 100,\n              d: \"Once per SSTORE operation if a dirty value is changed\"\n            },\n            sstoreInitRefundEIP2200: {\n              v: 19900,\n              d: \"Once per SSTORE operation for resetting to the original zero value\"\n            },\n            sstoreCleanRefundEIP2200: {\n              v: 4900,\n              d: \"Once per SSTORE operation for resetting to the original non-zero value\"\n            },\n            call: {\n              v: 0,\n              d: \"Base fee of the CALL opcode\"\n            },\n            callcode: {\n              v: 0,\n              d: \"Base fee of the CALLCODE opcode\"\n            },\n            delegatecall: {\n              v: 0,\n              d: \"Base fee of the DELEGATECALL opcode\"\n            },\n            staticcall: {\n              v: 0,\n              d: \"Base fee of the STATICCALL opcode\"\n            },\n            balance: {\n              v: 0,\n              d: \"Base fee of the BALANCE opcode\"\n            },\n            extcodesize: {\n              v: 0,\n              d: \"Base fee of the EXTCODESIZE opcode\"\n            },\n            extcodecopy: {\n              v: 0,\n              d: \"Base fee of the EXTCODECOPY opcode\"\n            },\n            extcodehash: {\n              v: 0,\n              d: \"Base fee of the EXTCODEHASH opcode\"\n            },\n            sload: {\n              v: 0,\n              d: \"Base fee of the SLOAD opcode\"\n            },\n            sstore: {\n              v: 0,\n              d: \"Base fee of the SSTORE opcode\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      6299: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-2930\",\n          comment: \"Optional access lists\",\n          url: \"https://eips.ethereum.org/EIPS/eip-2930\",\n          status: \"Final\",\n          minimumHardfork: \"istanbul\",\n          requiredEIPs: [2718, 2929],\n          gasConfig: {},\n          gasPrices: {\n            accessListStorageKeyCost: {\n              v: 1900,\n              d: \"Gas cost per storage key in an Access List transaction\"\n            },\n            accessListAddressCost: {\n              v: 2400,\n              d: \"Gas cost per storage key in an Access List transaction\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      1073: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3198\",\n          number: 3198,\n          comment: \"BASEFEE opcode\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3198\",\n          status: \"Final\",\n          minimumHardfork: \"london\",\n          gasConfig: {},\n          gasPrices: {\n            basefee: {\n              v: 2,\n              d: \"Gas cost of the BASEFEE opcode\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      634: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3529\",\n          comment: \"Reduction in refunds\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3529\",\n          status: \"Final\",\n          minimumHardfork: \"berlin\",\n          requiredEIPs: [2929],\n          gasConfig: {\n            maxRefundQuotient: {\n              v: 5,\n              d: \"Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)\"\n            }\n          },\n          gasPrices: {\n            selfdestructRefund: {\n              v: 0,\n              d: \"Refunded following a selfdestruct operation\"\n            },\n            sstoreClearRefundEIP2200: {\n              v: 4800,\n              d: \"Once per SSTORE operation for clearing an originally existing storage slot\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      3829: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3540\",\n          number: 3540,\n          comment: \"EVM Object Format (EOF) v1\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3540\",\n          status: \"Review\",\n          minimumHardfork: \"london\",\n          requiredEIPs: [3541],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      5729: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3541\",\n          comment: \"Reject new contracts starting with the 0xEF byte\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3541\",\n          status: \"Final\",\n          minimumHardfork: \"berlin\",\n          requiredEIPs: [],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      8958: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3554\",\n          comment: \"Reduction in refunds\",\n          url: \"Difficulty Bomb Delay to December 1st 2021\",\n          status: \"Final\",\n          minimumHardfork: \"muirGlacier\",\n          requiredEIPs: [],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {\n            difficultyBombDelay: {\n              v: 95e5,\n              d: \"the amount of blocks to delay the difficulty bomb with\"\n            }\n          }\n        };\n      },\n      8334: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3607\",\n          number: 3607,\n          comment: \"Reject transactions from senders with deployed code\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3607\",\n          status: \"Final\",\n          minimumHardfork: \"chainstart\",\n          requiredEIPs: [],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      3412: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3651\",\n          number: 3198,\n          comment: \"Warm COINBASE\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3651\",\n          status: \"Review\",\n          minimumHardfork: \"london\",\n          requiredEIPs: [2929],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      6337: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3670\",\n          number: 3670,\n          comment: \"EOF - Code Validation\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3670\",\n          status: \"Review\",\n          minimumHardfork: \"london\",\n          requiredEIPs: [3540],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      2610: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3675\",\n          number: 3675,\n          comment: \"Upgrade consensus to Proof-of-Stake\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3675\",\n          status: \"Final\",\n          minimumHardfork: \"london\",\n          requiredEIPs: [],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      7619: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3855\",\n          number: 3855,\n          comment: \"PUSH0 instruction\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3855\",\n          status: \"Review\",\n          minimumHardfork: \"chainstart\",\n          requiredEIPs: [],\n          gasConfig: {},\n          gasPrices: {\n            push0: {\n              v: 2,\n              d: \"Base fee of the PUSH0 opcode\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      8018: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3860\",\n          number: 3860,\n          comment: \"Limit and meter initcode\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3860\",\n          status: \"Review\",\n          minimumHardfork: \"spuriousDragon\",\n          requiredEIPs: [],\n          gasConfig: {},\n          gasPrices: {\n            initCodeWordCost: {\n              v: 2,\n              d: \"Gas to pay for each word (32 bytes) of initcode when creating a contract\"\n            }\n          },\n          vm: {\n            maxInitCodeSize: {\n              v: 49152,\n              d: \"Maximum length of initialization code when creating a contract\"\n            }\n          },\n          pow: {}\n        };\n      },\n      6779: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-4345\",\n          number: 4345,\n          comment: \"Difficulty Bomb Delay to June 2022\",\n          url: \"https://eips.ethereum.org/EIPS/eip-4345\",\n          status: \"Final\",\n          minimumHardfork: \"london\",\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {\n            difficultyBombDelay: {\n              v: 107e5,\n              d: \"the amount of blocks to delay the difficulty bomb with\"\n            }\n          }\n        };\n      },\n      623: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-4399\",\n          number: 4399,\n          comment: \"Supplant DIFFICULTY opcode with PREVRANDAO\",\n          url: \"https://eips.ethereum.org/EIPS/eip-4399\",\n          status: \"Review\",\n          minimumHardfork: \"london\",\n          requiredEIPs: [],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      797: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-5133\",\n          number: 5133,\n          comment: \"Delaying Difficulty Bomb to mid-September 2022\",\n          url: \"https://eips.ethereum.org/EIPS/eip-5133\",\n          status: \"Draft\",\n          minimumHardfork: \"grayGlacier\",\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {\n            difficultyBombDelay: {\n              v: 114e5,\n              d: \"the amount of blocks to delay the difficulty bomb with\"\n            }\n          }\n        };\n      },\n      5257: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.EIPs = void 0;\n        const o = n(r(2819)),\n          i = n(r(4013)),\n          s = n(r(1933)),\n          a = n(r(4638)),\n          c = n(r(6906)),\n          u = n(r(3399)),\n          d = n(r(7387)),\n          l = n(r(6299)),\n          h = n(r(1073)),\n          f = n(r(634)),\n          p = n(r(3829)),\n          m = n(r(5729)),\n          g = n(r(8958)),\n          y = n(r(8334)),\n          v = n(r(3412)),\n          b = n(r(6337)),\n          E = n(r(2610)),\n          _ = n(r(7619)),\n          A = n(r(8018)),\n          T = n(r(6779)),\n          w = n(r(623)),\n          I = n(r(797));\n        t.EIPs = {\n          1153: o.default,\n          1559: i.default,\n          2315: s.default,\n          2537: a.default,\n          2565: c.default,\n          2718: u.default,\n          2929: d.default,\n          2930: l.default,\n          3198: h.default,\n          3529: f.default,\n          3540: p.default,\n          3541: m.default,\n          3554: g.default,\n          3607: y.default,\n          3651: v.default,\n          3670: b.default,\n          3675: E.default,\n          3855: _.default,\n          3860: A.default,\n          4345: T.default,\n          4399: w.default,\n          5133: I.default\n        };\n      },\n      4443: (e, t) => {\n        \"use strict\";\n\n        var r, n, o, i, s;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.CustomChain = t.ConsensusAlgorithm = t.ConsensusType = t.Hardfork = t.Chain = void 0, (s = t.Chain || (t.Chain = {}))[s.Mainnet = 1] = \"Mainnet\", s[s.Goerli = 5] = \"Goerli\", s[s.Sepolia = 11155111] = \"Sepolia\", (i = t.Hardfork || (t.Hardfork = {})).Chainstart = \"chainstart\", i.Homestead = \"homestead\", i.Dao = \"dao\", i.TangerineWhistle = \"tangerineWhistle\", i.SpuriousDragon = \"spuriousDragon\", i.Byzantium = \"byzantium\", i.Constantinople = \"constantinople\", i.Petersburg = \"petersburg\", i.Istanbul = \"istanbul\", i.MuirGlacier = \"muirGlacier\", i.Berlin = \"berlin\", i.London = \"london\", i.ArrowGlacier = \"arrowGlacier\", i.GrayGlacier = \"grayGlacier\", i.MergeForkIdTransition = \"mergeForkIdTransition\", i.Merge = \"merge\", i.Shanghai = \"shanghai\", i.ShardingForkDev = \"shardingFork\", (o = t.ConsensusType || (t.ConsensusType = {})).ProofOfStake = \"pos\", o.ProofOfWork = \"pow\", o.ProofOfAuthority = \"poa\", (n = t.ConsensusAlgorithm || (t.ConsensusAlgorithm = {})).Ethash = \"ethash\", n.Clique = \"clique\", n.Casper = \"casper\", (r = t.CustomChain || (t.CustomChain = {})).PolygonMainnet = \"polygon-mainnet\", r.PolygonMumbai = \"polygon-mumbai\", r.ArbitrumRinkebyTestnet = \"arbitrum-rinkeby-testnet\", r.ArbitrumOne = \"arbitrum-one\", r.xDaiChain = \"x-dai-chain\", r.OptimisticKovan = \"optimistic-kovan\", r.OptimisticEthereum = \"optimistic-ethereum\";\n      },\n      3923: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"arrowGlacier\",\n          comment: \"HF to delay the difficulty bomb\",\n          url: \"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md\",\n          status: \"Final\",\n          eips: [4345],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      9126: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"berlin\",\n          comment: \"HF targeted for July 2020 following the Muir Glacier HF\",\n          url: \"https://eips.ethereum.org/EIPS/eip-2070\",\n          status: \"Final\",\n          eips: [2565, 2929, 2718, 2930]\n        };\n      },\n      7251: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"byzantium\",\n          comment: \"Hardfork with new precompiles, instructions and other protocol changes\",\n          url: \"https://eips.ethereum.org/EIPS/eip-609\",\n          status: \"Final\",\n          gasConfig: {},\n          gasPrices: {\n            modexpGquaddivisor: {\n              v: 20,\n              d: \"Gquaddivisor from modexp precompile for gas calculation\"\n            },\n            ecAdd: {\n              v: 500,\n              d: \"Gas costs for curve addition precompile\"\n            },\n            ecMul: {\n              v: 4e4,\n              d: \"Gas costs for curve multiplication precompile\"\n            },\n            ecPairing: {\n              v: 1e5,\n              d: \"Base gas costs for curve pairing precompile\"\n            },\n            ecPairingWord: {\n              v: 8e4,\n              d: \"Gas costs regarding curve pairing precompile input length\"\n            },\n            revert: {\n              v: 0,\n              d: \"Base fee of the REVERT opcode\"\n            },\n            staticcall: {\n              v: 700,\n              d: \"Base fee of the STATICCALL opcode\"\n            },\n            returndatasize: {\n              v: 2,\n              d: \"Base fee of the RETURNDATASIZE opcode\"\n            },\n            returndatacopy: {\n              v: 3,\n              d: \"Base fee of the RETURNDATACOPY opcode\"\n            }\n          },\n          vm: {},\n          pow: {\n            minerReward: {\n              v: \"3000000000000000000\",\n              d: \"the amount a miner get rewarded for mining a block\"\n            },\n            difficultyBombDelay: {\n              v: 3e6,\n              d: \"the amount of blocks to delay the difficulty bomb with\"\n            }\n          }\n        };\n      },\n      9454: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"chainstart\",\n          comment: \"Start of the Ethereum main chain\",\n          url: \"\",\n          status: \"\",\n          gasConfig: {\n            minGasLimit: {\n              v: 5e3,\n              d: \"Minimum the gas limit may ever be\"\n            },\n            gasLimitBoundDivisor: {\n              v: 1024,\n              d: \"The bound divisor of the gas limit, used in update calculations\"\n            },\n            maxRefundQuotient: {\n              v: 2,\n              d: \"Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)\"\n            }\n          },\n          gasPrices: {\n            base: {\n              v: 2,\n              d: \"Gas base cost, used e.g. for ChainID opcode (Istanbul)\"\n            },\n            tierStep: {\n              v: [0, 2, 3, 5, 8, 10, 20],\n              d: \"Once per operation, for a selection of them\"\n            },\n            exp: {\n              v: 10,\n              d: \"Base fee of the EXP opcode\"\n            },\n            expByte: {\n              v: 10,\n              d: \"Times ceil(log256(exponent)) for the EXP instruction\"\n            },\n            sha3: {\n              v: 30,\n              d: \"Base fee of the SHA3 opcode\"\n            },\n            sha3Word: {\n              v: 6,\n              d: \"Once per word of the SHA3 operation's data\"\n            },\n            sload: {\n              v: 50,\n              d: \"Base fee of the SLOAD opcode\"\n            },\n            sstoreSet: {\n              v: 2e4,\n              d: \"Once per SSTORE operation if the zeroness changes from zero\"\n            },\n            sstoreReset: {\n              v: 5e3,\n              d: \"Once per SSTORE operation if the zeroness does not change from zero\"\n            },\n            sstoreRefund: {\n              v: 15e3,\n              d: \"Once per SSTORE operation if the zeroness changes to zero\"\n            },\n            jumpdest: {\n              v: 1,\n              d: \"Base fee of the JUMPDEST opcode\"\n            },\n            log: {\n              v: 375,\n              d: \"Base fee of the LOG opcode\"\n            },\n            logData: {\n              v: 8,\n              d: \"Per byte in a LOG* operation's data\"\n            },\n            logTopic: {\n              v: 375,\n              d: \"Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas\"\n            },\n            create: {\n              v: 32e3,\n              d: \"Base fee of the CREATE opcode\"\n            },\n            call: {\n              v: 40,\n              d: \"Base fee of the CALL opcode\"\n            },\n            callStipend: {\n              v: 2300,\n              d: \"Free gas given at beginning of call\"\n            },\n            callValueTransfer: {\n              v: 9e3,\n              d: \"Paid for CALL when the value transfor is non-zero\"\n            },\n            callNewAccount: {\n              v: 25e3,\n              d: \"Paid for CALL when the destination address didn't exist prior\"\n            },\n            selfdestructRefund: {\n              v: 24e3,\n              d: \"Refunded following a selfdestruct operation\"\n            },\n            memory: {\n              v: 3,\n              d: \"Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL\"\n            },\n            quadCoeffDiv: {\n              v: 512,\n              d: \"Divisor for the quadratic particle of the memory cost equation\"\n            },\n            createData: {\n              v: 200,\n              d: \"\"\n            },\n            tx: {\n              v: 21e3,\n              d: \"Per transaction. NOTE: Not payable on data of calls between transactions\"\n            },\n            txCreation: {\n              v: 32e3,\n              d: \"The cost of creating a contract via tx\"\n            },\n            txDataZero: {\n              v: 4,\n              d: \"Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions\"\n            },\n            txDataNonZero: {\n              v: 68,\n              d: \"Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions\"\n            },\n            copy: {\n              v: 3,\n              d: \"Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added\"\n            },\n            ecRecover: {\n              v: 3e3,\n              d: \"\"\n            },\n            sha256: {\n              v: 60,\n              d: \"\"\n            },\n            sha256Word: {\n              v: 12,\n              d: \"\"\n            },\n            ripemd160: {\n              v: 600,\n              d: \"\"\n            },\n            ripemd160Word: {\n              v: 120,\n              d: \"\"\n            },\n            identity: {\n              v: 15,\n              d: \"\"\n            },\n            identityWord: {\n              v: 3,\n              d: \"\"\n            },\n            stop: {\n              v: 0,\n              d: \"Base fee of the STOP opcode\"\n            },\n            add: {\n              v: 3,\n              d: \"Base fee of the ADD opcode\"\n            },\n            mul: {\n              v: 5,\n              d: \"Base fee of the MUL opcode\"\n            },\n            sub: {\n              v: 3,\n              d: \"Base fee of the SUB opcode\"\n            },\n            div: {\n              v: 5,\n              d: \"Base fee of the DIV opcode\"\n            },\n            sdiv: {\n              v: 5,\n              d: \"Base fee of the SDIV opcode\"\n            },\n            mod: {\n              v: 5,\n              d: \"Base fee of the MOD opcode\"\n            },\n            smod: {\n              v: 5,\n              d: \"Base fee of the SMOD opcode\"\n            },\n            addmod: {\n              v: 8,\n              d: \"Base fee of the ADDMOD opcode\"\n            },\n            mulmod: {\n              v: 8,\n              d: \"Base fee of the MULMOD opcode\"\n            },\n            signextend: {\n              v: 5,\n              d: \"Base fee of the SIGNEXTEND opcode\"\n            },\n            lt: {\n              v: 3,\n              d: \"Base fee of the LT opcode\"\n            },\n            gt: {\n              v: 3,\n              d: \"Base fee of the GT opcode\"\n            },\n            slt: {\n              v: 3,\n              d: \"Base fee of the SLT opcode\"\n            },\n            sgt: {\n              v: 3,\n              d: \"Base fee of the SGT opcode\"\n            },\n            eq: {\n              v: 3,\n              d: \"Base fee of the EQ opcode\"\n            },\n            iszero: {\n              v: 3,\n              d: \"Base fee of the ISZERO opcode\"\n            },\n            and: {\n              v: 3,\n              d: \"Base fee of the AND opcode\"\n            },\n            or: {\n              v: 3,\n              d: \"Base fee of the OR opcode\"\n            },\n            xor: {\n              v: 3,\n              d: \"Base fee of the XOR opcode\"\n            },\n            not: {\n              v: 3,\n              d: \"Base fee of the NOT opcode\"\n            },\n            byte: {\n              v: 3,\n              d: \"Base fee of the BYTE opcode\"\n            },\n            address: {\n              v: 2,\n              d: \"Base fee of the ADDRESS opcode\"\n            },\n            balance: {\n              v: 20,\n              d: \"Base fee of the BALANCE opcode\"\n            },\n            origin: {\n              v: 2,\n              d: \"Base fee of the ORIGIN opcode\"\n            },\n            caller: {\n              v: 2,\n              d: \"Base fee of the CALLER opcode\"\n            },\n            callvalue: {\n              v: 2,\n              d: \"Base fee of the CALLVALUE opcode\"\n            },\n            calldataload: {\n              v: 3,\n              d: \"Base fee of the CALLDATALOAD opcode\"\n            },\n            calldatasize: {\n              v: 2,\n              d: \"Base fee of the CALLDATASIZE opcode\"\n            },\n            calldatacopy: {\n              v: 3,\n              d: \"Base fee of the CALLDATACOPY opcode\"\n            },\n            codesize: {\n              v: 2,\n              d: \"Base fee of the CODESIZE opcode\"\n            },\n            codecopy: {\n              v: 3,\n              d: \"Base fee of the CODECOPY opcode\"\n            },\n            gasprice: {\n              v: 2,\n              d: \"Base fee of the GASPRICE opcode\"\n            },\n            extcodesize: {\n              v: 20,\n              d: \"Base fee of the EXTCODESIZE opcode\"\n            },\n            extcodecopy: {\n              v: 20,\n              d: \"Base fee of the EXTCODECOPY opcode\"\n            },\n            blockhash: {\n              v: 20,\n              d: \"Base fee of the BLOCKHASH opcode\"\n            },\n            coinbase: {\n              v: 2,\n              d: \"Base fee of the COINBASE opcode\"\n            },\n            timestamp: {\n              v: 2,\n              d: \"Base fee of the TIMESTAMP opcode\"\n            },\n            number: {\n              v: 2,\n              d: \"Base fee of the NUMBER opcode\"\n            },\n            difficulty: {\n              v: 2,\n              d: \"Base fee of the DIFFICULTY opcode\"\n            },\n            gaslimit: {\n              v: 2,\n              d: \"Base fee of the GASLIMIT opcode\"\n            },\n            pop: {\n              v: 2,\n              d: \"Base fee of the POP opcode\"\n            },\n            mload: {\n              v: 3,\n              d: \"Base fee of the MLOAD opcode\"\n            },\n            mstore: {\n              v: 3,\n              d: \"Base fee of the MSTORE opcode\"\n            },\n            mstore8: {\n              v: 3,\n              d: \"Base fee of the MSTORE8 opcode\"\n            },\n            sstore: {\n              v: 0,\n              d: \"Base fee of the SSTORE opcode\"\n            },\n            jump: {\n              v: 8,\n              d: \"Base fee of the JUMP opcode\"\n            },\n            jumpi: {\n              v: 10,\n              d: \"Base fee of the JUMPI opcode\"\n            },\n            pc: {\n              v: 2,\n              d: \"Base fee of the PC opcode\"\n            },\n            msize: {\n              v: 2,\n              d: \"Base fee of the MSIZE opcode\"\n            },\n            gas: {\n              v: 2,\n              d: \"Base fee of the GAS opcode\"\n            },\n            push: {\n              v: 3,\n              d: \"Base fee of the PUSH opcode\"\n            },\n            dup: {\n              v: 3,\n              d: \"Base fee of the DUP opcode\"\n            },\n            swap: {\n              v: 3,\n              d: \"Base fee of the SWAP opcode\"\n            },\n            callcode: {\n              v: 40,\n              d: \"Base fee of the CALLCODE opcode\"\n            },\n            return: {\n              v: 0,\n              d: \"Base fee of the RETURN opcode\"\n            },\n            invalid: {\n              v: 0,\n              d: \"Base fee of the INVALID opcode\"\n            },\n            selfdestruct: {\n              v: 0,\n              d: \"Base fee of the SELFDESTRUCT opcode\"\n            }\n          },\n          vm: {\n            stackLimit: {\n              v: 1024,\n              d: \"Maximum size of VM stack allowed\"\n            },\n            callCreateDepth: {\n              v: 1024,\n              d: \"Maximum depth of call/create stack\"\n            },\n            maxExtraDataSize: {\n              v: 32,\n              d: \"Maximum size extra data may be after Genesis\"\n            }\n          },\n          pow: {\n            minimumDifficulty: {\n              v: 131072,\n              d: \"The minimum that the difficulty may ever be\"\n            },\n            difficultyBoundDivisor: {\n              v: 2048,\n              d: \"The bound divisor of the difficulty, used in the update calculations\"\n            },\n            durationLimit: {\n              v: 13,\n              d: \"The decision boundary on the blocktime duration used to determine whether difficulty should go up or not\"\n            },\n            epochDuration: {\n              v: 3e4,\n              d: \"Duration between proof-of-work epochs\"\n            },\n            timebombPeriod: {\n              v: 1e5,\n              d: \"Exponential difficulty timebomb period\"\n            },\n            minerReward: {\n              v: \"5000000000000000000\",\n              d: \"the amount a miner get rewarded for mining a block\"\n            },\n            difficultyBombDelay: {\n              v: 0,\n              d: \"the amount of blocks to delay the difficulty bomb with\"\n            }\n          }\n        };\n      },\n      1353: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"constantinople\",\n          comment: \"Postponed hardfork including EIP-1283 (SSTORE gas metering changes)\",\n          url: \"https://eips.ethereum.org/EIPS/eip-1013\",\n          status: \"Final\",\n          gasConfig: {},\n          gasPrices: {\n            netSstoreNoopGas: {\n              v: 200,\n              d: \"Once per SSTORE operation if the value doesn't change\"\n            },\n            netSstoreInitGas: {\n              v: 2e4,\n              d: \"Once per SSTORE operation from clean zero\"\n            },\n            netSstoreCleanGas: {\n              v: 5e3,\n              d: \"Once per SSTORE operation from clean non-zero\"\n            },\n            netSstoreDirtyGas: {\n              v: 200,\n              d: \"Once per SSTORE operation from dirty\"\n            },\n            netSstoreClearRefund: {\n              v: 15e3,\n              d: \"Once per SSTORE operation for clearing an originally existing storage slot\"\n            },\n            netSstoreResetRefund: {\n              v: 4800,\n              d: \"Once per SSTORE operation for resetting to the original non-zero value\"\n            },\n            netSstoreResetClearRefund: {\n              v: 19800,\n              d: \"Once per SSTORE operation for resetting to the original zero value\"\n            },\n            shl: {\n              v: 3,\n              d: \"Base fee of the SHL opcode\"\n            },\n            shr: {\n              v: 3,\n              d: \"Base fee of the SHR opcode\"\n            },\n            sar: {\n              v: 3,\n              d: \"Base fee of the SAR opcode\"\n            },\n            extcodehash: {\n              v: 400,\n              d: \"Base fee of the EXTCODEHASH opcode\"\n            },\n            create2: {\n              v: 32e3,\n              d: \"Base fee of the CREATE2 opcode\"\n            }\n          },\n          vm: {},\n          pow: {\n            minerReward: {\n              v: \"2000000000000000000\",\n              d: \"The amount a miner gets rewarded for mining a block\"\n            },\n            difficultyBombDelay: {\n              v: 5e6,\n              d: \"the amount of blocks to delay the difficulty bomb with\"\n            }\n          }\n        };\n      },\n      3810: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"dao\",\n          comment: \"DAO rescue hardfork\",\n          url: \"https://eips.ethereum.org/EIPS/eip-779\",\n          status: \"Final\",\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      6257: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"grayGlacier\",\n          comment: \"Delaying the difficulty bomb to Mid September 2022\",\n          url: \"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md\",\n          status: \"Draft\",\n          eips: [5133],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      7446: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"homestead\",\n          comment: \"Homestead hardfork with protocol and network changes\",\n          url: \"https://eips.ethereum.org/EIPS/eip-606\",\n          status: \"Final\",\n          gasConfig: {},\n          gasPrices: {\n            delegatecall: {\n              v: 40,\n              d: \"Base fee of the DELEGATECALL opcode\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      9137: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.hardforks = void 0;\n        const o = n(r(9454)),\n          i = n(r(3810)),\n          s = n(r(7446)),\n          a = n(r(7458)),\n          c = n(r(2546)),\n          u = n(r(7251)),\n          d = n(r(1353)),\n          l = n(r(5338)),\n          h = n(r(9597)),\n          f = n(r(7931)),\n          p = n(r(9126)),\n          m = n(r(1233)),\n          g = n(r(2761)),\n          y = n(r(3923)),\n          v = n(r(6257)),\n          b = n(r(6697)),\n          E = n(r(6668));\n        t.hardforks = {\n          chainstart: o.default,\n          homestead: s.default,\n          dao: i.default,\n          tangerineWhistle: a.default,\n          spuriousDragon: c.default,\n          byzantium: u.default,\n          constantinople: d.default,\n          petersburg: l.default,\n          istanbul: h.default,\n          muirGlacier: f.default,\n          berlin: p.default,\n          london: m.default,\n          shanghai: g.default,\n          arrowGlacier: y.default,\n          grayGlacier: v.default,\n          mergeForkIdTransition: b.default,\n          merge: E.default\n        };\n      },\n      9597: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"istanbul\",\n          comment: \"HF targeted for December 2019 following the Constantinople/Petersburg HF\",\n          url: \"https://eips.ethereum.org/EIPS/eip-1679\",\n          status: \"Final\",\n          gasConfig: {},\n          gasPrices: {\n            blake2Round: {\n              v: 1,\n              d: \"Gas cost per round for the Blake2 F precompile\"\n            },\n            ecAdd: {\n              v: 150,\n              d: \"Gas costs for curve addition precompile\"\n            },\n            ecMul: {\n              v: 6e3,\n              d: \"Gas costs for curve multiplication precompile\"\n            },\n            ecPairing: {\n              v: 45e3,\n              d: \"Base gas costs for curve pairing precompile\"\n            },\n            ecPairingWord: {\n              v: 34e3,\n              d: \"Gas costs regarding curve pairing precompile input length\"\n            },\n            txDataNonZero: {\n              v: 16,\n              d: \"Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions\"\n            },\n            sstoreSentryGasEIP2200: {\n              v: 2300,\n              d: \"Minimum gas required to be present for an SSTORE call, not consumed\"\n            },\n            sstoreNoopGasEIP2200: {\n              v: 800,\n              d: \"Once per SSTORE operation if the value doesn't change\"\n            },\n            sstoreDirtyGasEIP2200: {\n              v: 800,\n              d: \"Once per SSTORE operation if a dirty value is changed\"\n            },\n            sstoreInitGasEIP2200: {\n              v: 2e4,\n              d: \"Once per SSTORE operation from clean zero to non-zero\"\n            },\n            sstoreInitRefundEIP2200: {\n              v: 19200,\n              d: \"Once per SSTORE operation for resetting to the original zero value\"\n            },\n            sstoreCleanGasEIP2200: {\n              v: 5e3,\n              d: \"Once per SSTORE operation from clean non-zero to something else\"\n            },\n            sstoreCleanRefundEIP2200: {\n              v: 4200,\n              d: \"Once per SSTORE operation for resetting to the original non-zero value\"\n            },\n            sstoreClearRefundEIP2200: {\n              v: 15e3,\n              d: \"Once per SSTORE operation for clearing an originally existing storage slot\"\n            },\n            balance: {\n              v: 700,\n              d: \"Base fee of the BALANCE opcode\"\n            },\n            extcodehash: {\n              v: 700,\n              d: \"Base fee of the EXTCODEHASH opcode\"\n            },\n            chainid: {\n              v: 2,\n              d: \"Base fee of the CHAINID opcode\"\n            },\n            selfbalance: {\n              v: 5,\n              d: \"Base fee of the SELFBALANCE opcode\"\n            },\n            sload: {\n              v: 800,\n              d: \"Base fee of the SLOAD opcode\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      1233: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"london\",\n          comment: \"HF targeted for July 2021 following the Berlin fork\",\n          url: \"https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md\",\n          status: \"Final\",\n          eips: [1559, 3198, 3529, 3541]\n        };\n      },\n      6668: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"merge\",\n          comment: \"Hardfork to upgrade the consensus mechanism to Proof-of-Stake\",\n          url: \"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md\",\n          status: \"Final\",\n          consensus: {\n            type: \"pos\",\n            algorithm: \"casper\",\n            casper: {}\n          },\n          eips: [3675, 4399]\n        };\n      },\n      6697: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"mergeForkIdTransition\",\n          comment: \"Pre-merge hardfork to fork off non-upgraded clients\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3675\",\n          status: \"Draft\",\n          eips: []\n        };\n      },\n      7931: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"muirGlacier\",\n          comment: \"HF to delay the difficulty bomb\",\n          url: \"https://eips.ethereum.org/EIPS/eip-2384\",\n          status: \"Final\",\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {\n            difficultyBombDelay: {\n              v: 9e6,\n              d: \"the amount of blocks to delay the difficulty bomb with\"\n            }\n          }\n        };\n      },\n      5338: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"petersburg\",\n          comment: \"Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople\",\n          url: \"https://eips.ethereum.org/EIPS/eip-1716\",\n          status: \"Final\",\n          gasConfig: {},\n          gasPrices: {\n            netSstoreNoopGas: {\n              v: null,\n              d: \"Removed along EIP-1283\"\n            },\n            netSstoreInitGas: {\n              v: null,\n              d: \"Removed along EIP-1283\"\n            },\n            netSstoreCleanGas: {\n              v: null,\n              d: \"Removed along EIP-1283\"\n            },\n            netSstoreDirtyGas: {\n              v: null,\n              d: \"Removed along EIP-1283\"\n            },\n            netSstoreClearRefund: {\n              v: null,\n              d: \"Removed along EIP-1283\"\n            },\n            netSstoreResetRefund: {\n              v: null,\n              d: \"Removed along EIP-1283\"\n            },\n            netSstoreResetClearRefund: {\n              v: null,\n              d: \"Removed along EIP-1283\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      2761: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"shanghai\",\n          comment: \"Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode\",\n          url: \"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md\",\n          status: \"Final\",\n          eips: [3651, 3855, 3860, 4895]\n        };\n      },\n      2546: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"spuriousDragon\",\n          comment: \"HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit\",\n          url: \"https://eips.ethereum.org/EIPS/eip-607\",\n          status: \"Final\",\n          gasConfig: {},\n          gasPrices: {\n            expByte: {\n              v: 50,\n              d: \"Times ceil(log256(exponent)) for the EXP instruction\"\n            }\n          },\n          vm: {\n            maxCodeSize: {\n              v: 24576,\n              d: \"Maximum length of contract code\"\n            }\n          },\n          pow: {}\n        };\n      },\n      7458: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"tangerineWhistle\",\n          comment: \"Hardfork with gas cost changes for IO-heavy operations\",\n          url: \"https://eips.ethereum.org/EIPS/eip-608\",\n          status: \"Final\",\n          gasConfig: {},\n          gasPrices: {\n            sload: {\n              v: 200,\n              d: \"Once per SLOAD operation\"\n            },\n            call: {\n              v: 700,\n              d: \"Once per CALL operation & message call transaction\"\n            },\n            extcodesize: {\n              v: 700,\n              d: \"Base fee of the EXTCODESIZE opcode\"\n            },\n            extcodecopy: {\n              v: 700,\n              d: \"Base fee of the EXTCODECOPY opcode\"\n            },\n            balance: {\n              v: 400,\n              d: \"Base fee of the BALANCE opcode\"\n            },\n            delegatecall: {\n              v: 700,\n              d: \"Base fee of the DELEGATECALL opcode\"\n            },\n            callcode: {\n              v: 700,\n              d: \"Base fee of the CALLCODE opcode\"\n            },\n            selfdestruct: {\n              v: 5e3,\n              d: \"Base fee of the SELFDESTRUCT opcode\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      8317: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), o(r(6664), t), o(r(4443), t), o(r(850), t), o(r(2290), t);\n      },\n      850: (e, t) => {\n        \"use strict\";\n\n        var r;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.TypeOutput = void 0, (r = t.TypeOutput || (t.TypeOutput = {}))[r.Number = 0] = \"Number\", r[r.BigInt = 1] = \"BigInt\", r[r.Uint8Array = 2] = \"Uint8Array\", r[r.PrefixedHexString = 3] = \"PrefixedHexString\";\n      },\n      2290: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.toType = t.ecrecover = t.bigIntToUnpaddedUint8Array = t.bigIntToHex = t.unpadUint8Array = t.stripZeros = t.setLengthLeft = t.assertIsUint8Array = t.zeros = t.bigIntToUint8Array = t.uint8ArrayToBigInt = t.toUint8Array = t.intToUint8Array = t.padToEven = t.parseGethGenesis = t.stripHexPrefix = void 0;\n        const n = r(7345),\n          o = r(9634),\n          i = r(4555),\n          s = r(4443),\n          a = r(850);\n        t.stripHexPrefix = e => {\n          if (\"string\" != typeof e) throw new Error(\"[stripHexPrefix] input must be type 'string', received \" + typeof e);\n          return (0, n.isHexPrefixed)(e) ? e.slice(2) : e;\n        };\n        const c = function (e) {\n          if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Received an invalid integer type: ${e}`);\n          return `0x${e.toString(16)}`;\n        };\n        function u(e) {\n          let t = e;\n          if (\"string\" != typeof t) throw new Error(\"[padToEven] value must be type 'string', received \" + typeof t);\n          return t.length % 2 && (t = `0${t}`), t;\n        }\n        function d(e) {\n          const t = (0, o.bytesToHex)(e);\n          return \"0x\" === t ? BigInt(0) : BigInt(t);\n        }\n        function l(e) {\n          return (0, t.toUint8Array)(`0x${e.toString(16)}`);\n        }\n        function h(e) {\n          if (!(0, o.isUint8Array)(e)) throw new Error(`This method only supports Uint8Array but input was: ${e}`);\n        }\n        function f(e) {\n          let t = e[0];\n          for (; e.length > 0 && \"0\" === t.toString();) t = (e = e.slice(1))[0];\n          return e;\n        }\n        t.parseGethGenesis = function (e, r, o) {\n          try {\n            if ([\"config\", \"difficulty\", \"gasLimit\", \"alloc\"].some(t => !(t in e))) throw new Error(\"Invalid format, expected geth genesis fields missing\");\n            return void 0 !== r && (e.name = r), function (e, r = !0) {\n              var o, i;\n              const {\n                name: a,\n                config: u,\n                difficulty: d,\n                mixHash: l,\n                gasLimit: h,\n                coinbase: f,\n                baseFeePerGas: p\n              } = e;\n              let {\n                extraData: m,\n                timestamp: g,\n                nonce: y\n              } = e;\n              const v = Number(g),\n                {\n                  chainId: b\n                } = u;\n              if (\"\" === m && (m = \"0x\"), (0, n.isHexPrefixed)(g) || (g = c(parseInt(g))), 18 !== y.length && (y = function (e) {\n                return e && \"0x0\" !== e ? (0, n.isHexPrefixed)(e) ? `0x${(0, t.stripHexPrefix)(e).padStart(16, \"0\")}` : `0x${e.padStart(16, \"0\")}` : \"0x0000000000000000\";\n              }(y)), u.eip155Block !== u.eip158Block) throw new Error(\"EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork\");\n              const E = {\n                  name: a,\n                  chainId: b,\n                  networkId: b,\n                  genesis: {\n                    timestamp: g,\n                    gasLimit: parseInt(h),\n                    difficulty: parseInt(d),\n                    nonce: y,\n                    extraData: m,\n                    mixHash: l,\n                    coinbase: f,\n                    baseFeePerGas: p\n                  },\n                  hardfork: void 0,\n                  hardforks: [],\n                  bootstrapNodes: [],\n                  consensus: void 0 !== u.clique ? {\n                    type: \"poa\",\n                    algorithm: \"clique\",\n                    clique: {\n                      period: null !== (o = u.clique.period) && void 0 !== o ? o : u.clique.blockperiodseconds,\n                      epoch: null !== (i = u.clique.epoch) && void 0 !== i ? i : u.clique.epochlength\n                    }\n                  } : {\n                    type: \"pow\",\n                    algorithm: \"ethash\",\n                    ethash: {}\n                  }\n                },\n                _ = {\n                  [s.Hardfork.Homestead]: {\n                    name: \"homesteadBlock\"\n                  },\n                  [s.Hardfork.Dao]: {\n                    name: \"daoForkBlock\"\n                  },\n                  [s.Hardfork.TangerineWhistle]: {\n                    name: \"eip150Block\"\n                  },\n                  [s.Hardfork.SpuriousDragon]: {\n                    name: \"eip155Block\"\n                  },\n                  [s.Hardfork.Byzantium]: {\n                    name: \"byzantiumBlock\"\n                  },\n                  [s.Hardfork.Constantinople]: {\n                    name: \"constantinopleBlock\"\n                  },\n                  [s.Hardfork.Petersburg]: {\n                    name: \"petersburgBlock\"\n                  },\n                  [s.Hardfork.Istanbul]: {\n                    name: \"istanbulBlock\"\n                  },\n                  [s.Hardfork.MuirGlacier]: {\n                    name: \"muirGlacierBlock\"\n                  },\n                  [s.Hardfork.Berlin]: {\n                    name: \"berlinBlock\"\n                  },\n                  [s.Hardfork.London]: {\n                    name: \"londonBlock\"\n                  },\n                  [s.Hardfork.MergeForkIdTransition]: {\n                    name: \"mergeForkBlock\",\n                    postMerge: r\n                  },\n                  [s.Hardfork.Shanghai]: {\n                    name: \"shanghaiTime\",\n                    postMerge: !0,\n                    isTimestamp: !0\n                  },\n                  [s.Hardfork.ShardingForkDev]: {\n                    name: \"shardingForkTime\",\n                    postMerge: !0,\n                    isTimestamp: !0\n                  }\n                },\n                A = Object.keys(_).reduce((e, t) => (e[_[t].name] = t, e), {}),\n                T = Object.keys(u).filter(e => void 0 !== A[e] && void 0 !== u[e] && null !== u[e]);\n              if (E.hardforks = T.map(e => ({\n                name: A[e],\n                block: !0 === _[A[e]].isTimestamp || \"number\" != typeof u[e] ? null : u[e],\n                timestamp: !0 === _[A[e]].isTimestamp && \"number\" == typeof u[e] ? u[e] : void 0\n              })).filter(e => null !== e.block || void 0 !== e.timestamp), E.hardforks.sort((e, t) => {\n                var r, n;\n                return (null !== (r = e.block) && void 0 !== r ? r : 1 / 0) - (null !== (n = t.block) && void 0 !== n ? n : 1 / 0);\n              }), E.hardforks.sort((e, t) => {\n                var r, n;\n                return (null !== (r = e.timestamp) && void 0 !== r ? r : v) - (null !== (n = t.timestamp) && void 0 !== n ? n : v);\n              }), void 0 !== u.terminalTotalDifficulty) {\n                const e = {\n                    name: s.Hardfork.Merge,\n                    ttd: u.terminalTotalDifficulty,\n                    block: null\n                  },\n                  t = E.hardforks.findIndex(e => {\n                    var t;\n                    return !0 === (null === (t = _[e.name]) || void 0 === t ? void 0 : t.postMerge);\n                  });\n                -1 !== t ? E.hardforks.splice(t, 0, e) : E.hardforks.push(e);\n              }\n              const w = E.hardforks.length > 0 ? E.hardforks.slice(-1)[0] : void 0;\n              return E.hardfork = null == w ? void 0 : w.name, E.hardforks.unshift({\n                name: s.Hardfork.Chainstart,\n                block: 0\n              }), E;\n            }(e, o);\n          } catch (e) {\n            throw new Error(`Error parsing parameters file: ${e.message}`);\n          }\n        }, t.padToEven = u, t.intToUint8Array = function (e) {\n          const t = c(e);\n          return (0, o.hexToBytes)(`0x${u(t.slice(2))}`);\n        }, t.toUint8Array = function (e) {\n          var r;\n          if (null == e) return new Uint8Array();\n          if (e instanceof Uint8Array) return e;\n          if (\"Uint8Array\" === (null === (r = null == e ? void 0 : e.constructor) || void 0 === r ? void 0 : r.name)) return Uint8Array.from(e);\n          if (Array.isArray(e)) return Uint8Array.from(e);\n          if (\"string\" == typeof e) {\n            if (!(0, n.isHexString)(e)) throw new Error(`Cannot convert string to Uint8Array. only supports 0x-prefixed hex strings and this string was given: ${e}`);\n            return (0, o.hexToBytes)(u((0, t.stripHexPrefix)(e)));\n          }\n          if (\"number\" == typeof e) return (0, t.toUint8Array)((0, o.numberToHex)(e));\n          if (\"bigint\" == typeof e) {\n            if (e < BigInt(0)) throw new Error(`Cannot convert negative bigint to Uint8Array. Given: ${e}`);\n            let r = e.toString(16);\n            return r.length % 2 && (r = `0${r}`), (0, t.toUint8Array)(`0x${r}`);\n          }\n          if (e.toArray) return Uint8Array.from(e.toArray());\n          throw new Error(\"invalid type\");\n        }, t.uint8ArrayToBigInt = d, t.bigIntToUint8Array = l, t.zeros = function (e) {\n          return new Uint8Array(e).fill(0);\n        }, t.assertIsUint8Array = h, t.setLengthLeft = function (e, r) {\n          return h(e), function (e, r, n) {\n            const o = (0, t.zeros)(r);\n            return e.length < r ? (o.set(e, r - e.length), o) : e.subarray(-r);\n          }(e, r);\n        }, t.stripZeros = f, t.unpadUint8Array = function (e) {\n          return h(e), f(e);\n        }, t.bigIntToHex = e => `0x${e.toString(16)}`, t.bigIntToUnpaddedUint8Array = function (e) {\n          return (0, t.unpadUint8Array)(l(e));\n        }, t.ecrecover = function (e, t, r, n, o) {\n          const s = function (e, t) {\n            return e === BigInt(0) || e === BigInt(1) ? e : void 0 === t ? e - BigInt(27) : e - (t * BigInt(2) + BigInt(35));\n          }(t, o);\n          if (!function (e) {\n            return e === BigInt(0) || e === BigInt(1);\n          }(s)) throw new Error(\"Invalid signature v value\");\n          return new i.secp256k1.Signature(d(r), d(n)).addRecoveryBit(Number(s)).recoverPublicKey(e).toRawBytes(!1).slice(1);\n        }, t.toType = function (e, r) {\n          if (null === e) return null;\n          if (void 0 === e) return;\n          if (\"string\" == typeof e && !(0, n.isHexString)(e)) throw new Error(`A string must be provided with a 0x-prefix, given: ${e}`);\n          if (\"number\" == typeof e && !Number.isSafeInteger(e)) throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)\");\n          const i = (0, t.toUint8Array)(e);\n          switch (r) {\n            case a.TypeOutput.Uint8Array:\n              return i;\n            case a.TypeOutput.BigInt:\n              return d(i);\n            case a.TypeOutput.Number:\n              {\n                const e = d(i);\n                if (e > BigInt(Number.MAX_SAFE_INTEGER)) throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)\");\n                return Number(e);\n              }\n            case a.TypeOutput.PrefixedHexString:\n              return (0, o.bytesToHex)(i);\n            default:\n              throw new Error(\"unknown outputType\");\n          }\n        };\n      },\n      9247: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), o(r(8632), t), o(r(1560), t), o(r(4874), t), o(r(5774), t), o(r(8317), t), o(r(9275), t);\n      },\n      5774: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.keyStoreSchema = void 0, t.keyStoreSchema = {\n          type: \"object\",\n          required: [\"crypto\", \"id\", \"version\", \"address\"],\n          properties: {\n            crypto: {\n              type: \"object\",\n              required: [\"cipher\", \"ciphertext\", \"cipherparams\", \"kdf\", \"kdfparams\", \"mac\"],\n              properties: {\n                cipher: {\n                  type: \"string\"\n                },\n                ciphertext: {\n                  type: \"string\"\n                },\n                cipherparams: {\n                  type: \"object\"\n                },\n                kdf: {\n                  type: \"string\"\n                },\n                kdfparams: {\n                  type: \"object\"\n                },\n                salt: {\n                  type: \"string\"\n                },\n                mac: {\n                  type: \"string\"\n                }\n              }\n            },\n            id: {\n              type: \"string\"\n            },\n            version: {\n              type: \"number\"\n            },\n            address: {\n              type: \"string\"\n            }\n          }\n        };\n      },\n      7592: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Address = void 0;\n        const n = r(7423),\n          o = r(9634),\n          i = r(4555),\n          s = r(2290);\n        class a {\n          constructor(e) {\n            if (20 !== e.length) throw new Error(\"Invalid address length\");\n            this.buf = e;\n          }\n          static zero() {\n            return new a((0, s.zeros)(20));\n          }\n          equals(e) {\n            return (0, o.uint8ArrayEquals)(this.buf, e.buf);\n          }\n          isZero() {\n            return this.equals(a.zero());\n          }\n          toString() {\n            return (0, o.bytesToHex)(this.buf);\n          }\n          toArray() {\n            return this.buf;\n          }\n          static publicToAddress(e, t = !1) {\n            let r = e;\n            if ((0, s.assertIsUint8Array)(r), t && 64 !== r.length && (r = i.secp256k1.ProjectivePoint.fromHex(r).toRawBytes(!1).slice(1)), 64 !== r.length) throw new Error(\"Expected pubKey to be of length 64\");\n            return (0, n.keccak256)(r).slice(-20);\n          }\n        }\n        t.Address = a;\n      },\n      915: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.BaseTransaction = void 0;\n        const n = r(9634),\n          o = r(4555),\n          i = r(2290),\n          s = r(6664),\n          a = r(4443),\n          c = r(9964),\n          u = r(7592),\n          d = r(4562);\n        t.BaseTransaction = class {\n          constructor(e, t) {\n            var r, n;\n            this.cache = {\n              hash: void 0,\n              dataFee: void 0\n            }, this.activeCapabilities = [], this.DEFAULT_CHAIN = a.Chain.Mainnet, this.DEFAULT_HARDFORK = a.Hardfork.Merge;\n            const {\n              nonce: o,\n              gasLimit: s,\n              to: c,\n              value: l,\n              data: h,\n              v: f,\n              r: p,\n              s: m,\n              type: g\n            } = e;\n            this._type = Number((0, i.uint8ArrayToBigInt)((0, i.toUint8Array)(g))), this.txOptions = t;\n            const y = (0, i.toUint8Array)(\"\" === c ? \"0x\" : c),\n              v = (0, i.toUint8Array)(\"\" === f ? \"0x\" : f),\n              b = (0, i.toUint8Array)(\"\" === p ? \"0x\" : p),\n              E = (0, i.toUint8Array)(\"\" === m ? \"0x\" : m);\n            this.nonce = (0, i.uint8ArrayToBigInt)((0, i.toUint8Array)(\"\" === o ? \"0x\" : o)), this.gasLimit = (0, i.uint8ArrayToBigInt)((0, i.toUint8Array)(\"\" === s ? \"0x\" : s)), this.to = y.length > 0 ? new u.Address(y) : void 0, this.value = (0, i.uint8ArrayToBigInt)((0, i.toUint8Array)(\"\" === l ? \"0x\" : l)), this.data = (0, i.toUint8Array)(\"\" === h ? \"0x\" : h), this.v = v.length > 0 ? (0, i.uint8ArrayToBigInt)(v) : void 0, this.r = b.length > 0 ? (0, i.uint8ArrayToBigInt)(b) : void 0, this.s = E.length > 0 ? (0, i.uint8ArrayToBigInt)(E) : void 0, this._validateCannotExceedMaxInteger({\n              value: this.value,\n              r: this.r,\n              s: this.s\n            }), this._validateCannotExceedMaxInteger({\n              gasLimit: this.gasLimit\n            }, 64), this._validateCannotExceedMaxInteger({\n              nonce: this.nonce\n            }, 64, !0);\n            const _ = void 0 === this.to || null === this.to,\n              A = null !== (r = t.allowUnlimitedInitCodeSize) && void 0 !== r && r,\n              T = null !== (n = t.common) && void 0 !== n ? n : this._getCommon();\n            _ && T.isActivatedEIP(3860) && !A && (0, d.checkMaxInitCodeSize)(T, this.data.length);\n          }\n          get type() {\n            return this._type;\n          }\n          supports(e) {\n            return this.activeCapabilities.includes(e);\n          }\n          validate(e = !1) {\n            const t = [];\n            return this.getBaseFee() > this.gasLimit && t.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`), this.isSigned() && !this.verifySignature() && t.push(\"Invalid Signature\"), e ? t : 0 === t.length;\n          }\n          _validateYParity() {\n            const {\n              v: e\n            } = this;\n            if (void 0 !== e && e !== BigInt(0) && e !== BigInt(1)) {\n              const e = this._errorMsg(\"The y-parity of the transaction should either be 0 or 1\");\n              throw new Error(e);\n            }\n          }\n          _validateHighS() {\n            const {\n              s: e\n            } = this;\n            if (this.common.gteHardfork(\"homestead\") && void 0 !== e && e > o.SECP256K1_ORDER_DIV_2) {\n              const e = this._errorMsg(\"Invalid Signature: s-values greater than secp256k1n/2 are considered invalid\");\n              throw new Error(e);\n            }\n          }\n          getBaseFee() {\n            const e = this.common.param(\"gasPrices\", \"tx\");\n            let t = this.getDataFee();\n            if (e && (t += e), this.common.gteHardfork(\"homestead\") && this.toCreationAddress()) {\n              const e = this.common.param(\"gasPrices\", \"txCreation\");\n              e && (t += e);\n            }\n            return t;\n          }\n          getDataFee() {\n            const e = this.common.param(\"gasPrices\", \"txDataZero\"),\n              t = this.common.param(\"gasPrices\", \"txDataNonZero\");\n            let r = BigInt(0);\n            for (let n = 0; n < this.data.length; n += 1) 0 === this.data[n] ? r += e : r += t;\n            if ((void 0 === this.to || null === this.to) && this.common.isActivatedEIP(3860)) {\n              const e = BigInt(Math.ceil(this.data.length / 32));\n              r += this.common.param(\"gasPrices\", \"initCodeWordCost\") * e;\n            }\n            return r;\n          }\n          toCreationAddress() {\n            return void 0 === this.to || 0 === this.to.buf.length;\n          }\n          isSigned() {\n            const {\n              v: e,\n              r: t,\n              s: r\n            } = this;\n            return void 0 !== e && void 0 !== t && void 0 !== r;\n          }\n          verifySignature() {\n            try {\n              const e = this.getSenderPublicKey();\n              return 0 !== (0, i.unpadUint8Array)(e).length;\n            } catch (e) {\n              return !1;\n            }\n          }\n          getSenderAddress() {\n            return new u.Address(u.Address.publicToAddress(this.getSenderPublicKey()));\n          }\n          sign(e) {\n            if (32 !== e.length) {\n              const e = this._errorMsg(\"Private key must be 32 bytes in length.\");\n              throw new Error(e);\n            }\n            let t = !1;\n            0 === this.type && this.common.gteHardfork(\"spuriousDragon\") && !this.supports(c.Capability.EIP155ReplayProtection) && (this.activeCapabilities.push(c.Capability.EIP155ReplayProtection), t = !0);\n            const r = this.getMessageToSign(!0),\n              {\n                v: n,\n                r: o,\n                s: i\n              } = this._ecsign(r, e),\n              s = this._processSignature(n, o, i);\n            if (t) {\n              const e = this.activeCapabilities.indexOf(c.Capability.EIP155ReplayProtection);\n              e > -1 && this.activeCapabilities.splice(e, 1);\n            }\n            return s;\n          }\n          _getCommon(e, t) {\n            var r, n, o, a;\n            if (void 0 !== t) {\n              const r = (0, i.uint8ArrayToBigInt)((0, i.toUint8Array)(t));\n              if (e) {\n                if (e.chainId() !== r) {\n                  const e = this._errorMsg(\"The chain ID does not match the chain ID of Common\");\n                  throw new Error(e);\n                }\n                return e.copy();\n              }\n              return s.Common.isSupportedChainId(r) ? new s.Common({\n                chain: r,\n                hardfork: this.DEFAULT_HARDFORK\n              }) : s.Common.custom({\n                name: \"custom-chain\",\n                networkId: r,\n                chainId: r\n              }, {\n                baseChain: this.DEFAULT_CHAIN,\n                hardfork: this.DEFAULT_HARDFORK\n              });\n            }\n            if ((null == e ? void 0 : e.copy) && \"function\" == typeof (null == e ? void 0 : e.copy)) return e.copy();\n            if (e) {\n              const t = \"function\" == typeof e.hardfork ? e.hardfork() : e.hardfork;\n              return s.Common.custom({\n                name: \"custom-chain\",\n                networkId: e.networkId ? e.networkId() : null !== (n = BigInt(null === (r = e.customChain) || void 0 === r ? void 0 : r.networkId)) && void 0 !== n ? n : void 0,\n                chainId: e.chainId ? e.chainId() : null !== (a = BigInt(null === (o = e.customChain) || void 0 === o ? void 0 : o.chainId)) && void 0 !== a ? a : void 0\n              }, {\n                baseChain: this.DEFAULT_CHAIN,\n                hardfork: t || this.DEFAULT_HARDFORK\n              });\n            }\n            return new s.Common({\n              chain: this.DEFAULT_CHAIN,\n              hardfork: this.DEFAULT_HARDFORK\n            });\n          }\n          _validateCannotExceedMaxInteger(e, t = 256, r = !1) {\n            for (const [n, i] of Object.entries(e)) switch (t) {\n              case 64:\n                if (r) {\n                  if (void 0 !== i && i >= o.MAX_UINT64) {\n                    const e = this._errorMsg(`${n} cannot equal or exceed MAX_UINT64 (2^64-1), given ${i}`);\n                    throw new Error(e);\n                  }\n                } else if (void 0 !== i && i > o.MAX_UINT64) {\n                  const e = this._errorMsg(`${n} cannot exceed MAX_UINT64 (2^64-1), given ${i}`);\n                  throw new Error(e);\n                }\n                break;\n              case 256:\n                if (r) {\n                  if (void 0 !== i && i >= o.MAX_INTEGER) {\n                    const e = this._errorMsg(`${n} cannot equal or exceed MAX_INTEGER (2^256-1), given ${i}`);\n                    throw new Error(e);\n                  }\n                } else if (void 0 !== i && i > o.MAX_INTEGER) {\n                  const e = this._errorMsg(`${n} cannot exceed MAX_INTEGER (2^256-1), given ${i}`);\n                  throw new Error(e);\n                }\n                break;\n              default:\n                {\n                  const e = this._errorMsg(\"unimplemented bits value\");\n                  throw new Error(e);\n                }\n            }\n          }\n          static _validateNotArray(e) {\n            const t = [\"nonce\", \"gasPrice\", \"gasLimit\", \"to\", \"value\", \"data\", \"v\", \"r\", \"s\", \"type\", \"baseFee\", \"maxFeePerGas\", \"chainId\"];\n            for (const [r, n] of Object.entries(e)) if (t.includes(r) && Array.isArray(n)) throw new Error(`${r} cannot be an array`);\n          }\n          _getSharedErrorPostfix() {\n            let e = \"\";\n            try {\n              e = this.isSigned() ? (0, n.bytesToHex)(this.hash()) : \"not available (unsigned)\";\n            } catch (t) {\n              e = \"error\";\n            }\n            let t = \"\";\n            try {\n              t = this.isSigned().toString();\n            } catch (t) {\n              e = \"error\";\n            }\n            let r = \"\";\n            try {\n              r = this.common.hardfork();\n            } catch (e) {\n              r = \"error\";\n            }\n            let o = `tx type=${this.type} hash=${e} nonce=${this.nonce} value=${this.value} `;\n            return o += `signed=${t} hf=${r}`, o;\n          }\n          _ecsign(e, t, r) {\n            const n = o.secp256k1.sign(e, t),\n              i = n.toCompactRawBytes();\n            return {\n              r: i.subarray(0, 32),\n              s: i.subarray(32, 64),\n              v: void 0 === r ? BigInt(n.recovery + 27) : BigInt(n.recovery + 35) + BigInt(r) * BigInt(2)\n            };\n          }\n          static fromSerializedTx(e, t = {}) {}\n          static fromTxData(e, t = {}) {}\n        };\n      },\n      4555: function (e, t, r) {\n        \"use strict\";\n\n        var n,\n          o = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          s = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && o(t, e, r);\n            return i(t, e), t;\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SECP256K1_ORDER_DIV_2 = t.SECP256K1_ORDER = t.MAX_INTEGER = t.MAX_UINT64 = t.secp256k1 = void 0;\n        const a = s(r(5473));\n        t.secp256k1 = null !== (n = a.secp256k1) && void 0 !== n ? n : a, t.MAX_UINT64 = BigInt(\"0xffffffffffffffff\"), t.MAX_INTEGER = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"), t.SECP256K1_ORDER = t.secp256k1.CURVE.n, t.SECP256K1_ORDER_DIV_2 = t.SECP256K1_ORDER / BigInt(2);\n      },\n      6135: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.FeeMarketEIP1559Transaction = void 0;\n        const n = r(7423),\n          o = r(7345),\n          i = r(7256),\n          s = r(9634),\n          a = r(4555),\n          c = r(915),\n          u = r(4562),\n          d = r(2290),\n          l = (0, s.hexToBytes)(2..toString(16).padStart(2, \"0\"));\n        class h extends c.BaseTransaction {\n          constructor(e, t = {}) {\n            var r;\n            super(Object.assign(Object.assign({}, e), {\n              type: 2\n            }), t), this.DEFAULT_HARDFORK = \"london\";\n            const {\n              chainId: n,\n              accessList: o,\n              maxFeePerGas: i,\n              maxPriorityFeePerGas: s\n            } = e;\n            if (this.common = this._getCommon(t.common, n), this.chainId = this.common.chainId(), !this.common.isActivatedEIP(1559)) throw new Error(\"EIP-1559 not enabled on Common\");\n            this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);\n            const l = (0, u.getAccessListData)(null != o ? o : []);\n            if (this.accessList = l.accessList, this.AccessListJSON = l.AccessListJSON, (0, u.verifyAccessList)(this.accessList), this.maxFeePerGas = (0, d.uint8ArrayToBigInt)((0, d.toUint8Array)(\"\" === i ? \"0x\" : i)), this.maxPriorityFeePerGas = (0, d.uint8ArrayToBigInt)((0, d.toUint8Array)(\"\" === s ? \"0x\" : s)), this._validateCannotExceedMaxInteger({\n              maxFeePerGas: this.maxFeePerGas,\n              maxPriorityFeePerGas: this.maxPriorityFeePerGas\n            }), c.BaseTransaction._validateNotArray(e), this.gasLimit * this.maxFeePerGas > a.MAX_INTEGER) {\n              const e = this._errorMsg(\"gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)\");\n              throw new Error(e);\n            }\n            if (this.maxFeePerGas < this.maxPriorityFeePerGas) {\n              const e = this._errorMsg(\"maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)\");\n              throw new Error(e);\n            }\n            this._validateYParity(), this._validateHighS(), (null === (r = null == t ? void 0 : t.freeze) || void 0 === r || r) && Object.freeze(this);\n          }\n          static fromTxData(e, t = {}) {\n            return new h(e, t);\n          }\n          static fromSerializedTx(e, t = {}) {\n            if (!(0, s.uint8ArrayEquals)(e.subarray(0, 1), l)) throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: 2, received: ${(0, s.bytesToHex)(e.subarray(0, 1))}`);\n            const r = i.RLP.decode(e.subarray(1));\n            if (!Array.isArray(r)) throw new Error(\"Invalid serialized tx input: must be array\");\n            return h.fromValuesArray(r, t);\n          }\n          static fromValuesArray(e, t = {}) {\n            if (9 !== e.length && 12 !== e.length) throw new Error(\"Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).\");\n            const [r, n, i, s, a, c, u, l, f, p, m, g] = e;\n            return this._validateNotArray({\n              chainId: r,\n              v: p\n            }), (0, o.validateNoLeadingZeroes)({\n              nonce: n,\n              maxPriorityFeePerGas: i,\n              maxFeePerGas: s,\n              gasLimit: a,\n              value: u,\n              v: p,\n              r: m,\n              s: g\n            }), new h({\n              chainId: (0, d.uint8ArrayToBigInt)(r),\n              nonce: n,\n              maxPriorityFeePerGas: i,\n              maxFeePerGas: s,\n              gasLimit: a,\n              to: c,\n              value: u,\n              data: l,\n              accessList: null != f ? f : [],\n              v: void 0 !== p ? (0, d.uint8ArrayToBigInt)(p) : void 0,\n              r: m,\n              s: g\n            }, t);\n          }\n          getDataFee() {\n            if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) return this.cache.dataFee.value;\n            let e = super.getDataFee();\n            return e += BigInt((0, u.getDataFeeEIP2930)(this.accessList, this.common)), Object.isFrozen(this) && (this.cache.dataFee = {\n              value: e,\n              hardfork: this.common.hardfork()\n            }), e;\n          }\n          getUpfrontCost(e = BigInt(0)) {\n            const t = this.maxPriorityFeePerGas,\n              r = this.maxFeePerGas - e,\n              n = (t < r ? t : r) + e;\n            return this.gasLimit * n + this.value;\n          }\n          raw() {\n            return [(0, d.bigIntToUnpaddedUint8Array)(this.chainId), (0, d.bigIntToUnpaddedUint8Array)(this.nonce), (0, d.bigIntToUnpaddedUint8Array)(this.maxPriorityFeePerGas), (0, d.bigIntToUnpaddedUint8Array)(this.maxFeePerGas), (0, d.bigIntToUnpaddedUint8Array)(this.gasLimit), void 0 !== this.to ? this.to.buf : Uint8Array.from([]), (0, d.bigIntToUnpaddedUint8Array)(this.value), this.data, this.accessList, void 0 !== this.v ? (0, d.bigIntToUnpaddedUint8Array)(this.v) : Uint8Array.from([]), void 0 !== this.r ? (0, d.bigIntToUnpaddedUint8Array)(this.r) : Uint8Array.from([]), void 0 !== this.s ? (0, d.bigIntToUnpaddedUint8Array)(this.s) : Uint8Array.from([])];\n          }\n          serialize() {\n            const e = this.raw();\n            return (0, s.uint8ArrayConcat)(l, i.RLP.encode(e));\n          }\n          getMessageToSign(e = !0) {\n            const t = this.raw().slice(0, 9),\n              r = (0, s.uint8ArrayConcat)(l, i.RLP.encode(t));\n            return e ? (0, n.keccak256)(r) : r;\n          }\n          hash() {\n            if (!this.isSigned()) {\n              const e = this._errorMsg(\"Cannot call hash method if transaction is not signed\");\n              throw new Error(e);\n            }\n            return Object.isFrozen(this) ? (this.cache.hash || (this.cache.hash = (0, n.keccak256)(this.serialize())), this.cache.hash) : (0, n.keccak256)(this.serialize());\n          }\n          getMessageToVerifySignature() {\n            return this.getMessageToSign();\n          }\n          getSenderPublicKey() {\n            if (!this.isSigned()) {\n              const e = this._errorMsg(\"Cannot call this method if transaction is not signed\");\n              throw new Error(e);\n            }\n            const e = this.getMessageToVerifySignature(),\n              {\n                v: t,\n                r,\n                s: n\n              } = this;\n            this._validateHighS();\n            try {\n              return (0, d.ecrecover)(e, t + BigInt(27), (0, d.bigIntToUnpaddedUint8Array)(r), (0, d.bigIntToUnpaddedUint8Array)(n));\n            } catch (e) {\n              const t = this._errorMsg(\"Invalid Signature\");\n              throw new Error(t);\n            }\n          }\n          _processSignature(e, t, r) {\n            const n = Object.assign(Object.assign({}, this.txOptions), {\n              common: this.common\n            });\n            return h.fromTxData({\n              chainId: this.chainId,\n              nonce: this.nonce,\n              maxPriorityFeePerGas: this.maxPriorityFeePerGas,\n              maxFeePerGas: this.maxFeePerGas,\n              gasLimit: this.gasLimit,\n              to: this.to,\n              value: this.value,\n              data: this.data,\n              accessList: this.accessList,\n              v: e - BigInt(27),\n              r: (0, d.uint8ArrayToBigInt)(t),\n              s: (0, d.uint8ArrayToBigInt)(r)\n            }, n);\n          }\n          toJSON() {\n            const e = (0, u.getAccessListJSON)(this.accessList);\n            return {\n              chainId: (0, d.bigIntToHex)(this.chainId),\n              nonce: (0, d.bigIntToHex)(this.nonce),\n              maxPriorityFeePerGas: (0, d.bigIntToHex)(this.maxPriorityFeePerGas),\n              maxFeePerGas: (0, d.bigIntToHex)(this.maxFeePerGas),\n              gasLimit: (0, d.bigIntToHex)(this.gasLimit),\n              to: void 0 !== this.to ? this.to.toString() : void 0,\n              value: (0, d.bigIntToHex)(this.value),\n              data: (0, s.bytesToHex)(this.data),\n              accessList: e,\n              v: void 0 !== this.v ? (0, d.bigIntToHex)(this.v) : void 0,\n              r: void 0 !== this.r ? (0, d.bigIntToHex)(this.r) : void 0,\n              s: void 0 !== this.s ? (0, d.bigIntToHex)(this.s) : void 0\n            };\n          }\n          errorStr() {\n            let e = this._getSharedErrorPostfix();\n            return e += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`, e;\n          }\n          _errorMsg(e) {\n            return `${e} (${this.errorStr()})`;\n          }\n        }\n        t.FeeMarketEIP1559Transaction = h;\n      },\n      9013: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.AccessListEIP2930Transaction = void 0;\n        const n = r(7423),\n          o = r(7345),\n          i = r(7256),\n          s = r(9634),\n          a = r(4555),\n          c = r(4562),\n          u = r(2290),\n          d = r(915),\n          l = (0, s.hexToBytes)(1..toString(16).padStart(2, \"0\"));\n        class h extends d.BaseTransaction {\n          constructor(e, t = {}) {\n            var r;\n            super(Object.assign(Object.assign({}, e), {\n              type: 1\n            }), t), this.DEFAULT_HARDFORK = \"berlin\";\n            const {\n              chainId: n,\n              accessList: o,\n              gasPrice: i\n            } = e;\n            if (this.common = this._getCommon(t.common, n), this.chainId = this.common.chainId(), !this.common.isActivatedEIP(2930)) throw new Error(\"EIP-2930 not enabled on Common\");\n            this.activeCapabilities = this.activeCapabilities.concat([2718, 2930]);\n            const s = (0, c.getAccessListData)(null != o ? o : []);\n            if (this.accessList = s.accessList, this.AccessListJSON = s.AccessListJSON, (0, c.verifyAccessList)(this.accessList), this.gasPrice = (0, u.uint8ArrayToBigInt)((0, u.toUint8Array)(\"\" === i ? \"0x\" : i)), this._validateCannotExceedMaxInteger({\n              gasPrice: this.gasPrice\n            }), d.BaseTransaction._validateNotArray(e), this.gasPrice * this.gasLimit > a.MAX_INTEGER) {\n              const e = this._errorMsg(\"gasLimit * gasPrice cannot exceed MAX_INTEGER\");\n              throw new Error(e);\n            }\n            this._validateYParity(), this._validateHighS(), (null === (r = null == t ? void 0 : t.freeze) || void 0 === r || r) && Object.freeze(this);\n          }\n          static fromTxData(e, t = {}) {\n            return new h(e, t);\n          }\n          static fromSerializedTx(e, t = {}) {\n            if (!(0, s.uint8ArrayEquals)(e.subarray(0, 1), l)) throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: 1, received: ${(0, s.bytesToHex)(e.subarray(0, 1))}`);\n            const r = i.RLP.decode(Uint8Array.from(e.subarray(1)));\n            if (!Array.isArray(r)) throw new Error(\"Invalid serialized tx input: must be array\");\n            return h.fromValuesArray(r, t);\n          }\n          static fromValuesArray(e, t = {}) {\n            if (8 !== e.length && 11 !== e.length) throw new Error(\"Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).\");\n            const [r, n, i, s, a, c, d, l, f, p, m] = e;\n            return this._validateNotArray({\n              chainId: r,\n              v: f\n            }), (0, o.validateNoLeadingZeroes)({\n              nonce: n,\n              gasPrice: i,\n              gasLimit: s,\n              value: c,\n              v: f,\n              r: p,\n              s: m\n            }), new h({\n              chainId: (0, u.uint8ArrayToBigInt)(r),\n              nonce: n,\n              gasPrice: i,\n              gasLimit: s,\n              to: a,\n              value: c,\n              data: d,\n              accessList: null != l ? l : [],\n              v: void 0 !== f ? (0, u.uint8ArrayToBigInt)(f) : void 0,\n              r: p,\n              s: m\n            }, t);\n          }\n          getDataFee() {\n            if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) return this.cache.dataFee.value;\n            let e = super.getDataFee();\n            return e += BigInt((0, c.getDataFeeEIP2930)(this.accessList, this.common)), Object.isFrozen(this) && (this.cache.dataFee = {\n              value: e,\n              hardfork: this.common.hardfork()\n            }), e;\n          }\n          getUpfrontCost() {\n            return this.gasLimit * this.gasPrice + this.value;\n          }\n          raw() {\n            return [(0, u.bigIntToUnpaddedUint8Array)(this.chainId), (0, u.bigIntToUnpaddedUint8Array)(this.nonce), (0, u.bigIntToUnpaddedUint8Array)(this.gasPrice), (0, u.bigIntToUnpaddedUint8Array)(this.gasLimit), void 0 !== this.to ? this.to.buf : Uint8Array.from([]), (0, u.bigIntToUnpaddedUint8Array)(this.value), this.data, this.accessList, void 0 !== this.v ? (0, u.bigIntToUnpaddedUint8Array)(this.v) : Uint8Array.from([]), void 0 !== this.r ? (0, u.bigIntToUnpaddedUint8Array)(this.r) : Uint8Array.from([]), void 0 !== this.s ? (0, u.bigIntToUnpaddedUint8Array)(this.s) : Uint8Array.from([])];\n          }\n          serialize() {\n            const e = this.raw();\n            return (0, s.uint8ArrayConcat)(l, i.RLP.encode(e));\n          }\n          getMessageToSign(e = !0) {\n            const t = this.raw().slice(0, 8),\n              r = (0, s.uint8ArrayConcat)(l, i.RLP.encode(t));\n            return e ? (0, n.keccak256)(r) : r;\n          }\n          hash() {\n            if (!this.isSigned()) {\n              const e = this._errorMsg(\"Cannot call hash method if transaction is not signed\");\n              throw new Error(e);\n            }\n            return Object.isFrozen(this) ? (this.cache.hash || (this.cache.hash = (0, n.keccak256)(this.serialize())), this.cache.hash) : (0, n.keccak256)(this.serialize());\n          }\n          getMessageToVerifySignature() {\n            return this.getMessageToSign();\n          }\n          getSenderPublicKey() {\n            if (!this.isSigned()) {\n              const e = this._errorMsg(\"Cannot call this method if transaction is not signed\");\n              throw new Error(e);\n            }\n            const e = this.getMessageToVerifySignature(),\n              {\n                v: t,\n                r,\n                s: n\n              } = this;\n            this._validateHighS();\n            try {\n              return (0, u.ecrecover)(e, t + BigInt(27), (0, u.bigIntToUnpaddedUint8Array)(r), (0, u.bigIntToUnpaddedUint8Array)(n));\n            } catch (e) {\n              const t = this._errorMsg(\"Invalid Signature\");\n              throw new Error(t);\n            }\n          }\n          _processSignature(e, t, r) {\n            const n = Object.assign(Object.assign({}, this.txOptions), {\n              common: this.common\n            });\n            return h.fromTxData({\n              chainId: this.chainId,\n              nonce: this.nonce,\n              gasPrice: this.gasPrice,\n              gasLimit: this.gasLimit,\n              to: this.to,\n              value: this.value,\n              data: this.data,\n              accessList: this.accessList,\n              v: e - BigInt(27),\n              r: (0, u.uint8ArrayToBigInt)(t),\n              s: (0, u.uint8ArrayToBigInt)(r)\n            }, n);\n          }\n          toJSON() {\n            const e = (0, c.getAccessListJSON)(this.accessList);\n            return {\n              chainId: (0, u.bigIntToHex)(this.chainId),\n              nonce: (0, u.bigIntToHex)(this.nonce),\n              gasPrice: (0, u.bigIntToHex)(this.gasPrice),\n              gasLimit: (0, u.bigIntToHex)(this.gasLimit),\n              to: void 0 !== this.to ? this.to.toString() : void 0,\n              value: (0, u.bigIntToHex)(this.value),\n              data: (0, s.bytesToHex)(this.data),\n              accessList: e,\n              v: void 0 !== this.v ? (0, u.bigIntToHex)(this.v) : void 0,\n              r: void 0 !== this.r ? (0, u.bigIntToHex)(this.r) : void 0,\n              s: void 0 !== this.s ? (0, u.bigIntToHex)(this.s) : void 0\n            };\n          }\n          errorStr() {\n            var e, t;\n            let r = this._getSharedErrorPostfix();\n            return r += ` gasPrice=${this.gasPrice} accessListCount=${null !== (t = null === (e = this.accessList) || void 0 === e ? void 0 : e.length) && void 0 !== t ? t : 0}`, r;\n          }\n          _errorMsg(e) {\n            return `${e} (${this.errorStr()})`;\n          }\n        }\n        t.AccessListEIP2930Transaction = h;\n      },\n      9275: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          i = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return o(t, e), t;\n          },\n          s = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.txUtils = t.BaseTransaction = t.TransactionFactory = t.Transaction = t.AccessListEIP2930Transaction = t.FeeMarketEIP1559Transaction = void 0;\n        var a = r(6135);\n        Object.defineProperty(t, \"FeeMarketEIP1559Transaction\", {\n          enumerable: !0,\n          get: function () {\n            return a.FeeMarketEIP1559Transaction;\n          }\n        });\n        var c = r(9013);\n        Object.defineProperty(t, \"AccessListEIP2930Transaction\", {\n          enumerable: !0,\n          get: function () {\n            return c.AccessListEIP2930Transaction;\n          }\n        });\n        var u = r(5381);\n        Object.defineProperty(t, \"Transaction\", {\n          enumerable: !0,\n          get: function () {\n            return u.Transaction;\n          }\n        });\n        var d = r(7668);\n        Object.defineProperty(t, \"TransactionFactory\", {\n          enumerable: !0,\n          get: function () {\n            return d.TransactionFactory;\n          }\n        });\n        var l = r(915);\n        Object.defineProperty(t, \"BaseTransaction\", {\n          enumerable: !0,\n          get: function () {\n            return l.BaseTransaction;\n          }\n        }), t.txUtils = i(r(4562)), s(r(9964), t);\n      },\n      5381: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Transaction = void 0;\n        const n = r(7256),\n          o = r(7423),\n          i = r(9634),\n          s = r(7345),\n          a = r(2290),\n          c = r(4555),\n          u = r(915),\n          d = r(9964);\n        function l(e, t) {\n          const r = Number(e),\n            n = 2 * Number(t);\n          return r === n + 35 || r === n + 36;\n        }\n        class h extends u.BaseTransaction {\n          constructor(e, t = {}) {\n            var r;\n            if (super(Object.assign(Object.assign({}, e), {\n              type: 0\n            }), t), this.common = this._validateTxV(this.v, t.common), this.gasPrice = (0, a.uint8ArrayToBigInt)((0, a.toUint8Array)(\"\" === e.gasPrice ? \"0x\" : e.gasPrice)), this.gasPrice * this.gasLimit > c.MAX_INTEGER) {\n              const e = this._errorMsg(\"gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)\");\n              throw new Error(e);\n            }\n            this._validateCannotExceedMaxInteger({\n              gasPrice: this.gasPrice\n            }), u.BaseTransaction._validateNotArray(e), this.common.gteHardfork(\"spuriousDragon\") && (this.isSigned() ? l(this.v, this.common.chainId()) && this.activeCapabilities.push(d.Capability.EIP155ReplayProtection) : this.activeCapabilities.push(d.Capability.EIP155ReplayProtection)), (null === (r = null == t ? void 0 : t.freeze) || void 0 === r || r) && Object.freeze(this);\n          }\n          static fromTxData(e, t = {}) {\n            return new h(e, t);\n          }\n          static fromSerializedTx(e, t = {}) {\n            const r = n.RLP.decode(e);\n            if (!Array.isArray(r)) throw new Error(\"Invalid serialized tx input. Must be array\");\n            return this.fromValuesArray(r, t);\n          }\n          static fromValuesArray(e, t = {}) {\n            if (6 !== e.length && 9 !== e.length) throw new Error(\"Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).\");\n            const [r, n, o, i, a, c, u, d, l] = e;\n            return (0, s.validateNoLeadingZeroes)({\n              nonce: r,\n              gasPrice: n,\n              gasLimit: o,\n              value: a,\n              v: u,\n              r: d,\n              s: l\n            }), new h({\n              nonce: r,\n              gasPrice: n,\n              gasLimit: o,\n              to: i,\n              value: a,\n              data: c,\n              v: u,\n              r: d,\n              s: l\n            }, t);\n          }\n          raw() {\n            return [(0, a.bigIntToUnpaddedUint8Array)(this.nonce), (0, a.bigIntToUnpaddedUint8Array)(this.gasPrice), (0, a.bigIntToUnpaddedUint8Array)(this.gasLimit), void 0 !== this.to ? this.to.buf : Uint8Array.from([]), (0, a.bigIntToUnpaddedUint8Array)(this.value), this.data, void 0 !== this.v ? (0, a.bigIntToUnpaddedUint8Array)(this.v) : Uint8Array.from([]), void 0 !== this.r ? (0, a.bigIntToUnpaddedUint8Array)(this.r) : Uint8Array.from([]), void 0 !== this.s ? (0, a.bigIntToUnpaddedUint8Array)(this.s) : Uint8Array.from([])];\n          }\n          serialize() {\n            return n.RLP.encode(this.raw());\n          }\n          _getMessageToSign() {\n            const e = [(0, a.bigIntToUnpaddedUint8Array)(this.nonce), (0, a.bigIntToUnpaddedUint8Array)(this.gasPrice), (0, a.bigIntToUnpaddedUint8Array)(this.gasLimit), void 0 !== this.to ? this.to.buf : Uint8Array.from([]), (0, a.bigIntToUnpaddedUint8Array)(this.value), this.data];\n            return this.supports(d.Capability.EIP155ReplayProtection) && (e.push((0, a.toUint8Array)(this.common.chainId())), e.push((0, a.unpadUint8Array)((0, a.toUint8Array)(0))), e.push((0, a.unpadUint8Array)((0, a.toUint8Array)(0)))), e;\n          }\n          getMessageToSign(e = !0) {\n            const t = this._getMessageToSign();\n            return e ? (0, o.keccak256)(n.RLP.encode(t)) : t;\n          }\n          getDataFee() {\n            return this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork() ? this.cache.dataFee.value : (Object.isFrozen(this) && (this.cache.dataFee = {\n              value: super.getDataFee(),\n              hardfork: this.common.hardfork()\n            }), super.getDataFee());\n          }\n          getUpfrontCost() {\n            return this.gasLimit * this.gasPrice + this.value;\n          }\n          hash() {\n            if (!this.isSigned()) {\n              const e = this._errorMsg(\"Cannot call hash method if transaction is not signed\");\n              throw new Error(e);\n            }\n            return Object.isFrozen(this) ? (this.cache.hash || (this.cache.hash = (0, o.keccak256)(n.RLP.encode(this.raw()))), this.cache.hash) : (0, o.keccak256)(n.RLP.encode(this.raw()));\n          }\n          getMessageToVerifySignature() {\n            if (!this.isSigned()) {\n              const e = this._errorMsg(\"This transaction is not signed\");\n              throw new Error(e);\n            }\n            const e = this._getMessageToSign();\n            return (0, o.keccak256)(n.RLP.encode(e));\n          }\n          getSenderPublicKey() {\n            const e = this.getMessageToVerifySignature(),\n              {\n                v: t,\n                r,\n                s: n\n              } = this;\n            this._validateHighS();\n            try {\n              return (0, a.ecrecover)(e, t, (0, a.bigIntToUnpaddedUint8Array)(r), (0, a.bigIntToUnpaddedUint8Array)(n), this.supports(d.Capability.EIP155ReplayProtection) ? this.common.chainId() : void 0);\n            } catch (e) {\n              const t = this._errorMsg(\"Invalid Signature\");\n              throw new Error(t);\n            }\n          }\n          _processSignature(e, t, r) {\n            let n = e;\n            this.supports(d.Capability.EIP155ReplayProtection) && (n += this.common.chainId() * BigInt(2) + BigInt(8));\n            const o = Object.assign(Object.assign({}, this.txOptions), {\n              common: this.common\n            });\n            return h.fromTxData({\n              nonce: this.nonce,\n              gasPrice: this.gasPrice,\n              gasLimit: this.gasLimit,\n              to: this.to,\n              value: this.value,\n              data: this.data,\n              v: n,\n              r: (0, a.uint8ArrayToBigInt)(t),\n              s: (0, a.uint8ArrayToBigInt)(r)\n            }, o);\n          }\n          toJSON() {\n            return {\n              nonce: (0, a.bigIntToHex)(this.nonce),\n              gasPrice: (0, a.bigIntToHex)(this.gasPrice),\n              gasLimit: (0, a.bigIntToHex)(this.gasLimit),\n              to: void 0 !== this.to ? this.to.toString() : void 0,\n              value: (0, a.bigIntToHex)(this.value),\n              data: (0, i.bytesToHex)(this.data),\n              v: void 0 !== this.v ? (0, a.bigIntToHex)(this.v) : void 0,\n              r: void 0 !== this.r ? (0, a.bigIntToHex)(this.r) : void 0,\n              s: void 0 !== this.s ? (0, a.bigIntToHex)(this.s) : void 0\n            };\n          }\n          _validateTxV(e, t) {\n            let r;\n            const n = void 0 !== e ? Number(e) : void 0;\n            if (void 0 !== n && n < 37 && 27 !== n && 28 !== n) throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${n}`);\n            if (void 0 !== n && 0 !== n && (!t || t.gteHardfork(\"spuriousDragon\")) && 27 !== n && 28 !== n) if (t) {\n              if (!l(BigInt(n), t.chainId())) throw new Error(`Incompatible EIP155-based V ${n} and chain id ${t.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`);\n            } else {\n              let e;\n              e = (n - 35) % 2 == 0 ? 35 : 36, r = BigInt(n - e) / BigInt(2);\n            }\n            return this._getCommon(t, r);\n          }\n          errorStr() {\n            let e = this._getSharedErrorPostfix();\n            return e += ` gasPrice=${this.gasPrice}`, e;\n          }\n          _errorMsg(e) {\n            return `${e} (${this.errorStr()})`;\n          }\n        }\n        t.Transaction = h;\n      },\n      7668: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.TransactionFactory = void 0;\n        const n = r(9634),\n          o = r(2290),\n          i = r(6135),\n          s = r(9013),\n          a = r(5381),\n          c = new Map();\n        class u {\n          constructor() {}\n          static typeToInt(e) {\n            return Number((0, o.uint8ArrayToBigInt)((0, o.toUint8Array)(e)));\n          }\n          static registerTransactionType(e, t) {\n            const r = u.typeToInt(e);\n            c.set(r, t);\n          }\n          static fromTxData(e, t = {}) {\n            if (!(\"type\" in e) || void 0 === e.type) return a.Transaction.fromTxData(e, t);\n            const r = u.typeToInt(e.type);\n            if (0 === r) return a.Transaction.fromTxData(e, t);\n            if (1 === r) return s.AccessListEIP2930Transaction.fromTxData(e, t);\n            if (2 === r) return i.FeeMarketEIP1559Transaction.fromTxData(e, t);\n            const n = c.get(r);\n            if (null == n ? void 0 : n.fromTxData) return n.fromTxData(e, t);\n            throw new Error(`Tx instantiation with type ${r} not supported`);\n          }\n          static fromSerializedData(e, t = {}) {\n            if (!(e[0] <= 127)) return a.Transaction.fromSerializedTx(e, t);\n            switch (e[0]) {\n              case 1:\n                return s.AccessListEIP2930Transaction.fromSerializedTx(e, t);\n              case 2:\n                return i.FeeMarketEIP1559Transaction.fromSerializedTx(e, t);\n              default:\n                {\n                  const r = c.get(Number(e[0]));\n                  if (null == r ? void 0 : r.fromSerializedTx) return r.fromSerializedTx(e, t);\n                  throw new Error(`TypedTransaction with ID ${e[0]} unknown`);\n                }\n            }\n          }\n          static fromBlockBodyData(e, t = {}) {\n            if ((0, n.isUint8Array)(e)) return this.fromSerializedData(e, t);\n            if (Array.isArray(e)) return a.Transaction.fromValuesArray(e, t);\n            throw new Error(\"Cannot decode transaction: unknown type input\");\n          }\n        }\n        t.TransactionFactory = u;\n      },\n      9964: (e, t) => {\n        \"use strict\";\n\n        function r(e) {\n          if (0 === e.length) return !0;\n          const t = e[0];\n          return !!Array.isArray(t);\n        }\n        var n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isAccessList = t.isAccessListUint8Array = t.Capability = void 0, (n = t.Capability || (t.Capability = {}))[n.EIP155ReplayProtection = 155] = \"EIP155ReplayProtection\", n[n.EIP1559FeeMarket = 1559] = \"EIP1559FeeMarket\", n[n.EIP2718TypedTransaction = 2718] = \"EIP2718TypedTransaction\", n[n.EIP2930AccessLists = 2930] = \"EIP2930AccessLists\", t.isAccessListUint8Array = r, t.isAccessList = function (e) {\n          return !r(e);\n        };\n      },\n      4562: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getDataFeeEIP2930 = t.getAccessListJSON = t.verifyAccessList = t.getAccessListData = t.checkMaxInitCodeSize = void 0;\n        const n = r(9634),\n          o = r(2290),\n          i = r(9964);\n        t.checkMaxInitCodeSize = (e, t) => {\n          const r = e.param(\"vm\", \"maxInitCodeSize\");\n          if (r && BigInt(t) > r) throw new Error(`the initcode size of this transaction is too large: it is ${t} while the max is ${e.param(\"vm\", \"maxInitCodeSize\")}`);\n        }, t.getAccessListData = e => {\n          let t, r;\n          if ((0, i.isAccessList)(e)) {\n            t = e;\n            const n = [];\n            for (let t = 0; t < e.length; t += 1) {\n              const r = e[t],\n                i = (0, o.toUint8Array)(r.address),\n                s = [];\n              for (let e = 0; e < r.storageKeys.length; e += 1) s.push((0, o.toUint8Array)(r.storageKeys[e]));\n              n.push([i, s]);\n            }\n            r = n;\n          } else {\n            r = null != e ? e : [];\n            const o = [];\n            for (let e = 0; e < r.length; e += 1) {\n              const t = r[e],\n                i = (0, n.bytesToHex)(t[0]),\n                s = [];\n              for (let e = 0; e < t[1].length; e += 1) s.push((0, n.bytesToHex)(t[1][e]));\n              const a = {\n                address: i,\n                storageKeys: s\n              };\n              o.push(a);\n            }\n            t = o;\n          }\n          return {\n            AccessListJSON: t,\n            accessList: r\n          };\n        }, t.verifyAccessList = e => {\n          for (let t = 0; t < e.length; t += 1) {\n            const r = e[t],\n              n = r[0],\n              o = r[1];\n            if (void 0 !== r[2]) throw new Error(\"Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.\");\n            if (20 !== n.length) throw new Error(\"Invalid EIP-2930 transaction: address length should be 20 bytes\");\n            for (let e = 0; e < o.length; e += 1) if (32 !== o[e].length) throw new Error(\"Invalid EIP-2930 transaction: storage slot length should be 32 bytes\");\n          }\n        }, t.getAccessListJSON = e => {\n          const t = [];\n          for (let r = 0; r < e.length; r += 1) {\n            const i = e[r],\n              s = {\n                address: (0, n.bytesToHex)((0, o.setLengthLeft)(i[0], 20)),\n                storageKeys: []\n              },\n              a = i && i[1];\n            for (let e = 0; e < a.length; e += 1) {\n              const t = a[e];\n              s.storageKeys.push((0, n.bytesToHex)((0, o.setLengthLeft)(t, 32)));\n            }\n            t.push(s);\n          }\n          return t;\n        }, t.getDataFeeEIP2930 = (e, t) => {\n          const r = t.param(\"gasPrices\", \"accessListStorageKeyCost\"),\n            n = t.param(\"gasPrices\", \"accessListAddressCost\");\n          let o = 0;\n          for (let t = 0; t < e.length; t += 1) o += e[t][1].length;\n          return e.length * Number(n) + o * Number(r);\n        };\n      },\n      4874: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      8632: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Wallet = void 0;\n        const o = r(9970),\n          i = r(7345);\n        class s extends o.Web3BaseWallet {\n          constructor() {\n            super(...arguments), this._addressMap = new Map(), this._defaultKeyName = \"web3js_wallet\";\n          }\n          static getStorage() {\n            let e;\n            try {\n              e = window.localStorage;\n              const t = \"__storage_test__\";\n              return e.setItem(t, t), e.removeItem(t), e;\n            } catch (t) {\n              return !t || 22 !== t.code && 1014 !== t.code && \"QuotaExceededError\" !== t.name && \"NS_ERROR_DOM_QUOTA_REACHED\" !== t.name || (0, i.isNullish)(e) || 0 === e.length ? void 0 : e;\n            }\n          }\n          create(e) {\n            for (let t = 0; t < e; t += 1) this.add(this._accountProvider.create());\n            return this;\n          }\n          add(e) {\n            var t;\n            if (\"string\" == typeof e) return this.add(this._accountProvider.privateKeyToAccount(e));\n            let r = this.length;\n            return this.get(e.address) && (console.warn(`Account ${e.address.toLowerCase()} already exists.`), r = null !== (t = this._addressMap.get(e.address.toLowerCase())) && void 0 !== t ? t : r), this._addressMap.set(e.address.toLowerCase(), r), this[r] = e, this;\n          }\n          get(e) {\n            if (\"string\" == typeof e) {\n              const t = this._addressMap.get(e.toLowerCase());\n              return (0, i.isNullish)(t) ? void 0 : this[t];\n            }\n            return this[e];\n          }\n          remove(e) {\n            if (\"string\" == typeof e) {\n              const t = this._addressMap.get(e.toLowerCase());\n              return !(0, i.isNullish)(t) && (this._addressMap.delete(e.toLowerCase()), this.splice(t, 1), !0);\n            }\n            return !!this[e] && (this.splice(e, 1), !0);\n          }\n          clear() {\n            return this._addressMap.clear(), this.length = 0, this;\n          }\n          encrypt(e, t) {\n            return n(this, void 0, void 0, function* () {\n              return Promise.all(this.map(r => n(this, void 0, void 0, function* () {\n                return r.encrypt(e, t);\n              })));\n            });\n          }\n          decrypt(e, t, r) {\n            return n(this, void 0, void 0, function* () {\n              const o = yield Promise.all(e.map(e => n(this, void 0, void 0, function* () {\n                return this._accountProvider.decrypt(e, t, r);\n              })));\n              for (const e of o) this.add(e);\n              return this;\n            });\n          }\n          save(e, t) {\n            return n(this, void 0, void 0, function* () {\n              const r = s.getStorage();\n              if (!r) throw new Error(\"Local storage not available.\");\n              return r.setItem(null != t ? t : this._defaultKeyName, JSON.stringify(yield this.encrypt(e))), !0;\n            });\n          }\n          load(e, t) {\n            return n(this, void 0, void 0, function* () {\n              const r = s.getStorage();\n              if (!r) throw new Error(\"Local storage not available.\");\n              const n = r.getItem(null != t ? t : this._defaultKeyName);\n              return n && (yield this.decrypt(JSON.parse(n) || [], e)), this;\n            });\n          }\n        }\n        t.Wallet = s;\n      },\n      6658: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Contract = void 0;\n        const o = r(6527),\n          i = r(5071),\n          s = r(6637),\n          a = r(8381),\n          c = r(9970),\n          u = r(9634),\n          d = r(7345),\n          l = r(5537),\n          h = r(7388),\n          f = r(3948),\n          p = {\n            logs: h.LogsSubscription,\n            newHeads: s.NewHeadsSubscription,\n            newBlockHeaders: s.NewHeadsSubscription\n          };\n        class m extends o.Web3Context {\n          constructor(e, t, r, n, s) {\n            var a, c, l;\n            const h = (0, u.isContractInitOptions)(t) ? t : (0, u.isContractInitOptions)(r) ? r : void 0;\n            let g, y;\n            if (g = (0, f.isWeb3ContractContext)(t) ? t : (0, f.isWeb3ContractContext)(r) ? r : n, y = \"object\" == typeof t && \"provider\" in t ? t.provider : \"object\" == typeof r && \"provider\" in r ? r.provider : \"object\" == typeof n && \"provider\" in n ? n.provider : m.givenProvider, super(Object.assign(Object.assign({}, g), {\n              provider: y,\n              registeredSubscriptions: p\n            })), this.syncWithContext = !1, this._functions = {}, (null == g ? void 0 : g.wallet) && (this._wallet = g.wallet), (null == g ? void 0 : g.accountProvider) && (this._accountProvider = g.accountProvider), !(0, d.isNullish)(h) && !(0, d.isNullish)(h.data) && !(0, d.isNullish)(h.input) && \"both\" !== this.config.contractDataInputFill) throw new i.ContractTransactionDataAndInputError({\n              data: h.data,\n              input: h.input\n            });\n            this._overloadedMethodAbis = new Map();\n            const v = (0, u.isDataFormat)(n) ? n : (0, u.isDataFormat)(r) ? r : null != s ? s : this.defaultReturnFormat,\n              b = \"string\" == typeof t ? t : void 0;\n            this.config.contractDataInputFill = null !== (a = null == h ? void 0 : h.dataInputFill) && void 0 !== a ? a : this.config.contractDataInputFill, this._parseAndSetJsonInterface(e, v), this.defaultReturnFormat !== v && (this.defaultReturnFormat = v), (0, d.isNullish)(b) || this._parseAndSetAddress(b, v), this.options = {\n              address: b,\n              jsonInterface: this._jsonInterface,\n              gas: null !== (c = null == h ? void 0 : h.gas) && void 0 !== c ? c : null == h ? void 0 : h.gasLimit,\n              gasPrice: null == h ? void 0 : h.gasPrice,\n              from: null == h ? void 0 : h.from,\n              input: null == h ? void 0 : h.input,\n              data: null == h ? void 0 : h.data\n            }, this.syncWithContext = null !== (l = null == h ? void 0 : h.syncWithContext) && void 0 !== l && l, g instanceof o.Web3Context && this.subscribeToContextEvents(g), Object.defineProperty(this.options, \"address\", {\n              set: e => this._parseAndSetAddress(e, v),\n              get: () => this._address\n            }), Object.defineProperty(this.options, \"jsonInterface\", {\n              set: e => this._parseAndSetJsonInterface(e, v),\n              get: () => this._jsonInterface\n            }), g instanceof o.Web3Context && g.on(o.Web3ConfigEvent.CONFIG_CHANGE, e => {\n              this.setConfig({\n                [e.name]: e.newValue\n              });\n            });\n          }\n          get events() {\n            return this._events;\n          }\n          get methods() {\n            return this._methods;\n          }\n          clone() {\n            let e;\n            return e = this.options.address ? new m([...this._jsonInterface, ...this._errorsInterface], this.options.address, {\n              gas: this.options.gas,\n              gasPrice: this.options.gasPrice,\n              from: this.options.from,\n              input: this.options.input,\n              data: this.options.data,\n              provider: this.currentProvider,\n              syncWithContext: this.syncWithContext,\n              dataInputFill: this.config.contractDataInputFill\n            }, this.getContextObject()) : new m([...this._jsonInterface, ...this._errorsInterface], {\n              gas: this.options.gas,\n              gasPrice: this.options.gasPrice,\n              from: this.options.from,\n              input: this.options.input,\n              data: this.options.data,\n              provider: this.currentProvider,\n              syncWithContext: this.syncWithContext,\n              dataInputFill: this.config.contractDataInputFill\n            }, this.getContextObject()), this.context && e.subscribeToContextEvents(this.context), e;\n          }\n          deploy(e) {\n            var t, r, o;\n            let s = this._jsonInterface.find(e => \"constructor\" === e.type);\n            s || (s = {\n              type: \"constructor\",\n              stateMutability: \"\"\n            });\n            const a = (0, u.format)({\n                format: \"bytes\"\n              }, null !== (t = null == e ? void 0 : e.input) && void 0 !== t ? t : this.options.input, c.DEFAULT_RETURN_FORMAT),\n              d = (0, u.format)({\n                format: \"bytes\"\n              }, null !== (r = null == e ? void 0 : e.data) && void 0 !== r ? r : this.options.data, c.DEFAULT_RETURN_FORMAT);\n            if (!(a && \"0x\" !== a.trim() || d && \"0x\" !== d.trim())) throw new i.Web3ContractError(\"contract creation without any data provided.\");\n            const h = null !== (o = null == e ? void 0 : e.arguments) && void 0 !== o ? o : [],\n              f = Object.assign(Object.assign({}, this.options), {\n                input: a,\n                data: d\n              }),\n              p = null != a ? a : d;\n            return {\n              arguments: h,\n              send: e => {\n                const t = Object.assign({}, e);\n                return this._contractMethodDeploySend(s, h, t, f);\n              },\n              estimateGas: (e, t = this.defaultReturnFormat) => n(this, void 0, void 0, function* () {\n                const r = Object.assign({}, e);\n                return this._contractMethodEstimateGas({\n                  abi: s,\n                  params: h,\n                  returnFormat: t,\n                  options: r,\n                  contractOptions: f\n                });\n              }),\n              encodeABI: () => (0, l.encodeMethodABI)(s, h, (0, u.format)({\n                format: \"bytes\"\n              }, p, this.defaultReturnFormat)),\n              decodeData: e => Object.assign(Object.assign({}, (0, l.decodeMethodParams)(s, e.replace(p, \"\"), !1)), {\n                __method__: s.type\n              })\n            };\n          }\n          getPastEvents(e, t, r) {\n            var o;\n            return n(this, void 0, void 0, function* () {\n              const n = \"string\" == typeof e ? e : s.ALL_EVENTS,\n                a = \"string\" == typeof e || (0, u.isDataFormat)(e) ? (0, u.isDataFormat)(t) ? {} : t : e,\n                c = (0, u.isDataFormat)(e) ? e : (0, u.isDataFormat)(t) ? t : null != r ? r : this.defaultReturnFormat,\n                d = \"allEvents\" === n || n === s.ALL_EVENTS ? s.ALL_EVENTS_ABI : this._jsonInterface.find(e => \"name\" in e && e.name === n);\n              if (!d) throw new i.Web3ContractError(`Event ${n} not found.`);\n              const {\n                  fromBlock: h,\n                  toBlock: f,\n                  topics: p,\n                  address: m\n                } = (0, l.encodeEventABI)(this.options, d, null != a ? a : {}),\n                g = yield (0, s.getLogs)(this, {\n                  fromBlock: h,\n                  toBlock: f,\n                  topics: p,\n                  address: m\n                }, c),\n                y = g ? g.map(e => \"string\" == typeof e ? e : (0, s.decodeEventABI)(d, e, this._jsonInterface, c)) : [],\n                v = null !== (o = null == a ? void 0 : a.filter) && void 0 !== o ? o : {},\n                b = Object.keys(v);\n              return b.length > 0 ? y.filter(e => \"string\" == typeof e || b.every(t => {\n                var r;\n                if (Array.isArray(v[t])) return v[t].some(r => String(e.returnValues[t]).toUpperCase() === String(r).toUpperCase());\n                const n = null === (r = d.inputs) || void 0 === r ? void 0 : r.filter(e => e.name === t)[0];\n                return !(!(null == n ? void 0 : n.indexed) || \"string\" !== n.type || (0, u.keccak256)(v[t]) !== String(e.returnValues[t])) || String(e.returnValues[t]).toUpperCase() === String(v[t]).toUpperCase();\n              })) : y;\n            });\n          }\n          _parseAndSetAddress(e, t = this.defaultReturnFormat) {\n            this._address = e ? (0, u.toChecksumAddress)((0, u.format)({\n              format: \"address\"\n            }, e, t)) : e;\n          }\n          decodeMethodData(e) {\n            const t = e.slice(0, 10),\n              r = this._jsonInterface.filter(e => \"error\" !== e.type).find(e => t === (0, a.encodeFunctionSignature)((0, a.jsonInterfaceMethodToString)(e)));\n            if (!r) throw new i.Web3ContractError(`The ABI for the provided method signature ${t} was not found.`);\n            return Object.assign(Object.assign({}, (0, l.decodeMethodParams)(r, e)), {\n              __method__: (0, a.jsonInterfaceMethodToString)(r)\n            });\n          }\n          _parseAndSetJsonInterface(e, t = this.defaultReturnFormat) {\n            var r, n, o, i, c;\n            this._functions = {}, this._methods = {}, this._events = {};\n            let u = [];\n            const d = e.filter(e => \"error\" !== e.type),\n              l = e.filter(e => (0, a.isAbiErrorFragment)(e));\n            for (const e of d) {\n              const s = Object.assign(Object.assign({}, e), {\n                signature: \"\"\n              });\n              if ((0, a.isAbiFunctionFragment)(s)) {\n                const e = (0, a.jsonInterfaceMethodToString)(s),\n                  t = (0, a.encodeFunctionSignature)(e);\n                s.methodNameWithInputs = e, s.signature = t, s.constant = null !== (n = null !== (r = \"view\" === s.stateMutability) && void 0 !== r ? r : \"pure\" === s.stateMutability) && void 0 !== n ? n : s.constant, s.payable = null !== (o = \"payable\" === s.stateMutability) && void 0 !== o ? o : s.payable, this._overloadedMethodAbis.set(s.name, [...(null !== (i = this._overloadedMethodAbis.get(s.name)) && void 0 !== i ? i : []), s]);\n                const u = null !== (c = this._overloadedMethodAbis.get(s.name)) && void 0 !== c ? c : [],\n                  d = this._createContractMethod(u, l),\n                  h = this._createContractMethod(u, l, !0);\n                this._functions[e] = {\n                  signature: t,\n                  method: h\n                }, this._methods[s.name] = d, this._methods[e] = h, this._methods[t] = h;\n              } else if ((0, a.isAbiEventFragment)(s)) {\n                const e = (0, a.jsonInterfaceMethodToString)(s),\n                  r = (0, a.encodeEventSignature)(e),\n                  n = this._createContractEvent(s, t);\n                s.signature = r, e in this._events && \"bound\" !== s.name || (this._events[e] = n), this._events[s.name] = n, this._events[r] = n;\n              }\n              u = [...u, s];\n            }\n            this._events.allEvents = this._createContractEvent(s.ALL_EVENTS_ABI, t), this._jsonInterface = [...u], this._errorsInterface = l;\n          }\n          _getAbiParams(e, t) {\n            var r;\n            try {\n              return d.utils.transformJsonDataToAbiFormat(null !== (r = e.inputs) && void 0 !== r ? r : [], t);\n            } catch (t) {\n              throw new i.Web3ContractError(`Invalid parameters for method ${e.name}: ${t.message}`);\n            }\n          }\n          _createContractMethod(e, t, r = !1) {\n            const o = e[e.length - 1];\n            return (...e) => {\n              var i, s, a;\n              let c;\n              const u = null !== (s = r ? null === (i = this._overloadedMethodAbis.get(o.name)) || void 0 === i ? void 0 : i.filter(e => e.signature === o.signature) : this._overloadedMethodAbis.get(o.name)) && void 0 !== s ? s : [];\n              let h = u[0];\n              const f = t,\n                p = u.filter(t => {\n                  var r;\n                  return (null !== (r = t.inputs) && void 0 !== r ? r : []).length === e.length;\n                });\n              if (1 === u.length || 0 === p.length) c = this._getAbiParams(h, e), d.validator.validate(null !== (a = o.inputs) && void 0 !== a ? a : [], c);else {\n                const t = [],\n                  r = [];\n                for (const n of p) try {\n                  c = this._getAbiParams(n, e), d.validator.validate(n.inputs, c), r.push(n);\n                } catch (e) {\n                  t.push(e);\n                }\n                if (1 === r.length ? [h] = r : r.length > 1 && ([h] = r, console.warn(`Multiple methods found that is compatible with the given inputs.\\n\\tFound ${r.length} compatible methods: ${JSON.stringify(r.map(e => `${e.methodNameWithInputs} (signature: ${e.signature})`))} \\n\\tThe first one will be used: ${h.methodNameWithInputs}`)), t.length === p.length) throw new d.Web3ValidatorError(t);\n              }\n              const m = {\n                arguments: c,\n                call: (e, t) => n(this, void 0, void 0, function* () {\n                  return this._contractMethodCall(h, c, f, e, t);\n                }),\n                send: e => this._contractMethodSend(h, c, f, e),\n                estimateGas: (e, t = this.defaultReturnFormat) => n(this, void 0, void 0, function* () {\n                  return this._contractMethodEstimateGas({\n                    abi: h,\n                    params: c,\n                    returnFormat: t,\n                    options: e\n                  });\n                }),\n                encodeABI: () => (0, l.encodeMethodABI)(h, c),\n                decodeData: e => (0, l.decodeMethodParams)(h, e),\n                createAccessList: (e, t) => n(this, void 0, void 0, function* () {\n                  return this._contractMethodCreateAccessList(h, c, f, e, t);\n                })\n              };\n              return h.stateMutability, m;\n            };\n          }\n          _contractMethodCall(e, t, r, o, c) {\n            var u;\n            return n(this, void 0, void 0, function* () {\n              const n = (0, f.getEthTxCallParams)({\n                abi: e,\n                params: t,\n                options: Object.assign(Object.assign({}, o), {\n                  dataInputFill: this.config.contractDataInputFill\n                }),\n                contractOptions: Object.assign(Object.assign({}, this.options), {\n                  from: null !== (u = this.options.from) && void 0 !== u ? u : this.config.defaultAccount\n                })\n              });\n              try {\n                const t = yield (0, s.call)(this, n, c, this.defaultReturnFormat);\n                return (0, l.decodeMethodReturn)(e, t);\n              } catch (e) {\n                throw e instanceof i.ContractExecutionError && (0, a.decodeContractErrorData)(r, e.cause), e;\n              }\n            });\n          }\n          _contractMethodCreateAccessList(e, t, r, o, c) {\n            var u;\n            return n(this, void 0, void 0, function* () {\n              const n = (0, f.getCreateAccessListParams)({\n                abi: e,\n                params: t,\n                options: Object.assign(Object.assign({}, o), {\n                  dataInputFill: this.config.contractDataInputFill\n                }),\n                contractOptions: Object.assign(Object.assign({}, this.options), {\n                  from: null !== (u = this.options.from) && void 0 !== u ? u : this.config.defaultAccount\n                })\n              });\n              try {\n                return (0, s.createAccessList)(this, n, c, this.defaultReturnFormat);\n              } catch (e) {\n                throw e instanceof i.ContractExecutionError && (0, a.decodeContractErrorData)(r, e.cause), e;\n              }\n            });\n          }\n          _contractMethodSend(e, t, r, n, o) {\n            var c, u;\n            let d = null != o ? o : this.options;\n            d = Object.assign(Object.assign({}, d), {\n              input: void 0,\n              from: null !== (u = null !== (c = d.from) && void 0 !== c ? c : this.defaultAccount) && void 0 !== u ? u : void 0\n            });\n            const l = (0, f.getSendTxParams)({\n                abi: e,\n                params: t,\n                options: Object.assign(Object.assign({}, n), {\n                  dataInputFill: this.config.contractDataInputFill\n                }),\n                contractOptions: d\n              }),\n              h = (0, s.sendTransaction)(this, l, this.defaultReturnFormat, {\n                checkRevertBeforeSending: !1,\n                contractAbi: this._jsonInterface\n              });\n            return h.on(\"error\", e => {\n              e instanceof i.ContractExecutionError && (0, a.decodeContractErrorData)(r, e.cause);\n            }), h;\n          }\n          _contractMethodDeploySend(e, t, r, n) {\n            var o, a;\n            let c = null != n ? n : this.options;\n            c = Object.assign(Object.assign({}, c), {\n              from: null !== (a = null !== (o = c.from) && void 0 !== o ? o : this.defaultAccount) && void 0 !== a ? a : void 0\n            });\n            const u = (0, f.getSendTxParams)({\n              abi: e,\n              params: t,\n              options: Object.assign(Object.assign({}, r), {\n                dataInputFill: this.contractDataInputFill\n              }),\n              contractOptions: c\n            });\n            return (0, s.sendTransaction)(this, u, this.defaultReturnFormat, {\n              transactionResolver: e => {\n                if (e.status === BigInt(0)) throw new i.Web3ContractError(\"code couldn't be stored\", e);\n                const t = this.clone();\n                return t.options.address = e.contractAddress, t;\n              },\n              contractAbi: this._jsonInterface,\n              checkRevertBeforeSending: !1\n            });\n          }\n          _contractMethodEstimateGas({\n            abi: e,\n            params: t,\n            returnFormat: r,\n            options: o,\n            contractOptions: i\n          }) {\n            return n(this, void 0, void 0, function* () {\n              const n = (0, f.getEstimateGasParams)({\n                abi: e,\n                params: t,\n                options: Object.assign(Object.assign({}, o), {\n                  dataInputFill: this.config.contractDataInputFill\n                }),\n                contractOptions: null != i ? i : this.options\n              });\n              return (0, s.estimateGas)(this, n, c.BlockTags.LATEST, null != r ? r : this.defaultReturnFormat);\n            });\n          }\n          _createContractEvent(e, t = this.defaultReturnFormat) {\n            return (...r) => {\n              var n;\n              const {\n                  topics: o,\n                  fromBlock: s\n                } = (0, l.encodeEventABI)(this.options, e, r[0]),\n                a = new h.LogsSubscription({\n                  address: this.options.address,\n                  topics: o,\n                  abi: e,\n                  jsonInterface: this._jsonInterface\n                }, {\n                  subscriptionManager: this.subscriptionManager,\n                  returnFormat: t\n                });\n              return (0, d.isNullish)(s) || this.getPastEvents(e.name, {\n                fromBlock: s,\n                topics: o\n              }, t).then(e => {\n                e && e.forEach(e => a.emit(\"data\", e));\n              }).catch(e => {\n                a.emit(\"error\", new i.SubscriptionError(\"Failed to get past events.\", e));\n              }), null === (n = this.subscriptionManager) || void 0 === n || n.addSubscription(a).catch(e => {\n                a.emit(\"error\", new i.SubscriptionError(\"Failed to subscribe.\", e));\n              }), a;\n            };\n          }\n          subscribeToContextEvents(e) {\n            const t = this;\n            this.context = e, t.syncWithContext && e.on(o.Web3ConfigEvent.CONFIG_CHANGE, e => {\n              t.setConfig({\n                [e.name]: e.newValue\n              });\n            });\n          }\n        }\n        t.Contract = m;\n      },\n      5537: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeMethodReturn = t.decodeMethodParams = t.encodeMethodABI = t.encodeEventABI = t.decodeEventABI = void 0;\n        const n = r(9634),\n          o = r(9970),\n          i = r(8381),\n          s = r(6637),\n          a = r(5071);\n        var c = r(6637);\n        Object.defineProperty(t, \"decodeEventABI\", {\n          enumerable: !0,\n          get: function () {\n            return c.decodeEventABI;\n          }\n        }), t.encodeEventABI = ({\n          address: e\n        }, t, r) => {\n          var a, c;\n          const u = null == r ? void 0 : r.topics,\n            d = null !== (a = null == r ? void 0 : r.filter) && void 0 !== a ? a : {},\n            l = {};\n          if ((0, n.isNullish)(null == r ? void 0 : r.fromBlock) || (l.fromBlock = (0, n.format)(s.blockSchema.properties.number, null == r ? void 0 : r.fromBlock, {\n            number: o.FMT_NUMBER.HEX,\n            bytes: o.FMT_BYTES.HEX\n          })), (0, n.isNullish)(null == r ? void 0 : r.toBlock) || (l.toBlock = (0, n.format)(s.blockSchema.properties.number, null == r ? void 0 : r.toBlock, {\n            number: o.FMT_NUMBER.HEX,\n            bytes: o.FMT_BYTES.HEX\n          })), u && Array.isArray(u)) l.topics = [...u];else if (l.topics = [], !t || t.anonymous || [s.ALL_EVENTS, \"allEvents\"].includes(t.name) || l.topics.push(null !== (c = t.signature) && void 0 !== c ? c : (0, i.encodeEventSignature)((0, i.jsonInterfaceMethodToString)(t))), ![s.ALL_EVENTS, \"allEvents\"].includes(t.name) && t.inputs) for (const e of t.inputs) {\n            if (!e.indexed) continue;\n            const t = d[e.name];\n            t ? Array.isArray(t) ? l.topics.push(t.map(t => (0, i.encodeParameter)(e.type, t))) : \"string\" === e.type ? l.topics.push((0, n.keccak256)(t)) : l.topics.push((0, i.encodeParameter)(e.type, t)) : l.topics.push(null);\n          }\n          return l.topics.length || delete l.topics, e && (l.address = e.toLowerCase()), l;\n        }, t.encodeMethodABI = (e, t, r) => {\n          const n = Array.isArray(e.inputs) ? e.inputs.length : 0;\n          if (e.inputs && n !== t.length) throw new a.Web3ContractError(`The number of arguments is not matching the methods required number. You need to pass ${n} arguments.`);\n          let o;\n          if (o = e.inputs ? (0, i.encodeParameters)(Array.isArray(e.inputs) ? e.inputs : [], t).replace(\"0x\", \"\") : (0, i.inferTypesAndEncodeParameters)(t).replace(\"0x\", \"\"), (0, i.isAbiConstructorFragment)(e)) {\n            if (!r) throw new a.Web3ContractError(\"The contract has no contract data option set. This is necessary to append the constructor parameters.\");\n            return r.startsWith(\"0x\") ? `${r}${o}` : `0x${r}${o}`;\n          }\n          return `${(0, i.encodeFunctionSignature)(e)}${o}`;\n        }, t.decodeMethodParams = (e, t, r = !0) => {\n          const n = r && t && t.length >= 10 && t.startsWith(\"0x\") ? t.slice(10) : t;\n          if (!e.inputs) throw new a.Web3ContractError(\"No inputs found in the ABI\");\n          return (0, i.decodeParameters)([...e.inputs], n);\n        }, t.decodeMethodReturn = (e, t) => {\n          if (\"constructor\" === e.type) return t;\n          if (!t) return null;\n          const r = t.length >= 2 ? t.slice(2) : t;\n          if (!e.outputs) return null;\n          const n = (0, i.decodeParameters)([...e.outputs], r);\n          return 1 === n.__length__ ? n[0] : n;\n        };\n      },\n      3211: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n        const i = r(6658);\n        o(r(5537), t), o(r(6658), t), o(r(7388), t), o(r(3951), t), o(r(3948), t), t.default = i.Contract;\n      },\n      7388: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.LogsSubscription = void 0;\n        const n = r(6527),\n          o = r(6637);\n        class i extends n.Web3Subscription {\n          constructor(e, t) {\n            super(e, t), this.address = e.address, this.topics = e.topics, this.abi = e.abi, this.jsonInterface = e.jsonInterface;\n          }\n          _buildSubscriptionParams() {\n            return [\"logs\", {\n              address: this.address,\n              topics: this.topics\n            }];\n          }\n          formatSubscriptionResult(e) {\n            return (0, o.decodeEventABI)(this.abi, e, this.jsonInterface, super.returnFormat);\n          }\n        }\n        t.LogsSubscription = i;\n      },\n      3951: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      3948: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getCreateAccessListParams = t.isWeb3ContractContext = t.getEstimateGasParams = t.getEthTxCallParams = t.getSendTxParams = void 0;\n        const n = r(5071),\n          o = r(9634),\n          i = r(5537),\n          s = (e, t, r, n) => {\n            var s, a;\n            const c = {};\n            return (0, o.isNullish)(e.data) && \"both\" !== n || (c.data = (0, i.encodeMethodABI)(t, r, null !== (s = e.data) && void 0 !== s ? s : e.input)), (0, o.isNullish)(e.input) && \"both\" !== n || (c.input = (0, i.encodeMethodABI)(t, r, null !== (a = e.input) && void 0 !== a ? a : e.data)), (0, o.isNullish)(c.input) && (0, o.isNullish)(c.data) && (c[n] = (0, i.encodeMethodABI)(t, r)), {\n              data: c.data,\n              input: c.input\n            };\n          };\n        t.getSendTxParams = ({\n          abi: e,\n          params: t,\n          options: r,\n          contractOptions: i\n        }) => {\n          var a, c, u;\n          if (!(null !== (u = null !== (c = null !== (a = null == r ? void 0 : r.input) && void 0 !== a ? a : null == r ? void 0 : r.data) && void 0 !== c ? c : i.input) && void 0 !== u ? u : i.data) && !(null == r ? void 0 : r.to) && !i.address) throw new n.Web3ContractError(\"Contract address not specified\");\n          if (!(null == r ? void 0 : r.from) && !i.from) throw new n.Web3ContractError('Contract \"from\" address not specified');\n          let d = (0, o.mergeDeep)({\n            to: i.address,\n            gas: i.gas,\n            gasPrice: i.gasPrice,\n            from: i.from,\n            input: i.input,\n            maxPriorityFeePerGas: i.maxPriorityFeePerGas,\n            maxFeePerGas: i.maxFeePerGas,\n            data: i.data\n          }, r);\n          const l = s(d, e, t, null == r ? void 0 : r.dataInputFill);\n          return d = Object.assign(Object.assign({}, d), {\n            data: l.data,\n            input: l.input\n          }), d;\n        }, t.getEthTxCallParams = ({\n          abi: e,\n          params: t,\n          options: r,\n          contractOptions: i\n        }) => {\n          if (!(null == r ? void 0 : r.to) && !i.address) throw new n.Web3ContractError(\"Contract address not specified\");\n          let a = (0, o.mergeDeep)({\n            to: i.address,\n            gas: i.gas,\n            gasPrice: i.gasPrice,\n            from: i.from,\n            input: i.input,\n            maxPriorityFeePerGas: i.maxPriorityFeePerGas,\n            maxFeePerGas: i.maxFeePerGas,\n            data: i.data\n          }, r);\n          const c = s(a, e, t, null == r ? void 0 : r.dataInputFill);\n          return a = Object.assign(Object.assign({}, a), {\n            data: c.data,\n            input: c.input\n          }), a;\n        }, t.getEstimateGasParams = ({\n          abi: e,\n          params: t,\n          options: r,\n          contractOptions: n\n        }) => {\n          let i = (0, o.mergeDeep)({\n            to: n.address,\n            gas: n.gas,\n            gasPrice: n.gasPrice,\n            from: n.from,\n            input: n.input,\n            data: n.data\n          }, r);\n          const a = s(i, e, t, null == r ? void 0 : r.dataInputFill);\n          return i = Object.assign(Object.assign({}, i), {\n            data: a.data,\n            input: a.input\n          }), i;\n        }, t.isWeb3ContractContext = e => \"object\" == typeof e && !(0, o.isNullish)(e) && 0 !== Object.keys(e).length && !(0, o.isContractInitOptions)(e), t.getCreateAccessListParams = ({\n          abi: e,\n          params: t,\n          options: r,\n          contractOptions: i\n        }) => {\n          if (!(null == r ? void 0 : r.to) && !i.address) throw new n.Web3ContractError(\"Contract address not specified\");\n          if (!(null == r ? void 0 : r.from) && !i.from) throw new n.Web3ContractError('Contract \"from\" address not specified');\n          let a = (0, o.mergeDeep)({\n            to: i.address,\n            gas: i.gas,\n            gasPrice: i.gasPrice,\n            from: i.from,\n            input: i.input,\n            maxPriorityFeePerGas: i.maxPriorityFeePerGas,\n            maxFeePerGas: i.maxFeePerGas,\n            data: i.data\n          }, r);\n          const c = s(a, e, t, null == r ? void 0 : r.dataInputFill);\n          return a = Object.assign(Object.assign({}, a), {\n            data: c.data,\n            input: c.input\n          }), a;\n        };\n      },\n      6919: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ENSRegistryAbi = void 0, t.ENSRegistryAbi = [{\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"label\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"address\",\n            name: \"owner\",\n            type: \"address\"\n          }],\n          name: \"NewOwner\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"address\",\n            name: \"resolver\",\n            type: \"address\"\n          }],\n          name: \"NewResolver\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"address\",\n            name: \"owner\",\n            type: \"address\"\n          }],\n          name: \"Transfer\",\n          type: \"event\"\n        }, {\n          inputs: [{\n            internalType: \"address\",\n            name: \"owner\",\n            type: \"address\"\n          }, {\n            internalType: \"address\",\n            name: \"operator\",\n            type: \"address\"\n          }],\n          name: \"isApprovedForAll\",\n          outputs: [{\n            internalType: \"bool\",\n            name: \"\",\n            type: \"bool\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"owner\",\n          outputs: [{\n            internalType: \"address\",\n            name: \"\",\n            type: \"address\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"recordExists\",\n          outputs: [{\n            internalType: \"bool\",\n            name: \"\",\n            type: \"bool\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"resolver\",\n          outputs: [{\n            internalType: \"address\",\n            name: \"\",\n            type: \"address\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"ttl\",\n          outputs: [{\n            internalType: \"uint64\",\n            name: \"\",\n            type: \"uint64\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }];\n      },\n      172: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.PublicResolverAbi = void 0, t.PublicResolverAbi = [{\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"address\",\n            name: \"a\",\n            type: \"address\"\n          }],\n          name: \"AddrChanged\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"uint256\",\n            name: \"coinType\",\n            type: \"uint256\"\n          }, {\n            indexed: !1,\n            internalType: \"bytes\",\n            name: \"newAddress\",\n            type: \"bytes\"\n          }],\n          name: \"AddressChanged\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"address\",\n            name: \"owner\",\n            type: \"address\"\n          }, {\n            indexed: !0,\n            internalType: \"address\",\n            name: \"operator\",\n            type: \"address\"\n          }, {\n            indexed: !1,\n            internalType: \"bool\",\n            name: \"approved\",\n            type: \"bool\"\n          }],\n          name: \"ApprovalForAll\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"bytes\",\n            name: \"hash\",\n            type: \"bytes\"\n          }],\n          name: \"ContenthashChanged\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"bytes\",\n            name: \"name\",\n            type: \"bytes\"\n          }, {\n            indexed: !1,\n            internalType: \"uint16\",\n            name: \"resource\",\n            type: \"uint16\"\n          }, {\n            indexed: !1,\n            internalType: \"bytes\",\n            name: \"record\",\n            type: \"bytes\"\n          }],\n          name: \"DNSRecordChanged\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"bytes\",\n            name: \"name\",\n            type: \"bytes\"\n          }, {\n            indexed: !1,\n            internalType: \"uint16\",\n            name: \"resource\",\n            type: \"uint16\"\n          }],\n          name: \"DNSRecordDeleted\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"DNSZoneCleared\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"bytes\",\n            name: \"lastzonehash\",\n            type: \"bytes\"\n          }, {\n            indexed: !1,\n            internalType: \"bytes\",\n            name: \"zonehash\",\n            type: \"bytes\"\n          }],\n          name: \"DNSZonehashChanged\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !0,\n            internalType: \"bytes4\",\n            name: \"interfaceID\",\n            type: \"bytes4\"\n          }, {\n            indexed: !1,\n            internalType: \"address\",\n            name: \"implementer\",\n            type: \"address\"\n          }],\n          name: \"InterfaceChanged\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"string\",\n            name: \"name\",\n            type: \"string\"\n          }],\n          name: \"NameChanged\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"bytes32\",\n            name: \"x\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"bytes32\",\n            name: \"y\",\n            type: \"bytes32\"\n          }],\n          name: \"PubkeyChanged\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !0,\n            internalType: \"string\",\n            name: \"indexedKey\",\n            type: \"string\"\n          }, {\n            indexed: !1,\n            internalType: \"string\",\n            name: \"key\",\n            type: \"string\"\n          }],\n          name: \"TextChanged\",\n          type: \"event\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            internalType: \"uint256\",\n            name: \"contentTypes\",\n            type: \"uint256\"\n          }],\n          name: \"ABI\",\n          outputs: [{\n            internalType: \"uint256\",\n            name: \"\",\n            type: \"uint256\"\n          }, {\n            internalType: \"bytes\",\n            name: \"\",\n            type: \"bytes\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"addr\",\n          outputs: [{\n            internalType: \"address payable\",\n            name: \"\",\n            type: \"address\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            internalType: \"uint256\",\n            name: \"coinType\",\n            type: \"uint256\"\n          }],\n          name: \"addr\",\n          outputs: [{\n            internalType: \"bytes\",\n            name: \"\",\n            type: \"bytes\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"contenthash\",\n          outputs: [{\n            internalType: \"bytes\",\n            name: \"\",\n            type: \"bytes\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            internalType: \"bytes32\",\n            name: \"name\",\n            type: \"bytes32\"\n          }, {\n            internalType: \"uint16\",\n            name: \"resource\",\n            type: \"uint16\"\n          }],\n          name: \"dnsRecord\",\n          outputs: [{\n            internalType: \"bytes\",\n            name: \"\",\n            type: \"bytes\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            internalType: \"bytes32\",\n            name: \"name\",\n            type: \"bytes32\"\n          }],\n          name: \"hasDNSRecords\",\n          outputs: [{\n            internalType: \"bool\",\n            name: \"\",\n            type: \"bool\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            internalType: \"bytes4\",\n            name: \"interfaceID\",\n            type: \"bytes4\"\n          }],\n          name: \"interfaceImplementer\",\n          outputs: [{\n            internalType: \"address\",\n            name: \"\",\n            type: \"address\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"address\",\n            name: \"account\",\n            type: \"address\"\n          }, {\n            internalType: \"address\",\n            name: \"operator\",\n            type: \"address\"\n          }],\n          name: \"isApprovedForAll\",\n          outputs: [{\n            internalType: \"bool\",\n            name: \"\",\n            type: \"bool\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"name\",\n          outputs: [{\n            internalType: \"string\",\n            name: \"\",\n            type: \"string\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"pubkey\",\n          outputs: [{\n            internalType: \"bytes32\",\n            name: \"x\",\n            type: \"bytes32\"\n          }, {\n            internalType: \"bytes32\",\n            name: \"y\",\n            type: \"bytes32\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes4\",\n            name: \"interfaceID\",\n            type: \"bytes4\"\n          }],\n          name: \"supportsInterface\",\n          outputs: [{\n            internalType: \"bool\",\n            name: \"\",\n            type: \"bool\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            internalType: \"string\",\n            name: \"key\",\n            type: \"string\"\n          }],\n          name: \"text\",\n          outputs: [{\n            internalType: \"string\",\n            name: \"\",\n            type: \"string\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"zonehash\",\n          outputs: [{\n            internalType: \"bytes\",\n            name: \"\",\n            type: \"bytes\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            internalType: \"address\",\n            name: \"a\",\n            type: \"address\"\n          }],\n          name: \"setAddr\",\n          outputs: [],\n          stateMutability: \"nonpayable\",\n          type: \"function\"\n        }];\n      },\n      8677: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.networkIds = t.registryAddresses = t.methodsInInterface = t.interfaceIds = void 0, t.interfaceIds = {\n          addr: \"0x3b3b57de\",\n          name: \"0x691f3431\",\n          abi: \"0x2203ab56\",\n          pubkey: \"0xc8690233\",\n          text: \"0x59d1d43c\",\n          contenthash: \"0xbc1c58d1\"\n        }, t.methodsInInterface = {\n          setAddr: \"addr\",\n          addr: \"addr\",\n          setPubkey: \"pubkey\",\n          pubkey: \"pubkey\",\n          setContenthash: \"contenthash\",\n          contenthash: \"contenthash\",\n          text: \"text\",\n          name: \"name\"\n        }, t.registryAddresses = {\n          main: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n          goerli: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\"\n        }, t.networkIds = {\n          \"0x1\": \"main\",\n          \"0x5\": \"goerli\"\n        };\n      },\n      9142: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ENS = void 0;\n        const o = r(6527),\n          i = r(5071),\n          s = r(6637),\n          a = r(9820),\n          c = r(9970),\n          u = r(7345),\n          d = r(8677),\n          l = r(67),\n          h = r(8067);\n        class f extends o.Web3Context {\n          constructor(e, t) {\n            super(null != t ? t : \"\"), this.registryAddress = null != e ? e : d.registryAddresses.main, this._registry = new l.Registry(this.getContextObject(), e), this._resolver = new h.Resolver(this._registry);\n          }\n          getResolver(e) {\n            return n(this, void 0, void 0, function* () {\n              return this._registry.getResolver(e);\n            });\n          }\n          recordExists(e) {\n            return n(this, void 0, void 0, function* () {\n              return this._registry.recordExists(e);\n            });\n          }\n          getTTL(e) {\n            return n(this, void 0, void 0, function* () {\n              return this._registry.getTTL(e);\n            });\n          }\n          getOwner(e) {\n            return n(this, void 0, void 0, function* () {\n              return this._registry.getOwner(e);\n            });\n          }\n          getAddress(e, t = 60) {\n            return n(this, void 0, void 0, function* () {\n              return this._resolver.getAddress(e, t);\n            });\n          }\n          getText(e, t) {\n            return n(this, void 0, void 0, function* () {\n              return (0, u.isAddress)(e) ? this._resolver.getText(yield this._resolver.getName(e, !1), t) : this._resolver.getText(e, t);\n            });\n          }\n          getName(e, t = !0) {\n            return n(this, void 0, void 0, function* () {\n              return this._resolver.getName(e, t);\n            });\n          }\n          getPubkey(e) {\n            return n(this, void 0, void 0, function* () {\n              return this._resolver.getPubkey(e);\n            });\n          }\n          getContenthash(e) {\n            return n(this, void 0, void 0, function* () {\n              return this._resolver.getContenthash(e);\n            });\n          }\n          checkNetwork() {\n            return n(this, void 0, void 0, function* () {\n              const e = Date.now() / 1e3;\n              if (!this._lastSyncCheck || e - this._lastSyncCheck > 3600) {\n                const t = yield (0, s.isSyncing)(this);\n                if (\"boolean\" != typeof t || t) throw new i.ENSNetworkNotSyncedError();\n                this._lastSyncCheck = e;\n              }\n              if (this._detectedAddress) return this._detectedAddress;\n              const t = yield (0, a.getId)(this, Object.assign(Object.assign({}, this.defaultReturnFormat), {\n                  number: c.FMT_NUMBER.HEX\n                })),\n                r = d.registryAddresses[d.networkIds[t]];\n              if (void 0 === r) throw new i.ENSUnsupportedNetworkError(t);\n              return this._detectedAddress = r, this._detectedAddress;\n            });\n          }\n          supportsInterface(e, t) {\n            return n(this, void 0, void 0, function* () {\n              return this._resolver.supportsInterface(e, t);\n            });\n          }\n          get events() {\n            return this._registry.events;\n          }\n          setAddress(e, t, r) {\n            return n(this, void 0, void 0, function* () {\n              return this._resolver.setAddress(e, t, r);\n            });\n          }\n        }\n        t.ENS = f;\n      },\n      1698: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.registryAddresses = void 0;\n        const i = r(8677);\n        Object.defineProperty(t, \"registryAddresses\", {\n          enumerable: !0,\n          get: function () {\n            return i.registryAddresses;\n          }\n        }), o(r(9142), t);\n      },\n      67: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Registry = void 0;\n        const o = r(3211),\n          i = r(6919),\n          s = r(172),\n          a = r(8677),\n          c = r(8196);\n        t.Registry = class {\n          constructor(e, t) {\n            this.contract = new o.Contract(i.ENSRegistryAbi, null != t ? t : a.registryAddresses.main, e), this.context = e;\n          }\n          getOwner(e) {\n            return n(this, void 0, void 0, function* () {\n              try {\n                return this.contract.methods.owner((0, c.namehash)(e)).call();\n              } catch (e) {\n                throw new Error();\n              }\n            });\n          }\n          getTTL(e) {\n            return n(this, void 0, void 0, function* () {\n              try {\n                return this.contract.methods.ttl((0, c.namehash)(e)).call();\n              } catch (e) {\n                throw new Error();\n              }\n            });\n          }\n          recordExists(e) {\n            return n(this, void 0, void 0, function* () {\n              try {\n                return this.contract.methods.recordExists((0, c.namehash)(e)).call();\n              } catch (e) {\n                throw new Error();\n              }\n            });\n          }\n          getResolver(e) {\n            return n(this, void 0, void 0, function* () {\n              try {\n                return this.contract.methods.resolver((0, c.namehash)(e)).call().then(e => {\n                  if (\"string\" == typeof e) return new o.Contract(s.PublicResolverAbi, e, this.context);\n                  throw new Error();\n                });\n              } catch (e) {\n                throw new Error();\n              }\n            });\n          }\n          get events() {\n            return this.contract.events;\n          }\n        };\n      },\n      8067: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Resolver = void 0;\n        const o = r(5071),\n          i = r(9634),\n          s = r(7345),\n          a = r(8677),\n          c = r(8196);\n        t.Resolver = class {\n          constructor(e) {\n            this.registry = e;\n          }\n          getResolverContractAdapter(e) {\n            return n(this, void 0, void 0, function* () {\n              return this.registry.getResolver(e);\n            });\n          }\n          checkInterfaceSupport(e, t) {\n            var r, s;\n            return n(this, void 0, void 0, function* () {\n              if ((0, i.isNullish)(a.interfaceIds[t])) throw new o.ResolverMethodMissingError(null !== (r = e.options.address) && void 0 !== r ? r : \"\", t);\n              if (!(yield e.methods.supportsInterface(a.interfaceIds[t]).call())) throw new o.ResolverMethodMissingError(null !== (s = e.options.address) && void 0 !== s ? s : \"\", t);\n            });\n          }\n          supportsInterface(e, t) {\n            var r;\n            return n(this, void 0, void 0, function* () {\n              const n = yield this.getResolverContractAdapter(e);\n              let o = t;\n              if (!(0, s.isHexStrict)(o)) {\n                if (o = null !== (r = (0, i.sha3)(t)) && void 0 !== r ? r : \"\", \"\" === t) throw new Error(\"Invalid interface Id\");\n                o = o.slice(0, 10);\n              }\n              return n.methods.supportsInterface(o).call();\n            });\n          }\n          getAddress(e, t = 60) {\n            return n(this, void 0, void 0, function* () {\n              const r = yield this.getResolverContractAdapter(e);\n              return yield this.checkInterfaceSupport(r, a.methodsInInterface.addr), r.methods.addr((0, c.namehash)(e), t).call();\n            });\n          }\n          getPubkey(e) {\n            return n(this, void 0, void 0, function* () {\n              const t = yield this.getResolverContractAdapter(e);\n              return yield this.checkInterfaceSupport(t, a.methodsInInterface.pubkey), t.methods.pubkey((0, c.namehash)(e)).call();\n            });\n          }\n          getContenthash(e) {\n            return n(this, void 0, void 0, function* () {\n              const t = yield this.getResolverContractAdapter(e);\n              return yield this.checkInterfaceSupport(t, a.methodsInInterface.contenthash), t.methods.contenthash((0, c.namehash)(e)).call();\n            });\n          }\n          setAddress(e, t, r) {\n            return n(this, void 0, void 0, function* () {\n              const n = yield this.getResolverContractAdapter(e);\n              return yield this.checkInterfaceSupport(n, a.methodsInInterface.setAddr), n.methods.setAddr((0, c.namehash)(e), t).send(r);\n            });\n          }\n          getText(e, t) {\n            return n(this, void 0, void 0, function* () {\n              const r = yield this.getResolverContractAdapter(e);\n              return yield this.checkInterfaceSupport(r, a.methodsInInterface.text), r.methods.text((0, c.namehash)(e), t).call();\n            });\n          }\n          getName(e, t = !0) {\n            return n(this, void 0, void 0, function* () {\n              const r = `${e.toLowerCase().substring(2)}.addr.reverse`,\n                n = yield this.getResolverContractAdapter(r);\n              return t && (yield this.checkInterfaceSupport(n, a.methodsInInterface.name)), n.methods.name((0, c.namehash)(r)).call();\n            });\n          }\n        };\n      },\n      8196: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.namehash = t.normalize = void 0;\n        const n = r(9634),\n          o = r(6608);\n        t.normalize = e => (0, o.ens_normalize)(e), t.namehash = e => {\n          let r = \"\";\n          for (let e = 0; e < 32; e += 1) r += \"00\";\n          if (e) {\n            const o = (0, t.normalize)(e).split(\".\");\n            for (let e = o.length - 1; e >= 0; e -= 1) {\n              const t = (0, n.sha3Raw)(o[e]).slice(2);\n              r = (0, n.sha3Raw)(`0x${r}${t}`).slice(2);\n            }\n          }\n          return `0x${r}`;\n        };\n      },\n      5609: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Iban = void 0;\n        const n = r(9634),\n          o = r(7345),\n          i = r(5071);\n        class s {\n          constructor(e) {\n            if (this.toAddress = () => {\n              if (this.isDirect()) {\n                const e = this._iban.slice(4),\n                  t = s._parseInt(e, 36),\n                  r = (0, n.leftPad)(t, 40);\n                return (0, n.toChecksumAddress)(r);\n              }\n              throw new Error(\"Iban is indirect and cannot be converted. Must be length of 34 or 35\");\n            }, !s.isIndirect(e) && !s.isDirect(e)) throw new Error(\"Invalid IBAN was provided\");\n            this._iban = e;\n          }\n          static isDirect(e) {\n            return 34 === e.length || 35 === e.length;\n          }\n          isDirect() {\n            return s.isDirect(this._iban);\n          }\n          static isIndirect(e) {\n            return 20 === e.length;\n          }\n          isIndirect() {\n            return s.isIndirect(this._iban);\n          }\n          static isValid(e) {\n            return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(e) && 1 === s._mod9710(s._iso13616Prepare(e));\n          }\n          isValid() {\n            return s.isValid(this._iban);\n          }\n          static fromBban(e) {\n            const t = `0${(98 - this._mod9710(this._iso13616Prepare(`XE00${e}`))).toString()}`.slice(-2);\n            return new s(`XE${t}${e}`);\n          }\n          static createIndirect(e) {\n            return s.fromBban(`ETH${e.institution}${e.identifier}`);\n          }\n          static fromAddress(e) {\n            if (!(0, o.isAddress)(e)) throw new i.InvalidAddressError(e);\n            const t = BigInt((0, n.hexToNumber)(e)).toString(36),\n              r = (0, n.leftPad)(t, 15);\n            return s.fromBban(r.toUpperCase());\n          }\n          static toIban(e) {\n            return s.fromAddress(e).toString();\n          }\n          client() {\n            return this.isIndirect() ? this._iban.slice(11) : \"\";\n          }\n          checksum() {\n            return this._iban.slice(2, 4);\n          }\n          institution() {\n            return this.isIndirect() ? this._iban.slice(7, 11) : \"\";\n          }\n          toString() {\n            return this._iban;\n          }\n        }\n        t.Iban = s, s._iso13616Prepare = e => {\n          const t = \"A\".charCodeAt(0),\n            r = \"Z\".charCodeAt(0),\n            n = e.toUpperCase();\n          return `${n.slice(4)}${n.slice(0, 4)}`.split(\"\").map(e => {\n            const n = e.charCodeAt(0);\n            return n >= t && n <= r ? n - t + 10 : e;\n          }).join(\"\");\n        }, s._parseInt = (e, t) => [...e].reduce((e, r) => BigInt(parseInt(r, t)) + BigInt(t) * e, BigInt(0)), s._mod9710 = e => {\n          let t,\n            r = e;\n          for (; r.length > 2;) t = r.slice(0, 9), r = `${(parseInt(t, 10) % 97).toString()}${r.slice(t.length)}`;\n          return parseInt(r, 10) % 97;\n        }, s.toAddress = e => new s(e).toAddress();\n      },\n      9910: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n        const i = r(5609);\n        o(r(5609), t), o(r(1965), t), t.default = i.Iban;\n      },\n      1965: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      9757: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n        const i = r(9638);\n        o(r(9638), t), t.default = i.Personal;\n      },\n      9638: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          i = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return o(t, e), t;\n          },\n          s = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (o, i) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Personal = void 0;\n        const a = r(6527),\n          c = i(r(706));\n        class u extends a.Web3Context {\n          getAccounts() {\n            return s(this, void 0, void 0, function* () {\n              return c.getAccounts(this.requestManager);\n            });\n          }\n          newAccount(e) {\n            return s(this, void 0, void 0, function* () {\n              return c.newAccount(this.requestManager, e);\n            });\n          }\n          unlockAccount(e, t, r) {\n            return s(this, void 0, void 0, function* () {\n              return c.unlockAccount(this.requestManager, e, t, r);\n            });\n          }\n          lockAccount(e) {\n            return s(this, void 0, void 0, function* () {\n              return c.lockAccount(this.requestManager, e);\n            });\n          }\n          importRawKey(e, t) {\n            return s(this, void 0, void 0, function* () {\n              return c.importRawKey(this.requestManager, e, t);\n            });\n          }\n          sendTransaction(e, t) {\n            return s(this, void 0, void 0, function* () {\n              return c.sendTransaction(this.requestManager, e, t);\n            });\n          }\n          signTransaction(e, t) {\n            return s(this, void 0, void 0, function* () {\n              return c.signTransaction(this.requestManager, e, t);\n            });\n          }\n          sign(e, t, r) {\n            return s(this, void 0, void 0, function* () {\n              return c.sign(this.requestManager, e, t, r);\n            });\n          }\n          ecRecover(e, t) {\n            return s(this, void 0, void 0, function* () {\n              return c.ecRecover(this.requestManager, e, t);\n            });\n          }\n        }\n        t.Personal = u;\n      },\n      706: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ecRecover = t.sign = t.signTransaction = t.sendTransaction = t.importRawKey = t.lockAccount = t.unlockAccount = t.newAccount = t.getAccounts = void 0;\n        const o = r(9634),\n          i = r(6637),\n          s = r(9970),\n          a = r(7345),\n          c = r(1181);\n        t.getAccounts = e => n(void 0, void 0, void 0, function* () {\n          return (yield c.personalRpcMethods.getAccounts(e)).map(o.toChecksumAddress);\n        }), t.newAccount = (e, t) => n(void 0, void 0, void 0, function* () {\n          a.validator.validate([\"string\"], [t]);\n          const r = yield c.personalRpcMethods.newAccount(e, t);\n          return (0, o.toChecksumAddress)(r);\n        }), t.unlockAccount = (e, t, r, o) => n(void 0, void 0, void 0, function* () {\n          return a.validator.validate([\"address\", \"string\", \"uint\"], [t, r, o]), c.personalRpcMethods.unlockAccount(e, t, r, o);\n        }), t.lockAccount = (e, t) => n(void 0, void 0, void 0, function* () {\n          return a.validator.validate([\"address\"], [t]), c.personalRpcMethods.lockAccount(e, t);\n        }), t.importRawKey = (e, t, r) => n(void 0, void 0, void 0, function* () {\n          return a.validator.validate([\"string\", \"string\"], [t, r]), c.personalRpcMethods.importRawKey(e, t, r);\n        }), t.sendTransaction = (e, t, r) => n(void 0, void 0, void 0, function* () {\n          const n = (0, i.formatTransaction)(t, s.ETH_DATA_FORMAT);\n          return c.personalRpcMethods.sendTransaction(e, n, r);\n        }), t.signTransaction = (e, t, r) => n(void 0, void 0, void 0, function* () {\n          const n = (0, i.formatTransaction)(t, s.ETH_DATA_FORMAT);\n          return c.personalRpcMethods.signTransaction(e, n, r);\n        }), t.sign = (e, t, r, i) => n(void 0, void 0, void 0, function* () {\n          a.validator.validate([\"string\", \"address\", \"string\"], [t, r, i]);\n          const n = (0, a.isHexStrict)(t) ? t : (0, o.utf8ToHex)(t);\n          return c.personalRpcMethods.sign(e, n, r, i);\n        }), t.ecRecover = (e, t, r) => n(void 0, void 0, void 0, function* () {\n          a.validator.validate([\"string\", \"string\"], [t, r]);\n          const n = (0, a.isHexStrict)(t) ? t : (0, o.utf8ToHex)(t);\n          return c.personalRpcMethods.ecRecover(e, n, r);\n        });\n      },\n      9326: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.NUMBER_DATA_FORMAT = t.ALL_EVENTS_ABI = t.ALL_EVENTS = void 0;\n        const n = r(9970);\n        t.ALL_EVENTS = \"ALLEVENTS\", t.ALL_EVENTS_ABI = {\n          name: t.ALL_EVENTS,\n          signature: \"\",\n          type: \"event\",\n          inputs: []\n        }, t.NUMBER_DATA_FORMAT = {\n          bytes: n.FMT_BYTES.HEX,\n          number: n.FMT_NUMBER.NUMBER\n        };\n      },\n      6637: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SendTxHelper = t.trySendTransaction = t.waitForTransactionReceipt = t.getTransactionFromOrToAttr = t.transactionBuilder = t.detectTransactionType = void 0, r(6985);\n        const i = r(1435);\n        o(r(1435), t), o(r(7543), t), o(r(1922), t), o(r(9326), t), o(r(4832), t), o(r(8650), t), o(r(3222), t), o(r(5140), t), o(r(1258), t), o(r(7460), t);\n        var s = r(7350);\n        Object.defineProperty(t, \"detectTransactionType\", {\n          enumerable: !0,\n          get: function () {\n            return s.detectTransactionType;\n          }\n        });\n        var a = r(223);\n        Object.defineProperty(t, \"transactionBuilder\", {\n          enumerable: !0,\n          get: function () {\n            return a.transactionBuilder;\n          }\n        }), Object.defineProperty(t, \"getTransactionFromOrToAttr\", {\n          enumerable: !0,\n          get: function () {\n            return a.getTransactionFromOrToAttr;\n          }\n        });\n        var c = r(4745);\n        Object.defineProperty(t, \"waitForTransactionReceipt\", {\n          enumerable: !0,\n          get: function () {\n            return c.waitForTransactionReceipt;\n          }\n        });\n        var u = r(8425);\n        Object.defineProperty(t, \"trySendTransaction\", {\n          enumerable: !0,\n          get: function () {\n            return u.trySendTransaction;\n          }\n        });\n        var d = r(7322);\n        Object.defineProperty(t, \"SendTxHelper\", {\n          enumerable: !0,\n          get: function () {\n            return d.SendTxHelper;\n          }\n        }), t.default = i.Web3Eth;\n      },\n      3222: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (o, i) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__rest || function (e, t) {\n            var r = {};\n            for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);\n            if (null != e && \"function\" == typeof Object.getOwnPropertySymbols) {\n              var o = 0;\n              for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (r[n[o]] = e[n[o]]);\n            }\n            return r;\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.signTypedData = t.createAccessList = t.getFeeHistory = t.getProof = t.getChainId = t.getLogs = t.estimateGas = t.call = t.signTransaction = t.sign = t.sendSignedTransaction = t.sendTransaction = t.getTransactionCount = t.getTransactionReceipt = t.getTransactionFromBlock = t.getPendingTransactions = t.getTransaction = t.getUncle = t.getBlockUncleCount = t.getBlockTransactionCount = t.getBlock = t.getCode = t.getStorageAt = t.getBalance = t.getBlockNumber = t.getMaxPriorityFeePerGas = t.getGasPrice = t.getHashRate = t.isMining = t.getCoinbase = t.isSyncing = t.getProtocolVersion = void 0;\n        const i = r(9970),\n          s = r(6527),\n          a = r(9634),\n          c = r(9247),\n          u = r(7345),\n          d = r(5071),\n          l = r(1181),\n          h = r(5900),\n          f = r(1922),\n          p = r(223),\n          m = r(5140),\n          g = r(8425),\n          y = r(4745),\n          v = r(9326),\n          b = r(7322);\n        t.getProtocolVersion = e => n(void 0, void 0, void 0, function* () {\n          return l.ethRpcMethods.getProtocolVersion(e.requestManager);\n        }), t.isSyncing = e => n(void 0, void 0, void 0, function* () {\n          return l.ethRpcMethods.getSyncing(e.requestManager);\n        }), t.getCoinbase = e => n(void 0, void 0, void 0, function* () {\n          return l.ethRpcMethods.getCoinbase(e.requestManager);\n        }), t.isMining = e => n(void 0, void 0, void 0, function* () {\n          return l.ethRpcMethods.getMining(e.requestManager);\n        }), t.getHashRate = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            const r = yield l.ethRpcMethods.getHashRate(e.requestManager);\n            return (0, a.format)({\n              format: \"uint\"\n            }, r, null != t ? t : e.defaultReturnFormat);\n          });\n        }, t.getGasPrice = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            const r = yield l.ethRpcMethods.getGasPrice(e.requestManager);\n            return (0, a.format)({\n              format: \"uint\"\n            }, r, null != t ? t : e.defaultReturnFormat);\n          });\n        }, t.getMaxPriorityFeePerGas = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            const r = yield l.ethRpcMethods.getMaxPriorityFeePerGas(e.requestManager);\n            return (0, a.format)({\n              format: \"uint\"\n            }, r, null != t ? t : e.defaultReturnFormat);\n          });\n        }, t.getBlockNumber = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            const r = yield l.ethRpcMethods.getBlockNumber(e.requestManager);\n            return (0, a.format)({\n              format: \"uint\"\n            }, r, null != t ? t : e.defaultReturnFormat);\n          });\n        }, t.getBalance = function (e, t, r = e.defaultBlock, o) {\n          return n(this, void 0, void 0, function* () {\n            const n = (0, u.isBlockTag)(r) ? r : (0, a.format)({\n                format: \"uint\"\n              }, r, i.ETH_DATA_FORMAT),\n              s = yield l.ethRpcMethods.getBalance(e.requestManager, t, n);\n            return (0, a.format)({\n              format: \"uint\"\n            }, s, null != o ? o : e.defaultReturnFormat);\n          });\n        }, t.getStorageAt = function (e, t, r, o = e.defaultBlock, s) {\n          return n(this, void 0, void 0, function* () {\n            const n = (0, a.format)({\n                format: \"uint\"\n              }, r, i.ETH_DATA_FORMAT),\n              c = (0, u.isBlockTag)(o) ? o : (0, a.format)({\n                format: \"uint\"\n              }, o, i.ETH_DATA_FORMAT),\n              d = yield l.ethRpcMethods.getStorageAt(e.requestManager, t, n, c);\n            return (0, a.format)({\n              format: \"bytes\"\n            }, d, null != s ? s : e.defaultReturnFormat);\n          });\n        }, t.getCode = function (e, t, r = e.defaultBlock, o) {\n          return n(this, void 0, void 0, function* () {\n            const n = (0, u.isBlockTag)(r) ? r : (0, a.format)({\n                format: \"uint\"\n              }, r, i.ETH_DATA_FORMAT),\n              s = yield l.ethRpcMethods.getCode(e.requestManager, t, n);\n            return (0, a.format)({\n              format: \"bytes\"\n            }, s, null != o ? o : e.defaultReturnFormat);\n          });\n        }, t.getBlock = function (e, t = e.defaultBlock, r = !1, o) {\n          return n(this, void 0, void 0, function* () {\n            let n;\n            if ((0, u.isBytes)(t)) {\n              const o = (0, a.format)({\n                format: \"bytes32\"\n              }, t, i.ETH_DATA_FORMAT);\n              n = yield l.ethRpcMethods.getBlockByHash(e.requestManager, o, r);\n            } else {\n              const o = (0, u.isBlockTag)(t) ? t : (0, a.format)({\n                format: \"uint\"\n              }, t, i.ETH_DATA_FORMAT);\n              n = yield l.ethRpcMethods.getBlockByNumber(e.requestManager, o, r);\n            }\n            return (0, a.format)(f.blockSchema, n, null != o ? o : e.defaultReturnFormat);\n          });\n        }, t.getBlockTransactionCount = function (e, t = e.defaultBlock, r) {\n          return n(this, void 0, void 0, function* () {\n            let n;\n            if ((0, u.isBytes)(t)) {\n              const r = (0, a.format)({\n                format: \"bytes32\"\n              }, t, i.ETH_DATA_FORMAT);\n              n = yield l.ethRpcMethods.getBlockTransactionCountByHash(e.requestManager, r);\n            } else {\n              const r = (0, u.isBlockTag)(t) ? t : (0, a.format)({\n                format: \"uint\"\n              }, t, i.ETH_DATA_FORMAT);\n              n = yield l.ethRpcMethods.getBlockTransactionCountByNumber(e.requestManager, r);\n            }\n            return (0, a.format)({\n              format: \"uint\"\n            }, n, null != r ? r : e.defaultReturnFormat);\n          });\n        }, t.getBlockUncleCount = function (e, t = e.defaultBlock, r) {\n          return n(this, void 0, void 0, function* () {\n            let n;\n            if ((0, u.isBytes)(t)) {\n              const r = (0, a.format)({\n                format: \"bytes32\"\n              }, t, i.ETH_DATA_FORMAT);\n              n = yield l.ethRpcMethods.getUncleCountByBlockHash(e.requestManager, r);\n            } else {\n              const r = (0, u.isBlockTag)(t) ? t : (0, a.format)({\n                format: \"uint\"\n              }, t, i.ETH_DATA_FORMAT);\n              n = yield l.ethRpcMethods.getUncleCountByBlockNumber(e.requestManager, r);\n            }\n            return (0, a.format)({\n              format: \"uint\"\n            }, n, null != r ? r : e.defaultReturnFormat);\n          });\n        }, t.getUncle = function (e, t = e.defaultBlock, r, o) {\n          return n(this, void 0, void 0, function* () {\n            const n = (0, a.format)({\n              format: \"uint\"\n            }, r, i.ETH_DATA_FORMAT);\n            let s;\n            if ((0, u.isBytes)(t)) {\n              const r = (0, a.format)({\n                format: \"bytes32\"\n              }, t, i.ETH_DATA_FORMAT);\n              s = yield l.ethRpcMethods.getUncleByBlockHashAndIndex(e.requestManager, r, n);\n            } else {\n              const r = (0, u.isBlockTag)(t) ? t : (0, a.format)({\n                format: \"uint\"\n              }, t, i.ETH_DATA_FORMAT);\n              s = yield l.ethRpcMethods.getUncleByBlockNumberAndIndex(e.requestManager, r, n);\n            }\n            return (0, a.format)(f.blockSchema, s, null != o ? o : e.defaultReturnFormat);\n          });\n        }, t.getTransaction = function (e, t, r = e.defaultReturnFormat) {\n          return n(this, void 0, void 0, function* () {\n            const n = (0, a.format)({\n                format: \"bytes32\"\n              }, t, i.DEFAULT_RETURN_FORMAT),\n              o = yield l.ethRpcMethods.getTransactionByHash(e.requestManager, n);\n            return (0, u.isNullish)(o) ? o : (0, m.formatTransaction)(o, r, {\n              fillInputAndData: !0\n            });\n          });\n        }, t.getPendingTransactions = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return (yield l.ethRpcMethods.getPendingTransactions(e.requestManager)).map(r => (0, m.formatTransaction)(r, null != t ? t : e.defaultReturnFormat, {\n              fillInputAndData: !0\n            }));\n          });\n        }, t.getTransactionFromBlock = function (e, t = e.defaultBlock, r, o) {\n          return n(this, void 0, void 0, function* () {\n            const n = (0, a.format)({\n              format: \"uint\"\n            }, r, i.ETH_DATA_FORMAT);\n            let s;\n            if ((0, u.isBytes)(t)) {\n              const r = (0, a.format)({\n                format: \"bytes32\"\n              }, t, i.ETH_DATA_FORMAT);\n              s = yield l.ethRpcMethods.getTransactionByBlockHashAndIndex(e.requestManager, r, n);\n            } else {\n              const r = (0, u.isBlockTag)(t) ? t : (0, a.format)({\n                format: \"uint\"\n              }, t, i.ETH_DATA_FORMAT);\n              s = yield l.ethRpcMethods.getTransactionByBlockNumberAndIndex(e.requestManager, r, n);\n            }\n            return (0, u.isNullish)(s) ? s : (0, m.formatTransaction)(s, null != o ? o : e.defaultReturnFormat, {\n              fillInputAndData: !0\n            });\n          });\n        }, t.getTransactionReceipt = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            const n = (0, a.format)({\n                format: \"bytes32\"\n              }, t, i.DEFAULT_RETURN_FORMAT),\n              o = yield l.ethRpcMethods.getTransactionReceipt(e.requestManager, n);\n            return (0, u.isNullish)(o) ? o : (0, a.format)(f.transactionReceiptSchema, o, null != r ? r : e.defaultReturnFormat);\n          });\n        }, t.getTransactionCount = function (e, t, r = e.defaultBlock, o) {\n          return n(this, void 0, void 0, function* () {\n            const n = (0, u.isBlockTag)(r) ? r : (0, a.format)({\n                format: \"uint\"\n              }, r, i.ETH_DATA_FORMAT),\n              s = yield l.ethRpcMethods.getTransactionCount(e.requestManager, t, n);\n            return (0, a.format)({\n              format: \"uint\"\n            }, s, null != o ? o : e.defaultReturnFormat);\n          });\n        }, t.sendTransaction = function (e, t, r, o = {\n          checkRevertBeforeSending: !0\n        }, c) {\n          const d = new s.Web3PromiEvent((s, l) => {\n            setImmediate(() => {\n              (() => {\n                n(this, void 0, void 0, function* () {\n                  const n = new b.SendTxHelper({\n                    web3Context: e,\n                    promiEvent: d,\n                    options: o,\n                    returnFormat: r\n                  });\n                  let h = Object.assign({}, t);\n                  (0, u.isNullish)(c) || (h = yield c.processTransaction(h));\n                  let g = (0, m.formatTransaction)(Object.assign(Object.assign({}, h), {\n                    from: (0, p.getTransactionFromOrToAttr)(\"from\", e, h),\n                    to: (0, p.getTransactionFromOrToAttr)(\"to\", e, h)\n                  }), i.ETH_DATA_FORMAT);\n                  try {\n                    let t;\n                    g = yield n.populateGasPrice({\n                      transaction: h,\n                      transactionFormatted: g\n                    }), yield n.checkRevertBeforeSending(g), n.emitSending(g), e.wallet && !(0, u.isNullish)(g.from) && (t = e.wallet.get(g.from));\n                    const o = yield n.signAndSend({\n                        wallet: t,\n                        tx: g\n                      }),\n                      i = (0, a.format)({\n                        format: \"bytes32\"\n                      }, o, null != r ? r : e.defaultReturnFormat);\n                    n.emitSent(g), n.emitTransactionHash(i);\n                    const c = yield (0, y.waitForTransactionReceipt)(e, o, null != r ? r : e.defaultReturnFormat),\n                      d = n.getReceiptWithEvents((0, a.format)(f.transactionReceiptSchema, c, null != r ? r : e.defaultReturnFormat));\n                    n.emitReceipt(d), s(yield n.handleResolve({\n                      receipt: d,\n                      tx: g\n                    })), n.emitConfirmation({\n                      receipt: d,\n                      transactionHash: o\n                    });\n                  } catch (e) {\n                    l(yield n.handleError({\n                      error: e,\n                      tx: g\n                    }));\n                  }\n                });\n              })();\n            });\n          });\n          return d;\n        }, t.sendSignedTransaction = function (e, t, r, u = {\n          checkRevertBeforeSending: !0\n        }) {\n          const d = new s.Web3PromiEvent((s, h) => {\n            setImmediate(() => {\n              (() => {\n                n(this, void 0, void 0, function* () {\n                  const p = new b.SendTxHelper({\n                      web3Context: e,\n                      promiEvent: d,\n                      options: u,\n                      returnFormat: r\n                    }),\n                    m = (0, a.format)({\n                      format: \"bytes\"\n                    }, t, i.ETH_DATA_FORMAT),\n                    v = c.TransactionFactory.fromSerializedData((0, a.bytesToUint8Array)((0, a.hexToBytes)(m))),\n                    E = Object.assign(Object.assign({}, v.toJSON()), {\n                      from: v.getSenderAddress().toString()\n                    });\n                  try {\n                    const {\n                        v: t,\n                        r: i,\n                        s: c\n                      } = E,\n                      u = o(E, [\"v\", \"r\", \"s\"]);\n                    yield p.checkRevertBeforeSending(u), p.emitSending(m);\n                    const d = yield (0, g.trySendTransaction)(e, () => n(this, void 0, void 0, function* () {\n                      return l.ethRpcMethods.sendRawTransaction(e.requestManager, m);\n                    }));\n                    p.emitSent(m);\n                    const h = (0, a.format)({\n                      format: \"bytes32\"\n                    }, d, null != r ? r : e.defaultReturnFormat);\n                    p.emitTransactionHash(h);\n                    const v = yield (0, y.waitForTransactionReceipt)(e, d, null != r ? r : e.defaultReturnFormat),\n                      b = p.getReceiptWithEvents((0, a.format)(f.transactionReceiptSchema, v, null != r ? r : e.defaultReturnFormat));\n                    p.emitReceipt(b), s(yield p.handleResolve({\n                      receipt: b,\n                      tx: E\n                    })), p.emitConfirmation({\n                      receipt: b,\n                      transactionHash: d\n                    });\n                  } catch (e) {\n                    h(yield p.handleError({\n                      error: e,\n                      tx: E\n                    }));\n                  }\n                });\n              })();\n            });\n          });\n          return d;\n        }, t.sign = function (e, t, r, o = e.defaultReturnFormat) {\n          var s;\n          return n(this, void 0, void 0, function* () {\n            const n = (0, a.format)({\n              format: \"bytes\"\n            }, t, i.DEFAULT_RETURN_FORMAT);\n            if (null === (s = e.wallet) || void 0 === s ? void 0 : s.get(r)) {\n              const t = e.wallet.get(r).sign(n);\n              return (0, a.format)(f.SignatureObjectSchema, t, o);\n            }\n            if (\"number\" == typeof r) throw new d.SignatureError(t, 'RPC method \"eth_sign\" does not support index signatures');\n            const c = yield l.ethRpcMethods.sign(e.requestManager, r, n);\n            return (0, a.format)({\n              format: \"bytes\"\n            }, c, o);\n          });\n        }, t.signTransaction = function (e, t, r = e.defaultReturnFormat) {\n          return n(this, void 0, void 0, function* () {\n            const n = yield l.ethRpcMethods.signTransaction(e.requestManager, (0, m.formatTransaction)(t, i.ETH_DATA_FORMAT));\n            return (0, u.isString)(n) ? (0, h.decodeSignedTransaction)(n, r, {\n              fillInputAndData: !0\n            }) : {\n              raw: (0, a.format)({\n                format: \"bytes\"\n              }, n.raw, r),\n              tx: (0, m.formatTransaction)(n.tx, r, {\n                fillInputAndData: !0\n              })\n            };\n          });\n        }, t.call = function (e, t, r = e.defaultBlock, o = e.defaultReturnFormat) {\n          return n(this, void 0, void 0, function* () {\n            const n = (0, u.isBlockTag)(r) ? r : (0, a.format)({\n                format: \"uint\"\n              }, r, i.ETH_DATA_FORMAT),\n              s = yield l.ethRpcMethods.call(e.requestManager, (0, m.formatTransaction)(t, i.ETH_DATA_FORMAT), n);\n            return (0, a.format)({\n              format: \"bytes\"\n            }, s, o);\n          });\n        }, t.estimateGas = function (e, t, r = e.defaultBlock, o) {\n          return n(this, void 0, void 0, function* () {\n            const n = (0, m.formatTransaction)(t, i.ETH_DATA_FORMAT),\n              s = (0, u.isBlockTag)(r) ? r : (0, a.format)({\n                format: \"uint\"\n              }, r, i.ETH_DATA_FORMAT),\n              c = yield l.ethRpcMethods.estimateGas(e.requestManager, n, s);\n            return (0, a.format)({\n              format: \"uint\"\n            }, c, null != o ? o : e.defaultReturnFormat);\n          });\n        }, t.getLogs = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            let {\n              toBlock: n,\n              fromBlock: o\n            } = t;\n            (0, u.isNullish)(n) || \"number\" != typeof n && \"bigint\" != typeof n || (n = (0, a.numberToHex)(n)), (0, u.isNullish)(o) || \"number\" != typeof o && \"bigint\" != typeof o || (o = (0, a.numberToHex)(o));\n            const i = Object.assign(Object.assign({}, t), {\n              fromBlock: o,\n              toBlock: n\n            });\n            return (yield l.ethRpcMethods.getLogs(e.requestManager, i)).map(t => \"string\" == typeof t ? t : (0, a.format)(f.logSchema, t, null != r ? r : e.defaultReturnFormat));\n          });\n        }, t.getChainId = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            const r = yield l.ethRpcMethods.getChainId(e.requestManager);\n            return (0, a.format)({\n              format: \"uint\"\n            }, r, null != t ? t : e.defaultReturnFormat);\n          });\n        }, t.getProof = function (e, t, r, o = e.defaultBlock, s) {\n          return n(this, void 0, void 0, function* () {\n            const n = r.map(e => (0, a.format)({\n                format: \"bytes\"\n              }, e, i.ETH_DATA_FORMAT)),\n              c = (0, u.isBlockTag)(o) ? o : (0, a.format)({\n                format: \"uint\"\n              }, o, i.ETH_DATA_FORMAT),\n              d = yield l.ethRpcMethods.getProof(e.requestManager, t, n, c);\n            return (0, a.format)(f.accountSchema, d, null != s ? s : e.defaultReturnFormat);\n          });\n        }, t.getFeeHistory = function (e, t, r = e.defaultBlock, o, s) {\n          return n(this, void 0, void 0, function* () {\n            const n = (0, a.format)({\n                format: \"uint\"\n              }, t, i.ETH_DATA_FORMAT),\n              c = (0, u.isBlockTag)(r) ? r : (0, a.format)({\n                format: \"uint\"\n              }, r, i.ETH_DATA_FORMAT),\n              d = (0, a.format)({\n                type: \"array\",\n                items: {\n                  format: \"uint\"\n                }\n              }, o, v.NUMBER_DATA_FORMAT),\n              h = yield l.ethRpcMethods.getFeeHistory(e.requestManager, n, c, d);\n            return (0, a.format)(f.feeHistorySchema, h, null != s ? s : e.defaultReturnFormat);\n          });\n        }, t.createAccessList = function (e, t, r = e.defaultBlock, o) {\n          return n(this, void 0, void 0, function* () {\n            const n = (0, u.isBlockTag)(r) ? r : (0, a.format)({\n                format: \"uint\"\n              }, r, i.ETH_DATA_FORMAT),\n              s = yield l.ethRpcMethods.createAccessList(e.requestManager, (0, m.formatTransaction)(t, i.ETH_DATA_FORMAT), n);\n            return (0, a.format)(f.accessListResultSchema, s, null != o ? o : e.defaultReturnFormat);\n          });\n        }, t.signTypedData = function (e, t, r, o, i) {\n          return n(this, void 0, void 0, function* () {\n            const n = yield l.ethRpcMethods.signTypedData(e.requestManager, t, r, o);\n            return (0, a.format)({\n              format: \"bytes\"\n            }, n, null != i ? i : e.defaultReturnFormat);\n          });\n        };\n      },\n      1922: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.accountSchema = t.storageProofSchema = t.feeHistorySchema = t.SignatureObjectSchema = t.transactionReceiptSchema = t.syncSchema = t.logSchema = t.blockHeaderSchema = t.blockSchema = t.withdrawalsSchema = t.transactionInfoSchema = t.transactionSchema = t.customChainSchema = t.hardforkSchema = t.chainSchema = t.accessListResultSchema = t.accessListSchema = t.accessListItemSchema = void 0, t.accessListItemSchema = {\n          type: \"object\",\n          properties: {\n            address: {\n              format: \"address\"\n            },\n            storageKeys: {\n              type: \"array\",\n              items: {\n                format: \"bytes32\"\n              }\n            }\n          }\n        }, t.accessListSchema = {\n          type: \"array\",\n          items: Object.assign({}, t.accessListItemSchema)\n        }, t.accessListResultSchema = {\n          type: \"object\",\n          properties: {\n            accessList: Object.assign({}, t.accessListSchema),\n            gasUsed: {\n              type: \"string\"\n            }\n          }\n        }, t.chainSchema = {\n          type: \"string\",\n          enum: [\"goerli\", \"kovan\", \"mainnet\", \"rinkeby\", \"ropsten\", \"sepolia\"]\n        }, t.hardforkSchema = {\n          type: \"string\",\n          enum: [\"arrowGlacier\", \"berlin\", \"byzantium\", \"chainstart\", \"constantinople\", \"dao\", \"homestead\", \"istanbul\", \"london\", \"merge\", \"muirGlacier\", \"petersburg\", \"shanghai\", \"spuriousDragon\", \"tangerineWhistle\"]\n        }, t.customChainSchema = {\n          type: \"object\",\n          properties: {\n            name: {\n              format: \"string\"\n            },\n            networkId: {\n              format: \"uint\"\n            },\n            chainId: {\n              format: \"uint\"\n            }\n          }\n        }, t.transactionSchema = {\n          type: \"object\",\n          properties: {\n            from: {\n              format: \"address\"\n            },\n            to: {\n              oneOf: [{\n                format: \"address\"\n              }, {\n                type: \"null\"\n              }]\n            },\n            value: {\n              format: \"uint\"\n            },\n            gas: {\n              format: \"uint\"\n            },\n            gasPrice: {\n              format: \"uint\"\n            },\n            effectiveGasPrice: {\n              format: \"uint\"\n            },\n            type: {\n              format: \"uint\"\n            },\n            maxFeePerGas: {\n              format: \"uint\"\n            },\n            maxPriorityFeePerGas: {\n              format: \"uint\"\n            },\n            accessList: Object.assign({}, t.accessListSchema),\n            data: {\n              format: \"bytes\"\n            },\n            input: {\n              format: \"bytes\"\n            },\n            nonce: {\n              format: \"uint\"\n            },\n            chain: Object.assign({}, t.chainSchema),\n            hardfork: Object.assign({}, t.hardforkSchema),\n            chainId: {\n              format: \"uint\"\n            },\n            networkId: {\n              format: \"uint\"\n            },\n            common: {\n              type: \"object\",\n              properties: {\n                customChain: Object.assign({}, t.customChainSchema),\n                baseChain: Object.assign({}, t.chainSchema),\n                hardfork: Object.assign({}, t.hardforkSchema)\n              }\n            },\n            gasLimit: {\n              format: \"uint\"\n            },\n            v: {\n              format: \"uint\"\n            },\n            r: {\n              format: \"bytes32\"\n            },\n            s: {\n              format: \"bytes32\"\n            }\n          }\n        }, t.transactionInfoSchema = {\n          type: \"object\",\n          properties: Object.assign(Object.assign({}, t.transactionSchema.properties), {\n            blockHash: {\n              format: \"bytes32\"\n            },\n            blockNumber: {\n              format: \"uint\"\n            },\n            hash: {\n              format: \"bytes32\"\n            },\n            transactionIndex: {\n              format: \"uint\"\n            },\n            from: {\n              format: \"address\"\n            },\n            to: {\n              oneOf: [{\n                format: \"address\"\n              }, {\n                type: \"null\"\n              }]\n            },\n            value: {\n              format: \"uint\"\n            },\n            gas: {\n              format: \"uint\"\n            },\n            gasPrice: {\n              format: \"uint\"\n            },\n            effectiveGasPrice: {\n              format: \"uint\"\n            },\n            type: {\n              format: \"uint\"\n            },\n            maxFeePerGas: {\n              format: \"uint\"\n            },\n            maxPriorityFeePerGas: {\n              format: \"uint\"\n            },\n            accessList: Object.assign({}, t.accessListSchema),\n            data: {\n              format: \"bytes\"\n            },\n            input: {\n              format: \"bytes\"\n            },\n            nonce: {\n              format: \"uint\"\n            },\n            gasLimit: {\n              format: \"uint\"\n            },\n            v: {\n              format: \"uint\"\n            },\n            r: {\n              format: \"bytes32\"\n            },\n            s: {\n              format: \"bytes32\"\n            }\n          })\n        }, t.withdrawalsSchema = {\n          type: \"object\",\n          properties: {\n            index: {\n              format: \"uint\"\n            },\n            validatorIndex: {\n              format: \"uint\"\n            },\n            address: {\n              format: \"address\"\n            },\n            amount: {\n              format: \"uint\"\n            }\n          }\n        }, t.blockSchema = {\n          type: \"object\",\n          properties: {\n            baseFeePerGas: {\n              format: \"uint\"\n            },\n            blobGasUsed: {\n              format: \"uint\"\n            },\n            difficulty: {\n              format: \"uint\"\n            },\n            excessBlobGas: {\n              format: \"uint\"\n            },\n            extraData: {\n              format: \"bytes\"\n            },\n            gasLimit: {\n              format: \"uint\"\n            },\n            gasUsed: {\n              format: \"uint\"\n            },\n            hash: {\n              format: \"bytes32\"\n            },\n            logsBloom: {\n              format: \"bytes256\"\n            },\n            miner: {\n              format: \"bytes\"\n            },\n            mixHash: {\n              format: \"bytes32\"\n            },\n            nonce: {\n              format: \"uint\"\n            },\n            number: {\n              format: \"uint\"\n            },\n            parentBeaconBlockRoot: {\n              format: \"bytes32\"\n            },\n            parentHash: {\n              format: \"bytes32\"\n            },\n            receiptsRoot: {\n              format: \"bytes32\"\n            },\n            sha3Uncles: {\n              format: \"bytes32\"\n            },\n            size: {\n              format: \"uint\"\n            },\n            stateRoot: {\n              format: \"bytes32\"\n            },\n            timestamp: {\n              format: \"uint\"\n            },\n            totalDifficulty: {\n              format: \"uint\"\n            },\n            transactions: {\n              oneOf: [{\n                type: \"array\",\n                items: Object.assign({}, t.transactionInfoSchema)\n              }, {\n                type: \"array\",\n                items: {\n                  format: \"bytes32\"\n                }\n              }]\n            },\n            transactionsRoot: {\n              format: \"bytes32\"\n            },\n            uncles: {\n              type: \"array\",\n              items: {\n                format: \"bytes32\"\n              }\n            },\n            withdrawals: {\n              type: \"array\",\n              items: Object.assign({}, t.withdrawalsSchema)\n            },\n            withdrawalsRoot: {\n              format: \"bytes32\"\n            }\n          }\n        }, t.blockHeaderSchema = {\n          type: \"object\",\n          properties: {\n            author: {\n              format: \"bytes32\"\n            },\n            excessDataGas: {\n              format: \"uint\"\n            },\n            baseFeePerGas: {\n              format: \"uint\"\n            },\n            blobGasUsed: {\n              format: \"uint\"\n            },\n            difficulty: {\n              format: \"uint\"\n            },\n            excessBlobGas: {\n              format: \"uint\"\n            },\n            extraData: {\n              format: \"bytes\"\n            },\n            gasLimit: {\n              format: \"uint\"\n            },\n            gasUsed: {\n              format: \"uint\"\n            },\n            hash: {\n              format: \"bytes32\"\n            },\n            logsBloom: {\n              format: \"bytes256\"\n            },\n            miner: {\n              format: \"bytes\"\n            },\n            mixHash: {\n              format: \"bytes32\"\n            },\n            nonce: {\n              format: \"uint\"\n            },\n            number: {\n              format: \"uint\"\n            },\n            parentBeaconBlockRoot: {\n              format: \"bytes32\"\n            },\n            parentHash: {\n              format: \"bytes32\"\n            },\n            receiptsRoot: {\n              format: \"bytes32\"\n            },\n            sha3Uncles: {\n              format: \"bytes32\"\n            },\n            size: {\n              format: \"uint\"\n            },\n            stateRoot: {\n              format: \"bytes32\"\n            },\n            timestamp: {\n              format: \"uint\"\n            },\n            totalDifficulty: {\n              format: \"uint\"\n            },\n            transactions: {\n              type: \"array\",\n              items: {\n                format: \"bytes32\"\n              }\n            },\n            transactionsRoot: {\n              format: \"bytes32\"\n            },\n            uncles: {\n              type: \"array\",\n              items: {\n                format: \"bytes32\"\n              }\n            },\n            withdrawals: {\n              type: \"array\",\n              items: Object.assign({}, t.withdrawalsSchema)\n            },\n            withdrawalsRoot: {\n              format: \"bytes32\"\n            }\n          }\n        }, t.logSchema = {\n          type: \"object\",\n          properties: {\n            removed: {\n              format: \"bool\"\n            },\n            logIndex: {\n              format: \"uint\"\n            },\n            transactionIndex: {\n              format: \"uint\"\n            },\n            transactionHash: {\n              format: \"bytes32\"\n            },\n            blockHash: {\n              format: \"bytes32\"\n            },\n            blockNumber: {\n              format: \"uint\"\n            },\n            address: {\n              format: \"address\"\n            },\n            data: {\n              format: \"bytes\"\n            },\n            topics: {\n              type: \"array\",\n              items: {\n                format: \"bytes32\"\n              }\n            }\n          }\n        }, t.syncSchema = {\n          type: \"object\",\n          properties: {\n            startingBlock: {\n              format: \"string\"\n            },\n            currentBlock: {\n              format: \"string\"\n            },\n            highestBlock: {\n              format: \"string\"\n            },\n            knownStates: {\n              format: \"string\"\n            },\n            pulledStates: {\n              format: \"string\"\n            }\n          }\n        }, t.transactionReceiptSchema = {\n          type: \"object\",\n          properties: {\n            transactionHash: {\n              format: \"bytes32\"\n            },\n            transactionIndex: {\n              format: \"uint\"\n            },\n            blockHash: {\n              format: \"bytes32\"\n            },\n            blockNumber: {\n              format: \"uint\"\n            },\n            from: {\n              format: \"address\"\n            },\n            to: {\n              format: \"address\"\n            },\n            cumulativeGasUsed: {\n              format: \"uint\"\n            },\n            gasUsed: {\n              format: \"uint\"\n            },\n            effectiveGasPrice: {\n              format: \"uint\"\n            },\n            contractAddress: {\n              format: \"address\"\n            },\n            logs: {\n              type: \"array\",\n              items: Object.assign({}, t.logSchema)\n            },\n            logsBloom: {\n              format: \"bytes\"\n            },\n            root: {\n              format: \"bytes\"\n            },\n            status: {\n              format: \"uint\"\n            },\n            type: {\n              format: \"uint\"\n            }\n          }\n        }, t.SignatureObjectSchema = {\n          type: \"object\",\n          properties: {\n            messageHash: {\n              format: \"bytes\"\n            },\n            r: {\n              format: \"bytes32\"\n            },\n            s: {\n              format: \"bytes32\"\n            },\n            v: {\n              format: \"bytes\"\n            },\n            message: {\n              format: \"bytes\"\n            },\n            signature: {\n              format: \"bytes\"\n            }\n          }\n        }, t.feeHistorySchema = {\n          type: \"object\",\n          properties: {\n            oldestBlock: {\n              format: \"uint\"\n            },\n            baseFeePerGas: {\n              type: \"array\",\n              items: {\n                format: \"uint\"\n              }\n            },\n            reward: {\n              type: \"array\",\n              items: {\n                type: \"array\",\n                items: {\n                  format: \"uint\"\n                }\n              }\n            },\n            gasUsedRatio: {\n              type: \"array\",\n              items: {\n                type: \"number\"\n              }\n            }\n          }\n        }, t.storageProofSchema = {\n          type: \"object\",\n          properties: {\n            key: {\n              format: \"bytes32\"\n            },\n            value: {\n              format: \"uint\"\n            },\n            proof: {\n              type: \"array\",\n              items: {\n                format: \"bytes32\"\n              }\n            }\n          }\n        }, t.accountSchema = {\n          type: \"object\",\n          properties: {\n            balance: {\n              format: \"uint\"\n            },\n            codeHash: {\n              format: \"bytes32\"\n            },\n            nonce: {\n              format: \"uint\"\n            },\n            storageHash: {\n              format: \"bytes32\"\n            },\n            accountProof: {\n              type: \"array\",\n              items: {\n                format: \"bytes32\"\n              }\n            },\n            storageProof: {\n              type: \"array\",\n              items: Object.assign({}, t.storageProofSchema)\n            }\n          }\n        };\n      },\n      4832: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      5900: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeSignedTransaction = void 0;\n        const n = r(9634),\n          o = r(9247),\n          i = r(7350),\n          s = r(5140);\n        t.decodeSignedTransaction = function (e, t, r = {\n          fillInputAndData: !1\n        }) {\n          return {\n            raw: (0, n.format)({\n              format: \"bytes\"\n            }, e, t),\n            tx: (0, s.formatTransaction)(Object.assign(Object.assign({}, o.TransactionFactory.fromSerializedData((0, n.hexToBytes)(e)).toJSON()), {\n              hash: (0, n.bytesToHex)((0, n.keccak256)((0, n.hexToBytes)(e))),\n              type: (0, i.detectRawTransactionType)((0, n.hexToBytes)(e))\n            }), t, {\n              fillInputAndData: r.fillInputAndData\n            })\n          };\n        };\n      },\n      7543: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeEventABI = void 0;\n        const n = r(9634),\n          o = r(9970),\n          i = r(8381),\n          s = r(1922),\n          a = r(9326);\n        t.decodeEventABI = (e, t, r, c = o.DEFAULT_RETURN_FORMAT) => {\n          var u, d, l, h, f;\n          let p = Object.assign({}, e);\n          const m = (0, n.format)(s.logSchema, t, c);\n          if ([a.ALL_EVENTS, \"allEvents\"].includes(p.name)) {\n            p = r.find(e => e.signature === t.topics[0]) || {\n              anonymous: !0\n            };\n          }\n          if (p.inputs = null !== (d = null !== (u = p.inputs) && void 0 !== u ? u : e.inputs) && void 0 !== d ? d : [], !p.anonymous) {\n            let e = 0;\n            (null !== (l = p.inputs) && void 0 !== l ? l : []).forEach(t => {\n              t.indexed && (e += 1);\n            }), e > 0 && (null == t ? void 0 : t.topics) && (null == t ? void 0 : t.topics.length) !== e + 1 && (p = Object.assign(Object.assign({}, p), {\n              anonymous: !0,\n              inputs: []\n            }));\n          }\n          const g = p.anonymous ? t.topics : (null !== (h = t.topics) && void 0 !== h ? h : []).slice(1);\n          return Object.assign(Object.assign({}, m), {\n            returnValues: (0, i.decodeLog)([...(null !== (f = p.inputs) && void 0 !== f ? f : [])], t.data, g),\n            event: p.name,\n            signature: !p.anonymous && t.topics && 0 !== t.topics.length && t.topics[0] ? t.topics[0] : void 0,\n            raw: {\n              data: t.data,\n              topics: t.topics\n            }\n          });\n        };\n      },\n      7350: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.detectRawTransactionType = t.detectTransactionType = t.defaultTransactionTypeParser = void 0;\n        const n = r(9634),\n          o = r(9970),\n          i = r(7345),\n          s = r(5071),\n          a = {\n            type: \"object\",\n            properties: {\n              accessList: {\n                type: \"null\"\n              },\n              maxFeePerGas: {\n                type: \"null\"\n              },\n              maxPriorityFeePerGas: {\n                type: \"null\"\n              }\n            }\n          },\n          c = {\n            type: \"object\",\n            properties: {\n              maxFeePerGas: {\n                type: \"null\"\n              },\n              maxPriorityFeePerGas: {\n                type: \"null\"\n              }\n            }\n          },\n          u = {\n            type: \"object\",\n            properties: {\n              gasPrice: {\n                type: \"null\"\n              }\n            }\n          },\n          d = (e, t, r) => {\n            try {\n              i.validator.validateJSONSchema(e, t);\n            } catch (e) {\n              if (e instanceof i.Web3ValidatorError) throw new s.InvalidPropertiesForTransactionTypeError(e.errors, r);\n              throw e;\n            }\n          };\n        t.defaultTransactionTypeParser = e => {\n          var t, r;\n          const s = e;\n          if (!(0, i.isNullish)(s.type)) {\n            let e;\n            switch (s.type) {\n              case \"0x0\":\n                e = a;\n                break;\n              case \"0x1\":\n                e = c;\n                break;\n              case \"0x2\":\n                e = u;\n                break;\n              default:\n                return (0, n.format)({\n                  format: \"uint\"\n                }, s.type, o.ETH_DATA_FORMAT);\n            }\n            return d(e, s, s.type), (0, n.format)({\n              format: \"uint\"\n            }, s.type, o.ETH_DATA_FORMAT);\n          }\n          if (!(0, i.isNullish)(s.maxFeePerGas) || !(0, i.isNullish)(s.maxPriorityFeePerGas)) return d(u, s, \"0x2\"), \"0x2\";\n          if (!(0, i.isNullish)(s.accessList)) return d(c, s, \"0x1\"), \"0x1\";\n          const l = null !== (t = s.hardfork) && void 0 !== t ? t : null === (r = s.common) || void 0 === r ? void 0 : r.hardfork;\n          if (!(0, i.isNullish)(l)) {\n            const e = Object.keys(o.HardforksOrdered).indexOf(l);\n            if (e >= Object.keys(o.HardforksOrdered).indexOf(\"london\")) return (0, i.isNullish)(s.gasPrice) ? \"0x2\" : \"0x0\";\n            if (e === Object.keys(o.HardforksOrdered).indexOf(\"berlin\")) return \"0x0\";\n          }\n          return (0, i.isNullish)(s.gasPrice) ? void 0 : (d(a, s, \"0x0\"), \"0x0\");\n        }, t.detectTransactionType = (e, r) => {\n          var n;\n          return (null !== (n = null == r ? void 0 : r.transactionTypeParser) && void 0 !== n ? n : t.defaultTransactionTypeParser)(e);\n        }, t.detectRawTransactionType = e => e[0] > 127 ? \"0x0\" : (0, n.toHex)(e[0]);\n      },\n      5140: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.formatTransaction = void 0;\n        const n = r(9970),\n          o = r(7345),\n          i = r(9634),\n          s = r(5071),\n          a = r(1922);\n        t.formatTransaction = function (e, t = n.DEFAULT_RETURN_FORMAT, r = {\n          transactionSchema: a.transactionInfoSchema,\n          fillInputAndData: !1\n        }) {\n          var c, u;\n          let d = (0, i.mergeDeep)({}, e);\n          if ((0, o.isNullish)(null == e ? void 0 : e.common) || (d.common = Object.assign({}, e.common), (0, o.isNullish)(null === (c = e.common) || void 0 === c ? void 0 : c.customChain) || (d.common.customChain = Object.assign({}, e.common.customChain))), d = (0, i.format)(null !== (u = r.transactionSchema) && void 0 !== u ? u : a.transactionInfoSchema, d, t), !(0, o.isNullish)(d.data) && !(0, o.isNullish)(d.input) && (0, i.toHex)(d.data) !== (0, i.toHex)(d.input)) throw new s.TransactionDataAndInputError({\n            data: (0, i.bytesToHex)(d.data),\n            input: (0, i.bytesToHex)(d.input)\n          });\n          return r.fillInputAndData && ((0, o.isNullish)(d.data) ? (0, o.isNullish)(d.input) || (d.data = d.input) : d.input = d.data), (0, o.isNullish)(d.gasLimit) || (d.gas = d.gasLimit, delete d.gasLimit), d;\n        };\n      },\n      4429: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getRevertReason = t.parseTransactionError = void 0;\n        const o = r(5071),\n          i = r(8381),\n          s = r(3222);\n        t.parseTransactionError = (e, t) => {\n          var r, n, s, a, c;\n          if (e instanceof o.ContractExecutionError && e.cause instanceof o.Eip838ExecutionError) {\n            if (void 0 !== t) {\n              const o = t.filter(e => (0, i.isAbiErrorFragment)(e));\n              return (0, i.decodeContractErrorData)(o, e.cause), {\n                reason: e.cause.message,\n                signature: null === (r = e.cause.data) || void 0 === r ? void 0 : r.slice(0, 10),\n                data: null === (n = e.cause.data) || void 0 === n ? void 0 : n.substring(10),\n                customErrorName: e.cause.errorName,\n                customErrorDecodedSignature: e.cause.errorSignature,\n                customErrorArguments: e.cause.errorArgs\n              };\n            }\n            return {\n              reason: e.cause.message,\n              signature: null === (s = e.cause.data) || void 0 === s ? void 0 : s.slice(0, 10),\n              data: null === (a = e.cause.data) || void 0 === a ? void 0 : a.substring(10)\n            };\n          }\n          if (e instanceof o.InvalidResponseError && !Array.isArray(null === (c = e.cause) || void 0 === c ? void 0 : c.errors) && void 0 !== e.cause) return e.cause.message;\n          throw e;\n        }, t.getRevertReason = function (e, r, o, i = e.defaultReturnFormat) {\n          return n(this, void 0, void 0, function* () {\n            try {\n              return void (yield (0, s.call)(e, r, e.defaultBlock, i));\n            } catch (e) {\n              return (0, t.parseTransactionError)(e, o);\n            }\n          });\n        };\n      },\n      1882: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getTransactionError = void 0;\n        const o = r(5071),\n          i = r(4429);\n        t.getTransactionError = function (e, t, r, s, a, c) {\n          return n(this, void 0, void 0, function* () {\n            let n,\n              u = c;\n            if (void 0 === u && (void 0 !== s ? u = (0, i.parseTransactionError)(s) : e.handleRevert && void 0 !== t && (u = yield (0, i.getRevertReason)(e, t, a))), void 0 === u) n = new o.TransactionRevertedWithoutReasonError(r);else if (\"string\" == typeof u) n = new o.TransactionRevertInstructionError(u, void 0, r);else if (void 0 !== u.customErrorName && void 0 !== u.customErrorDecodedSignature && void 0 !== u.customErrorArguments) {\n              const e = u;\n              n = new o.TransactionRevertWithCustomError(e.reason, e.customErrorName, e.customErrorDecodedSignature, e.customErrorArguments, e.signature, r, e.data);\n            } else n = new o.TransactionRevertInstructionError(u.reason, u.signature, r, u.data);\n            return n;\n          });\n        };\n      },\n      8736: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getTransactionGasPricing = void 0;\n        const o = r(9970),\n          i = r(7345),\n          s = r(5071),\n          a = r(9634),\n          c = r(3222),\n          u = r(223);\n        t.getTransactionGasPricing = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            const d = (0, u.getTransactionType)(e, t);\n            if (!(0, i.isNullish)(d)) {\n              if (d.startsWith(\"-\")) throw new s.UnsupportedTransactionTypeError(d);\n              if (Number(d) < 0 || Number(d) > 127) throw new s.UnsupportedTransactionTypeError(d);\n              if ((0, i.isNullish)(e.gasPrice) && (\"0x0\" === d || \"0x1\" === d)) return {\n                gasPrice: yield (0, c.getGasPrice)(t, r),\n                maxPriorityFeePerGas: void 0,\n                maxFeePerGas: void 0\n              };\n              if (\"0x2\" === d) return Object.assign({\n                gasPrice: void 0\n              }, yield function (e, t, r) {\n                var u, d, l, h;\n                return n(this, void 0, void 0, function* () {\n                  const n = yield (0, c.getBlock)(t, t.defaultBlock, !1, o.ETH_DATA_FORMAT);\n                  if ((0, i.isNullish)(n.baseFeePerGas)) throw new s.Eip1559NotSupportedError();\n                  let f;\n                  if ((0, i.isNullish)(e.gasPrice) && BigInt(n.baseFeePerGas) === BigInt(0) && (f = yield (0, c.getGasPrice)(t, r)), !(0, i.isNullish)(e.gasPrice) || !(0, i.isNullish)(f)) {\n                    const t = (0, a.format)({\n                      format: \"uint\"\n                    }, null !== (u = e.gasPrice) && void 0 !== u ? u : f, r);\n                    return {\n                      maxPriorityFeePerGas: t,\n                      maxFeePerGas: t\n                    };\n                  }\n                  return {\n                    maxPriorityFeePerGas: (0, a.format)({\n                      format: \"uint\"\n                    }, null !== (d = e.maxPriorityFeePerGas) && void 0 !== d ? d : t.defaultMaxPriorityFeePerGas, r),\n                    maxFeePerGas: (0, a.format)({\n                      format: \"uint\"\n                    }, null !== (l = e.maxFeePerGas) && void 0 !== l ? l : BigInt(n.baseFeePerGas) * BigInt(2) + BigInt(null !== (h = e.maxPriorityFeePerGas) && void 0 !== h ? h : t.defaultMaxPriorityFeePerGas), r)\n                  };\n                });\n              }(e, t, r));\n            }\n          });\n        };\n      },\n      1258: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.prepareTransactionForSigning = void 0;\n        const o = r(9970),\n          i = r(9634),\n          s = r(9247),\n          a = r(7345),\n          c = r(8650),\n          u = r(5140),\n          d = r(223);\n        t.prepareTransactionForSigning = (e, t, r, l = !1, h = !0) => n(void 0, void 0, void 0, function* () {\n          const n = yield (0, d.transactionBuilder)({\n              transaction: e,\n              web3Context: t,\n              privateKey: r,\n              fillGasPrice: l,\n              fillGasLimit: h\n            }),\n            f = (0, u.formatTransaction)(n, o.ETH_DATA_FORMAT);\n          return (0, c.validateTransactionForSigning)(f), s.TransactionFactory.fromTxData((e => {\n            var t, r;\n            return {\n              nonce: e.nonce,\n              gasPrice: e.gasPrice,\n              gasLimit: null !== (t = e.gasLimit) && void 0 !== t ? t : e.gas,\n              to: e.to,\n              value: e.value,\n              data: null !== (r = e.data) && void 0 !== r ? r : e.input,\n              type: e.type,\n              chainId: e.chainId,\n              accessList: e.accessList,\n              maxPriorityFeePerGas: e.maxPriorityFeePerGas,\n              maxFeePerGas: e.maxFeePerGas\n            };\n          })(f), ((e, t) => {\n            var r, n, o, c, u, d, l, h, f, p, m, g, y, v, b, E, _, A;\n            let T;\n            if (((0, a.isNullish)(e.chain) || (0, a.isNullish)(e.hardfork)) && (0, a.isNullish)(e.common)) t.defaultCommon ? (T = Object.assign({}, t.defaultCommon), (0, a.isNullish)(T.hardfork) && (T.hardfork = null !== (r = e.hardfork) && void 0 !== r ? r : t.defaultHardfork), (0, a.isNullish)(T.baseChain) && (T.baseChain = t.defaultChain)) : T = s.Common.custom({\n              name: \"custom-network\",\n              chainId: (0, i.toNumber)(e.chainId),\n              networkId: (0, a.isNullish)(e.networkId) ? void 0 : (0, i.toNumber)(e.networkId),\n              defaultHardfork: null !== (n = e.hardfork) && void 0 !== n ? n : t.defaultHardfork\n            }, {\n              baseChain: t.defaultChain\n            });else {\n              const r = null !== (d = null !== (u = null === (c = null === (o = null == e ? void 0 : e.common) || void 0 === o ? void 0 : o.customChain) || void 0 === c ? void 0 : c.name) && void 0 !== u ? u : e.chain) && void 0 !== d ? d : \"custom-network\",\n                n = (0, i.toNumber)(null !== (f = null === (h = null === (l = null == e ? void 0 : e.common) || void 0 === l ? void 0 : l.customChain) || void 0 === h ? void 0 : h.chainId) && void 0 !== f ? f : null == e ? void 0 : e.chainId),\n                a = (0, i.toNumber)(null !== (g = null === (m = null === (p = null == e ? void 0 : e.common) || void 0 === p ? void 0 : p.customChain) || void 0 === m ? void 0 : m.networkId) && void 0 !== g ? g : null == e ? void 0 : e.networkId),\n                w = null !== (b = null !== (v = null === (y = null == e ? void 0 : e.common) || void 0 === y ? void 0 : y.hardfork) && void 0 !== v ? v : null == e ? void 0 : e.hardfork) && void 0 !== b ? b : t.defaultHardfork,\n                I = null !== (A = null !== (_ = null === (E = e.common) || void 0 === E ? void 0 : E.baseChain) && void 0 !== _ ? _ : e.chain) && void 0 !== A ? A : t.defaultChain;\n              n && a && r && (T = s.Common.custom({\n                name: r,\n                chainId: n,\n                networkId: a,\n                defaultHardfork: w\n              }, {\n                baseChain: I\n              }));\n            }\n            return {\n              common: T\n            };\n          })(f, t));\n        });\n      },\n      4659: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.rejectIfBlockTimeout = void 0;\n        const o = r(9634),\n          i = r(5071),\n          s = r(9326),\n          a = r(3222);\n        function c(e, t, r) {\n          const c = e.transactionPollingInterval,\n            [u, d] = (0, o.rejectIfConditionAtInterval)(() => n(this, void 0, void 0, function* () {\n              let n;\n              try {\n                n = yield (0, a.getBlockNumber)(e, s.NUMBER_DATA_FORMAT);\n              } catch (e) {\n                return void console.warn(\"An error happen while trying to get the block number\", e);\n              }\n              const o = n - t;\n              if (o >= e.transactionBlockTimeout) return new i.TransactionBlockTimeoutError({\n                starterBlockNumber: t,\n                numberOfBlocks: o,\n                transactionHash: r\n              });\n            }), c);\n          return [d, {\n            clean: () => {\n              clearInterval(u);\n            }\n          }];\n        }\n        t.rejectIfBlockTimeout = function (e, t) {\n          var r, o;\n          return n(this, void 0, void 0, function* () {\n            const {\n              provider: u\n            } = e.requestManager;\n            let d;\n            const l = yield (0, a.getBlockNumber)(e, s.NUMBER_DATA_FORMAT);\n            return d = (null === (o = (r = u).supportsSubscriptions) || void 0 === o ? void 0 : o.call(r)) && e.enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout ? yield function (e, t, r) {\n              var o;\n              return n(this, void 0, void 0, function* () {\n                let n,\n                  s,\n                  a = !0;\n                function u(n, o) {\n                  o && console.warn(\"error happened at subscription. So revert to polling...\", o), s.clean(), a = !1;\n                  const [i, u] = c(e, t, r);\n                  s.clean = u.clean, i.catch(e => n(e));\n                }\n                try {\n                  n = yield null === (o = e.subscriptionManager) || void 0 === o ? void 0 : o.subscribe(\"newHeads\"), s = {\n                    clean: () => {\n                      var t;\n                      n.id && (null === (t = e.subscriptionManager) || void 0 === t || t.removeSubscription(n).then(() => {}).catch(() => {}));\n                    }\n                  };\n                } catch (n) {\n                  return c(e, t, r);\n                }\n                return [new Promise((o, s) => {\n                  try {\n                    n.on(\"data\", n => {\n                      if (a = !1, !(null == n ? void 0 : n.number)) return;\n                      const o = Number(BigInt(n.number) - BigInt(t));\n                      o >= e.transactionBlockTimeout && s(new i.TransactionBlockTimeoutError({\n                        starterBlockNumber: t,\n                        numberOfBlocks: o,\n                        transactionHash: r\n                      }));\n                    }), n.on(\"error\", e => {\n                      u(s, e);\n                    });\n                  } catch (e) {\n                    u(s, e);\n                  }\n                  setTimeout(() => {\n                    a && u(s);\n                  }, 1e3 * e.blockHeaderTimeout);\n                }), s];\n              });\n            }(e, l, t) : c(e, l, t), d;\n          });\n        };\n      },\n      7322: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SendTxHelper = void 0;\n        const o = r(9970),\n          i = r(7345),\n          s = r(5071),\n          a = r(1181),\n          c = r(8736),\n          u = r(8425),\n          d = r(2117),\n          l = r(9326),\n          h = r(1882),\n          f = r(4429),\n          p = r(7543);\n        t.SendTxHelper = class {\n          constructor({\n            options: e,\n            web3Context: t,\n            promiEvent: r,\n            returnFormat: n\n          }) {\n            this.options = {\n              checkRevertBeforeSending: !0\n            }, this.options = e, this.web3Context = t, this.promiEvent = r, this.returnFormat = n;\n          }\n          getReceiptWithEvents(e) {\n            var t, r;\n            const n = Object.assign({}, null != e ? e : {});\n            if ((null === (t = this.options) || void 0 === t ? void 0 : t.contractAbi) && n.logs && n.logs.length > 0) {\n              n.events = {};\n              for (const e of n.logs) {\n                const t = (0, p.decodeEventABI)(l.ALL_EVENTS_ABI, e, null === (r = this.options) || void 0 === r ? void 0 : r.contractAbi, this.returnFormat);\n                t.event && (n.events[t.event] = t);\n              }\n            }\n            return n;\n          }\n          checkRevertBeforeSending(e) {\n            return n(this, void 0, void 0, function* () {\n              if (!1 !== this.options.checkRevertBeforeSending) {\n                let t = e;\n                (0, i.isNullish)(e.data) && (0, i.isNullish)(e.input) && (0, i.isNullish)(e.gas) && (t = Object.assign(Object.assign({}, e), {\n                  gas: 21e3\n                }));\n                const r = yield (0, f.getRevertReason)(this.web3Context, t, this.options.contractAbi);\n                if (void 0 !== r) throw yield (0, h.getTransactionError)(this.web3Context, e, void 0, void 0, this.options.contractAbi, r);\n              }\n            });\n          }\n          emitSending(e) {\n            this.promiEvent.listenerCount(\"sending\") > 0 && this.promiEvent.emit(\"sending\", e);\n          }\n          populateGasPrice({\n            transactionFormatted: e,\n            transaction: t\n          }) {\n            var r;\n            return n(this, void 0, void 0, function* () {\n              let n = e;\n              return !(null === (r = this.options) || void 0 === r ? void 0 : r.ignoreGasPricing) && (0, i.isNullish)(e.gasPrice) && ((0, i.isNullish)(t.maxPriorityFeePerGas) || (0, i.isNullish)(t.maxFeePerGas)) && (n = Object.assign(Object.assign({}, e), yield (0, c.getTransactionGasPricing)(e, this.web3Context, o.ETH_DATA_FORMAT))), n;\n            });\n          }\n          signAndSend({\n            wallet: e,\n            tx: t\n          }) {\n            return n(this, void 0, void 0, function* () {\n              if (e) {\n                const r = yield e.signTransaction(t);\n                return (0, u.trySendTransaction)(this.web3Context, () => n(this, void 0, void 0, function* () {\n                  return a.ethRpcMethods.sendRawTransaction(this.web3Context.requestManager, r.rawTransaction);\n                }), r.transactionHash);\n              }\n              return (0, u.trySendTransaction)(this.web3Context, () => n(this, void 0, void 0, function* () {\n                return a.ethRpcMethods.sendTransaction(this.web3Context.requestManager, t);\n              }));\n            });\n          }\n          emitSent(e) {\n            this.promiEvent.listenerCount(\"sent\") > 0 && this.promiEvent.emit(\"sent\", e);\n          }\n          emitTransactionHash(e) {\n            this.promiEvent.listenerCount(\"transactionHash\") > 0 && this.promiEvent.emit(\"transactionHash\", e);\n          }\n          emitReceipt(e) {\n            this.promiEvent.listenerCount(\"receipt\") > 0 && this.promiEvent.emit(\"receipt\", e);\n          }\n          handleError({\n            error: e,\n            tx: t\n          }) {\n            var r;\n            return n(this, void 0, void 0, function* () {\n              let n = e;\n              return n instanceof s.ContractExecutionError && this.web3Context.handleRevert && (n = yield (0, h.getTransactionError)(this.web3Context, t, void 0, void 0, null === (r = this.options) || void 0 === r ? void 0 : r.contractAbi)), (n instanceof s.InvalidResponseError || n instanceof s.ContractExecutionError || n instanceof s.TransactionRevertWithCustomError || n instanceof s.TransactionRevertedWithoutReasonError || n instanceof s.TransactionRevertInstructionError || n instanceof s.TransactionPollingTimeoutError) && this.promiEvent.listenerCount(\"error\") > 0 && this.promiEvent.emit(\"error\", n), n;\n            });\n          }\n          emitConfirmation({\n            receipt: e,\n            transactionHash: t,\n            customTransactionReceiptSchema: r\n          }) {\n            this.promiEvent.listenerCount(\"confirmation\") > 0 && (0, d.watchTransactionForConfirmations)(this.web3Context, this.promiEvent, e, t, this.returnFormat, r);\n          }\n          handleResolve({\n            receipt: e,\n            tx: t\n          }) {\n            var r, o, i;\n            return n(this, void 0, void 0, function* () {\n              if (null === (r = this.options) || void 0 === r ? void 0 : r.transactionResolver) return null === (o = this.options) || void 0 === o ? void 0 : o.transactionResolver(e);\n              if (e.status === BigInt(0)) {\n                const r = yield (0, h.getTransactionError)(this.web3Context, t, e, void 0, null === (i = this.options) || void 0 === i ? void 0 : i.contractAbi);\n                throw this.promiEvent.listenerCount(\"error\") > 0 && this.promiEvent.emit(\"error\", r), r;\n              }\n              return e;\n            });\n          }\n        };\n      },\n      223: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.transactionBuilder = t.defaultTransactionBuilder = t.getTransactionType = t.getTransactionNonce = t.getTransactionFromOrToAttr = void 0;\n        const o = r(9970),\n          i = r(9247),\n          s = r(9820),\n          a = r(7345),\n          c = r(5071),\n          u = r(9634),\n          d = r(9326),\n          l = r(3222),\n          h = r(7350),\n          f = r(1922),\n          p = r(8736);\n        function m(e) {\n          var r, i;\n          return n(this, void 0, void 0, function* () {\n            let n = (0, u.format)(f.transactionSchema, e.transaction, e.web3Context.defaultReturnFormat);\n            if ((0, a.isNullish)(n.from) && (n.from = (0, t.getTransactionFromOrToAttr)(\"from\", e.web3Context, void 0, e.privateKey)), (0, a.isNullish)(n.nonce) && (n.nonce = yield (0, t.getTransactionNonce)(e.web3Context, n.from, o.ETH_DATA_FORMAT)), (0, a.isNullish)(n.value) && (n.value = \"0x0\"), (0, a.isNullish)(n.data)) (0, a.isNullish)(n.input) ? n.input = \"0x\" : n.input.startsWith(\"0x\") || (n.input = `0x${n.input}`);else {\n              if (!(0, a.isNullish)(n.input) && n.data !== n.input) throw new c.TransactionDataAndInputError({\n                data: (0, u.bytesToHex)(n.data),\n                input: (0, u.bytesToHex)(n.input)\n              });\n              n.data.startsWith(\"0x\") || (n.data = `0x${n.data}`);\n            }\n            if ((0, a.isNullish)(n.common)) {\n              if (e.web3Context.defaultCommon) {\n                const t = e.web3Context.defaultCommon,\n                  r = t.customChain.chainId,\n                  o = t.customChain.networkId,\n                  i = t.customChain.name;\n                n.common = Object.assign(Object.assign({}, t), {\n                  customChain: {\n                    chainId: r,\n                    networkId: o,\n                    name: i\n                  }\n                });\n              }\n              (0, a.isNullish)(n.chain) && (n.chain = e.web3Context.defaultChain), (0, a.isNullish)(n.hardfork) && (n.hardfork = e.web3Context.defaultHardfork);\n            }\n            if ((0, a.isNullish)(n.chainId) && (0, a.isNullish)(null === (r = n.common) || void 0 === r ? void 0 : r.customChain.chainId) && (n.chainId = yield (0, l.getChainId)(e.web3Context, o.ETH_DATA_FORMAT)), (0, a.isNullish)(n.networkId) && (n.networkId = null !== (i = e.web3Context.defaultNetworkId) && void 0 !== i ? i : yield (0, s.getId)(e.web3Context, o.ETH_DATA_FORMAT)), (0, a.isNullish)(n.gasLimit) && !(0, a.isNullish)(n.gas) && (n.gasLimit = n.gas), n.type = (0, t.getTransactionType)(n, e.web3Context), !(0, a.isNullish)(n.accessList) || \"0x1\" !== n.type && \"0x2\" !== n.type || (n.accessList = []), e.fillGasPrice && (n = Object.assign(Object.assign({}, n), yield (0, p.getTransactionGasPricing)(n, e.web3Context, o.ETH_DATA_FORMAT))), (0, a.isNullish)(n.gas) && (0, a.isNullish)(n.gasLimit) && e.fillGasLimit) {\n              const t = yield (0, l.estimateGas)(e.web3Context, n, \"latest\", o.ETH_DATA_FORMAT);\n              n = Object.assign(Object.assign({}, n), {\n                gas: (0, u.format)({\n                  format: \"uint\"\n                }, t, o.ETH_DATA_FORMAT)\n              });\n            }\n            return n;\n          });\n        }\n        t.getTransactionFromOrToAttr = (e, t, r, n) => {\n          if (void 0 !== r && e in r && void 0 !== r[e]) {\n            if (\"string\" == typeof r[e] && (0, a.isAddress)(r[e])) return r[e];\n            if (!(0, a.isHexStrict)(r[e]) && (0, a.isNumber)(r[e])) {\n              if (t.wallet) {\n                const n = t.wallet.get((0, u.format)({\n                  format: \"uint\"\n                }, r[e], d.NUMBER_DATA_FORMAT));\n                if (!(0, a.isNullish)(n)) return n.address;\n                throw new c.LocalWalletNotAvailableError();\n              }\n              throw new c.LocalWalletNotAvailableError();\n            }\n            throw \"from\" === e ? new c.InvalidTransactionWithSender(r.from) : new c.InvalidTransactionWithReceiver(r.to);\n          }\n          if (\"from\" === e) {\n            if (!(0, a.isNullish)(n)) return (0, i.privateKeyToAddress)(n);\n            if (!(0, a.isNullish)(t.defaultAccount)) return t.defaultAccount;\n          }\n        }, t.getTransactionNonce = (e, t, r = e.defaultReturnFormat) => n(void 0, void 0, void 0, function* () {\n          if ((0, a.isNullish)(t)) throw new c.UnableToPopulateNonceError();\n          return (0, l.getTransactionCount)(e, t, e.defaultBlock, r);\n        }), t.getTransactionType = (e, t) => {\n          const r = (0, h.detectTransactionType)(e, t);\n          return (0, a.isNullish)(r) ? (0, a.isNullish)(t.defaultTransactionType) ? void 0 : (0, u.format)({\n            format: \"uint\"\n          }, t.defaultTransactionType, o.ETH_DATA_FORMAT) : r;\n        }, t.defaultTransactionBuilder = m, t.transactionBuilder = e => n(void 0, void 0, void 0, function* () {\n          var t;\n          return (null !== (t = e.web3Context.transactionBuilder) && void 0 !== t ? t : m)(Object.assign(Object.assign({}, e), {\n            transaction: e.transaction\n          }));\n        });\n      },\n      8425: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.trySendTransaction = void 0;\n        const o = r(9634),\n          i = r(5071),\n          s = r(4659);\n        t.trySendTransaction = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            const [n, a] = (0, o.rejectIfTimeout)(e.transactionSendTimeout, new i.TransactionSendTimeoutError({\n                numberOfSeconds: e.transactionSendTimeout / 1e3,\n                transactionHash: r\n              })),\n              [c, u] = yield (0, s.rejectIfBlockTimeout)(e, r);\n            try {\n              return yield Promise.race([t(), a, c]);\n            } finally {\n              clearTimeout(n), u.clean();\n            }\n          });\n        };\n      },\n      4745: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.waitForTransactionReceipt = void 0;\n        const o = r(5071),\n          i = r(9634),\n          s = r(4659),\n          a = r(3222);\n        t.waitForTransactionReceipt = function (e, t, r, c) {\n          var u;\n          return n(this, void 0, void 0, function* () {\n            const d = null !== (u = e.transactionReceiptPollingInterval) && void 0 !== u ? u : e.transactionPollingInterval,\n              [l, h] = (0, i.pollTillDefinedAndReturnIntervalId)(() => n(this, void 0, void 0, function* () {\n                try {\n                  return (null != c ? c : a.getTransactionReceipt)(e, t, r);\n                } catch (e) {\n                  return void console.warn(\"An error happen while trying to get the transaction receipt\", e);\n                }\n              }), d),\n              [f, p] = (0, i.rejectIfTimeout)(e.transactionPollingTimeout, new o.TransactionPollingTimeoutError({\n                numberOfSeconds: e.transactionPollingTimeout / 1e3,\n                transactionHash: t\n              })),\n              [m, g] = yield (0, s.rejectIfBlockTimeout)(e, t);\n            try {\n              return yield Promise.race([l, p, m]);\n            } finally {\n              f && clearTimeout(f), h && clearInterval(h), g.clean();\n            }\n          });\n        };\n      },\n      8717: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.watchTransactionByPolling = void 0;\n        const o = r(9634),\n          i = r(1181),\n          s = r(1922);\n        t.watchTransactionByPolling = ({\n          web3Context: e,\n          transactionReceipt: t,\n          transactionPromiEvent: r,\n          customTransactionReceiptSchema: a,\n          returnFormat: c\n        }) => {\n          var u;\n          let d = 1;\n          const l = setInterval(() => {\n            n(void 0, void 0, void 0, function* () {\n              d >= e.transactionConfirmationBlocks && clearInterval(l);\n              const n = yield i.ethRpcMethods.getBlockByNumber(e.requestManager, (0, o.numberToHex)(BigInt(t.blockNumber) + BigInt(d)), !1);\n              (null == n ? void 0 : n.hash) && (d += 1, r.emit(\"confirmation\", {\n                confirmations: (0, o.format)({\n                  format: \"uint\"\n                }, d, c),\n                receipt: (0, o.format)(null != a ? a : s.transactionReceiptSchema, t, c),\n                latestBlockHash: (0, o.format)({\n                  format: \"bytes32\"\n                }, n.hash, c)\n              }));\n            });\n          }, null !== (u = e.transactionReceiptPollingInterval) && void 0 !== u ? u : e.transactionPollingInterval);\n        };\n      },\n      2539: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.watchTransactionBySubscription = void 0;\n        const o = r(9634),\n          i = r(1922),\n          s = r(8717);\n        t.watchTransactionBySubscription = ({\n          web3Context: e,\n          transactionReceipt: t,\n          transactionPromiEvent: r,\n          customTransactionReceiptSchema: a,\n          returnFormat: c\n        }) => {\n          let u,\n            d = !0;\n          setImmediate(() => {\n            var l;\n            null === (l = e.subscriptionManager) || void 0 === l || l.subscribe(\"newHeads\").then(l => {\n              l.on(\"data\", s => n(void 0, void 0, void 0, function* () {\n                var n;\n                if (d = !1, !(null == s ? void 0 : s.number) || u === (null == s ? void 0 : s.parentHash)) return;\n                u = null == s ? void 0 : s.parentHash;\n                const h = BigInt(s.number) - BigInt(t.blockNumber) + BigInt(1);\n                r.emit(\"confirmation\", {\n                  confirmations: (0, o.format)({\n                    format: \"uint\"\n                  }, h, c),\n                  receipt: (0, o.format)(null != a ? a : i.transactionReceiptSchema, t, c),\n                  latestBlockHash: (0, o.format)({\n                    format: \"bytes32\"\n                  }, s.parentHash, c)\n                }), h >= e.transactionConfirmationBlocks && (yield null === (n = e.subscriptionManager) || void 0 === n ? void 0 : n.removeSubscription(l));\n              })), l.on(\"error\", () => n(void 0, void 0, void 0, function* () {\n                var n;\n                yield null === (n = e.subscriptionManager) || void 0 === n ? void 0 : n.removeSubscription(l), d = !1, (0, s.watchTransactionByPolling)({\n                  web3Context: e,\n                  transactionReceipt: t,\n                  transactionPromiEvent: r,\n                  customTransactionReceiptSchema: a,\n                  returnFormat: c\n                });\n              }));\n            }).catch(() => {\n              d = !1, (0, s.watchTransactionByPolling)({\n                web3Context: e,\n                transactionReceipt: t,\n                customTransactionReceiptSchema: a,\n                transactionPromiEvent: r,\n                returnFormat: c\n              });\n            });\n          }), setTimeout(() => {\n            d && (0, s.watchTransactionByPolling)({\n              web3Context: e,\n              transactionReceipt: t,\n              transactionPromiEvent: r,\n              returnFormat: c\n            });\n          }, 1e3 * e.blockHeaderTimeout);\n        };\n      },\n      2117: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.watchTransactionForConfirmations = void 0;\n        const n = r(9634),\n          o = r(7345),\n          i = r(5071),\n          s = r(1922),\n          a = r(8717),\n          c = r(2539);\n        t.watchTransactionForConfirmations = function (e, t, r, u, d, l) {\n          if ((0, o.isNullish)(r) || (0, o.isNullish)(r.blockHash)) throw new i.TransactionMissingReceiptOrBlockHashError({\n            receipt: r,\n            blockHash: (0, n.format)({\n              format: \"bytes32\"\n            }, null == r ? void 0 : r.blockHash, d),\n            transactionHash: (0, n.format)({\n              format: \"bytes32\"\n            }, u, d)\n          });\n          if (!r.blockNumber) throw new i.TransactionReceiptMissingBlockNumberError({\n            receipt: r\n          });\n          t.emit(\"confirmation\", {\n            confirmations: (0, n.format)({\n              format: \"uint\"\n            }, 1, d),\n            receipt: (0, n.format)(null != l ? l : s.transactionReceiptSchema, r, d),\n            latestBlockHash: (0, n.format)({\n              format: \"bytes32\"\n            }, r.blockHash, d)\n          });\n          const h = e.requestManager.provider;\n          h && \"supportsSubscriptions\" in h && h.supportsSubscriptions() ? (0, c.watchTransactionBySubscription)({\n            web3Context: e,\n            transactionReceipt: r,\n            transactionPromiEvent: t,\n            customTransactionReceiptSchema: l,\n            returnFormat: d\n          }) : (0, a.watchTransactionByPolling)({\n            web3Context: e,\n            transactionReceipt: r,\n            transactionPromiEvent: t,\n            customTransactionReceiptSchema: l,\n            returnFormat: d\n          });\n        };\n      },\n      8650: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.validateTransactionForSigning = t.validateGas = t.validateFeeMarketGas = t.validateLegacyGas = t.validateHardfork = t.validateBaseChain = t.validateChainInfo = t.validateCustomChainInfo = t.validateTransactionCall = t.isTransactionCall = t.validateTransactionWithSender = t.isTransactionWithSender = t.isTransactionLegacyUnsigned = t.isTransaction2930Unsigned = t.isTransaction1559Unsigned = t.isAccessList = t.isAccessListEntry = t.isBaseTransaction = void 0;\n        const n = r(9970),\n          o = r(7345),\n          i = r(5071),\n          s = r(5140);\n        function a(e) {\n          return !(!(0, o.isNullish)(e.to) && !(0, o.isAddress)(e.to) || !(0, o.isHexStrict)(e.type) && !(0, o.isNullish)(e.type) && 2 !== e.type.length || !(0, o.isHexStrict)(e.nonce) || !(0, o.isHexStrict)(e.gas) || !(0, o.isHexStrict)(e.value) || !(0, o.isHexStrict)(e.input) || e.chainId && !(0, o.isHexStrict)(e.chainId));\n        }\n        function c(e) {\n          return !(!(0, o.isNullish)(e.address) && !(0, o.isAddress)(e.address) || !(0, o.isNullish)(e.storageKeys) && !e.storageKeys.every(e => (0, o.isHexString32Bytes)(e)));\n        }\n        function u(e) {\n          return !(!Array.isArray(e) || !e.every(e => c(e)));\n        }\n        function d(e) {\n          return !!(a(e) && (0, o.isHexStrict)(e.maxFeePerGas) && (0, o.isHexStrict)(e.maxPriorityFeePerGas) && u(e.accessList));\n        }\n        function l(e) {\n          return !!a(e) && !!(0, o.isHexStrict)(e.gasPrice) && !!u(e.accessList);\n        }\n        function h(e) {\n          return !!a(e) && !!(0, o.isHexStrict)(e.gasPrice);\n        }\n        function f(e) {\n          return !!(0, o.isAddress)(e.from) && !!a(e) && !!(d(e) || l(e) || h(e));\n        }\n        function p(e) {\n          return !(!(0, o.isNullish)(e.from) && !(0, o.isAddress)(e.from) || !(0, o.isAddress)(e.to) || !(0, o.isNullish)(e.gas) && !(0, o.isHexStrict)(e.gas) || !(0, o.isNullish)(e.gasPrice) && !(0, o.isHexStrict)(e.gasPrice) || !(0, o.isNullish)(e.value) && !(0, o.isHexStrict)(e.value) || !(0, o.isNullish)(e.data) && !(0, o.isHexStrict)(e.data) || !(0, o.isNullish)(e.input) && !(0, o.isHexStrict)(e.input) || !(0, o.isNullish)(e.type) || d(e) || l(e));\n        }\n        t.isBaseTransaction = a, t.isAccessListEntry = c, t.isAccessList = u, t.isTransaction1559Unsigned = d, t.isTransaction2930Unsigned = l, t.isTransactionLegacyUnsigned = h, t.isTransactionWithSender = f, t.validateTransactionWithSender = function (e) {\n          if (!f(e)) throw new i.InvalidTransactionWithSender(e);\n        }, t.isTransactionCall = p, t.validateTransactionCall = function (e) {\n          if (!p(e)) throw new i.InvalidTransactionCall(e);\n        }, t.validateCustomChainInfo = e => {\n          if (!(0, o.isNullish)(e.common)) {\n            if ((0, o.isNullish)(e.common.customChain)) throw new i.MissingCustomChainError();\n            if ((0, o.isNullish)(e.common.customChain.chainId)) throw new i.MissingCustomChainIdError();\n            if (!(0, o.isNullish)(e.chainId) && e.chainId !== e.common.customChain.chainId) throw new i.ChainIdMismatchError({\n              txChainId: e.chainId,\n              customChainId: e.common.customChain.chainId\n            });\n          }\n        }, t.validateChainInfo = e => {\n          if (!(0, o.isNullish)(e.common) && !(0, o.isNullish)(e.chain) && !(0, o.isNullish)(e.hardfork)) throw new i.CommonOrChainAndHardforkError();\n          if (!(0, o.isNullish)(e.chain) && (0, o.isNullish)(e.hardfork) || !(0, o.isNullish)(e.hardfork) && (0, o.isNullish)(e.chain)) throw new i.MissingChainOrHardforkError({\n            chain: e.chain,\n            hardfork: e.hardfork\n          });\n        }, t.validateBaseChain = e => {\n          if (!(0, o.isNullish)(e.common) && !(0, o.isNullish)(e.common.baseChain) && !(0, o.isNullish)(e.chain) && e.chain !== e.common.baseChain) throw new i.ChainMismatchError({\n            txChain: e.chain,\n            baseChain: e.common.baseChain\n          });\n        }, t.validateHardfork = e => {\n          if (!(0, o.isNullish)(e.common) && !(0, o.isNullish)(e.common.hardfork) && !(0, o.isNullish)(e.hardfork) && e.hardfork !== e.common.hardfork) throw new i.HardforkMismatchError({\n            txHardfork: e.hardfork,\n            commonHardfork: e.common.hardfork\n          });\n        }, t.validateLegacyGas = e => {\n          if ((0, o.isNullish)(e.gas) || !(0, o.isUInt)(e.gas) || (0, o.isNullish)(e.gasPrice) || !(0, o.isUInt)(e.gasPrice)) throw new i.InvalidGasOrGasPrice({\n            gas: e.gas,\n            gasPrice: e.gasPrice\n          });\n          if (!(0, o.isNullish)(e.maxFeePerGas) || !(0, o.isNullish)(e.maxPriorityFeePerGas)) throw new i.UnsupportedFeeMarketError({\n            maxFeePerGas: e.maxFeePerGas,\n            maxPriorityFeePerGas: e.maxPriorityFeePerGas\n          });\n        }, t.validateFeeMarketGas = e => {\n          if (!(0, o.isNullish)(e.gasPrice) && \"0x2\" === e.type) throw new i.Eip1559GasPriceError(e.gasPrice);\n          if (\"0x0\" === e.type || \"0x1\" === e.type) throw new i.UnsupportedFeeMarketError({\n            maxFeePerGas: e.maxFeePerGas,\n            maxPriorityFeePerGas: e.maxPriorityFeePerGas\n          });\n          if ((0, o.isNullish)(e.maxFeePerGas) || !(0, o.isUInt)(e.maxFeePerGas) || (0, o.isNullish)(e.maxPriorityFeePerGas) || !(0, o.isUInt)(e.maxPriorityFeePerGas)) throw new i.InvalidMaxPriorityFeePerGasOrMaxFeePerGas({\n            maxPriorityFeePerGas: e.maxPriorityFeePerGas,\n            maxFeePerGas: e.maxFeePerGas\n          });\n        }, t.validateGas = e => {\n          const r = !(0, o.isNullish)(e.gas) || !(0, o.isNullish)(e.gasLimit),\n            n = r && !(0, o.isNullish)(e.gasPrice),\n            s = r && !(0, o.isNullish)(e.maxPriorityFeePerGas) && !(0, o.isNullish)(e.maxFeePerGas);\n          if (!n && !s) throw new i.MissingGasError({\n            gas: e.gas,\n            gasPrice: e.gasPrice,\n            maxPriorityFeePerGas: e.maxPriorityFeePerGas,\n            maxFeePerGas: e.maxFeePerGas\n          });\n          if (n && s) throw new i.TransactionGasMismatchError({\n            gas: e.gas,\n            gasPrice: e.gasPrice,\n            maxPriorityFeePerGas: e.maxPriorityFeePerGas,\n            maxFeePerGas: e.maxFeePerGas\n          });\n          (n ? t.validateLegacyGas : t.validateFeeMarketGas)(e), (!(0, o.isNullish)(e.type) && e.type > \"0x1\" ? t.validateFeeMarketGas : t.validateLegacyGas)(e);\n        }, t.validateTransactionForSigning = (e, r) => {\n          if (!(0, o.isNullish)(r)) return void r(e);\n          if (\"object\" != typeof e || (0, o.isNullish)(e)) throw new i.InvalidTransactionObjectError(e);\n          (0, t.validateCustomChainInfo)(e), (0, t.validateChainInfo)(e), (0, t.validateBaseChain)(e), (0, t.validateHardfork)(e);\n          const a = (0, s.formatTransaction)(e, n.ETH_DATA_FORMAT);\n          if ((0, t.validateGas)(a), (0, o.isNullish)(a.nonce) || (0, o.isNullish)(a.chainId) || a.nonce.startsWith(\"-\") || a.chainId.startsWith(\"-\")) throw new i.InvalidNonceOrChainIdError({\n            nonce: e.nonce,\n            chainId: e.chainId\n          });\n        };\n      },\n      1435: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          i = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return o(t, e), t;\n          },\n          s = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (o, i) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3Eth = t.registeredSubscriptions = void 0;\n        const a = r(9970),\n          c = r(6527),\n          u = r(5071),\n          d = r(9634),\n          l = r(1181),\n          h = i(r(3222)),\n          f = r(7460);\n        t.registeredSubscriptions = {\n          logs: f.LogsSubscription,\n          newPendingTransactions: f.NewPendingTransactionsSubscription,\n          newHeads: f.NewHeadsSubscription,\n          syncing: f.SyncingSubscription,\n          pendingTransactions: f.NewPendingTransactionsSubscription,\n          newBlockHeaders: f.NewHeadsSubscription\n        };\n        class p extends c.Web3Context {\n          constructor(e) {\n            \"string\" == typeof e || (0, c.isSupportedProvider)(e) ? super({\n              provider: e,\n              registeredSubscriptions: t.registeredSubscriptions\n            }) : e.registeredSubscriptions ? super(e) : (super(Object.assign(Object.assign({}, e), {\n              registeredSubscriptions: t.registeredSubscriptions\n            })), this.getFeeData = this.calculateFeeData);\n          }\n          setTransactionMiddleware(e) {\n            this.transactionMiddleware = e;\n          }\n          getTransactionMiddleware() {\n            return this.transactionMiddleware;\n          }\n          getProtocolVersion() {\n            return s(this, void 0, void 0, function* () {\n              return l.ethRpcMethods.getProtocolVersion(this.requestManager);\n            });\n          }\n          isSyncing() {\n            return s(this, void 0, void 0, function* () {\n              return l.ethRpcMethods.getSyncing(this.requestManager);\n            });\n          }\n          getCoinbase() {\n            return s(this, void 0, void 0, function* () {\n              return l.ethRpcMethods.getCoinbase(this.requestManager);\n            });\n          }\n          isMining() {\n            return s(this, void 0, void 0, function* () {\n              return l.ethRpcMethods.getMining(this.requestManager);\n            });\n          }\n          getHashrate(e) {\n            var t;\n            return void 0 === e && (e = null !== (t = this.defaultReturnFormat) && void 0 !== t ? t : a.DEFAULT_RETURN_FORMAT), s(this, void 0, void 0, function* () {\n              return this.getHashRate(e);\n            });\n          }\n          getHashRate(e = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.getHashRate(this, e);\n            });\n          }\n          getGasPrice(e = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.getGasPrice(this, e);\n            });\n          }\n          getMaxPriorityFeePerGas(e = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.getMaxPriorityFeePerGas(this, e);\n            });\n          }\n          calculateFeeData(e = BigInt(2), t = d.ethUnitMap.Gwei) {\n            var r;\n            return s(this, void 0, void 0, function* () {\n              const n = yield this.getBlock(void 0, !1),\n                o = null !== (r = null == n ? void 0 : n.baseFeePerGas) && void 0 !== r ? r : void 0;\n              let i, s, a;\n              try {\n                i = yield this.getGasPrice();\n              } catch (e) {}\n              try {\n                s = yield this.getMaxPriorityFeePerGas();\n              } catch (e) {}\n              return o && (s = null != s ? s : t, a = o * e + s), {\n                gasPrice: i,\n                maxFeePerGas: a,\n                maxPriorityFeePerGas: s,\n                baseFeePerGas: o\n              };\n            });\n          }\n          getAccounts() {\n            var e;\n            return s(this, void 0, void 0, function* () {\n              return (null !== (e = yield l.ethRpcMethods.getAccounts(this.requestManager)) && void 0 !== e ? e : []).map(e => (0, d.toChecksumAddress)(e));\n            });\n          }\n          getBlockNumber(e = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.getBlockNumber(this, e);\n            });\n          }\n          getBalance(e, t = this.defaultBlock, r = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.getBalance(this, e, t, r);\n            });\n          }\n          getStorageAt(e, t, r = this.defaultBlock, n = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.getStorageAt(this, e, t, r, n);\n            });\n          }\n          getCode(e, t = this.defaultBlock, r = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.getCode(this, e, t, r);\n            });\n          }\n          getBlock(e = this.defaultBlock, t = !1, r = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.getBlock(this, e, t, r);\n            });\n          }\n          getBlockTransactionCount(e = this.defaultBlock, t = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.getBlockTransactionCount(this, e, t);\n            });\n          }\n          getBlockUncleCount(e = this.defaultBlock, t = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.getBlockUncleCount(this, e, t);\n            });\n          }\n          getUncle(e = this.defaultBlock, t, r = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.getUncle(this, e, t, r);\n            });\n          }\n          getTransaction(e, t = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              const r = yield h.getTransaction(this, e, t);\n              if (!r) throw new u.TransactionNotFound();\n              return r;\n            });\n          }\n          getPendingTransactions(e = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.getPendingTransactions(this, e);\n            });\n          }\n          getTransactionFromBlock(e = this.defaultBlock, t, r = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.getTransactionFromBlock(this, e, t, r);\n            });\n          }\n          getTransactionReceipt(e, t = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              const r = yield h.getTransactionReceipt(this, e, t);\n              if (!r) throw new u.TransactionNotFound();\n              return r;\n            });\n          }\n          getTransactionCount(e, t = this.defaultBlock, r = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.getTransactionCount(this, e, t, r);\n            });\n          }\n          sendTransaction(e, t = this.defaultReturnFormat, r) {\n            return h.sendTransaction(this, e, t, r, this.transactionMiddleware);\n          }\n          sendSignedTransaction(e, t = this.defaultReturnFormat, r) {\n            return h.sendSignedTransaction(this, e, t, r);\n          }\n          sign(e, t, r = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.sign(this, e, t, r);\n            });\n          }\n          signTransaction(e, t = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.signTransaction(this, e, t);\n            });\n          }\n          call(e, t = this.defaultBlock, r = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.call(this, e, t, r);\n            });\n          }\n          estimateGas(e, t = this.defaultBlock, r = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.estimateGas(this, e, t, r);\n            });\n          }\n          getPastLogs(e, t = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.getLogs(this, e, t);\n            });\n          }\n          getWork() {\n            return s(this, void 0, void 0, function* () {\n              return l.ethRpcMethods.getWork(this.requestManager);\n            });\n          }\n          submitWork(e, t, r) {\n            return s(this, void 0, void 0, function* () {\n              return l.ethRpcMethods.submitWork(this.requestManager, e, t, r);\n            });\n          }\n          requestAccounts() {\n            return s(this, void 0, void 0, function* () {\n              return l.ethRpcMethods.requestAccounts(this.requestManager);\n            });\n          }\n          getChainId(e = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.getChainId(this, e);\n            });\n          }\n          getNodeInfo() {\n            return s(this, void 0, void 0, function* () {\n              return l.ethRpcMethods.getNodeInfo(this.requestManager);\n            });\n          }\n          getProof(e, t, r = this.defaultBlock, n = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.getProof(this, e, t, r, n);\n            });\n          }\n          getFeeHistory(e, t = this.defaultBlock, r, n = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.getFeeHistory(this, e, t, r, n);\n            });\n          }\n          createAccessList(e, t = this.defaultBlock, r = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return h.createAccessList(this, e, t, r);\n            });\n          }\n          signTypedData(e, t, r, n) {\n            var o;\n            return void 0 === r && (r = !1), void 0 === n && (n = null !== (o = this.defaultReturnFormat) && void 0 !== o ? o : a.DEFAULT_RETURN_FORMAT), s(this, void 0, void 0, function* () {\n              return h.signTypedData(this, e, t, r, n);\n            });\n          }\n          subscribe(e, t, r) {\n            var n, o;\n            return void 0 === r && (r = null !== (n = this.defaultReturnFormat) && void 0 !== n ? n : a.DEFAULT_RETURN_FORMAT), s(this, void 0, void 0, function* () {\n              const n = yield null === (o = this.subscriptionManager) || void 0 === o ? void 0 : o.subscribe(e, t, r);\n              return n instanceof f.LogsSubscription && \"logs\" === e && \"object\" == typeof t && !(0, d.isNullish)(t.fromBlock) && Number.isFinite(Number(t.fromBlock)) && setImmediate(() => {\n                this.getPastLogs(t).then(e => {\n                  for (const t of e) n._processSubscriptionResult(t);\n                }).catch(e => {\n                  n._processSubscriptionError(e);\n                });\n              }), n;\n            });\n          }\n          static shouldClearSubscription({\n            sub: e\n          }) {\n            return !(e instanceof f.SyncingSubscription);\n          }\n          clearSubscriptions(e = !1) {\n            var t;\n            return null === (t = this.subscriptionManager) || void 0 === t ? void 0 : t.unsubscribe(e ? p.shouldClearSubscription : void 0);\n          }\n        }\n        t.Web3Eth = p;\n      },\n      7460: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SyncingSubscription = t.NewHeadsSubscription = t.NewPendingTransactionsSubscription = t.LogsSubscription = void 0;\n        const n = r(9634),\n          o = r(6527),\n          i = r(1922);\n        class s extends o.Web3Subscription {\n          _buildSubscriptionParams() {\n            return [\"logs\", this.args];\n          }\n          formatSubscriptionResult(e) {\n            return (0, n.format)(i.logSchema, e, super.returnFormat);\n          }\n        }\n        t.LogsSubscription = s;\n        class a extends o.Web3Subscription {\n          _buildSubscriptionParams() {\n            return [\"newPendingTransactions\"];\n          }\n          formatSubscriptionResult(e) {\n            return (0, n.format)({\n              format: \"string\"\n            }, e, super.returnFormat);\n          }\n        }\n        t.NewPendingTransactionsSubscription = a;\n        class c extends o.Web3Subscription {\n          _buildSubscriptionParams() {\n            return [\"newHeads\"];\n          }\n          formatSubscriptionResult(e) {\n            return (0, n.format)(i.blockHeaderSchema, e, super.returnFormat);\n          }\n        }\n        t.NewHeadsSubscription = c;\n        class u extends o.Web3Subscription {\n          _buildSubscriptionParams() {\n            return [\"syncing\"];\n          }\n          _processSubscriptionResult(e) {\n            if (\"boolean\" == typeof e) this.emit(\"changed\", e);else {\n              const t = Object.fromEntries(Object.entries(e.status).map(([e, t]) => [e.charAt(0).toLowerCase() + e.substring(1), t]));\n              this.emit(\"changed\", e.syncing), this.emit(\"data\", (0, n.format)(i.syncSchema, t, super.returnFormat));\n            }\n          }\n        }\n        t.SyncingSubscription = u;\n      },\n      9820: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n        const i = r(2491);\n        o(r(2491), t), o(r(7961), t), t.default = i.Net;\n      },\n      2491: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          i = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return o(t, e), t;\n          },\n          s = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (o, i) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Net = void 0;\n        const a = r(6527),\n          c = i(r(7961));\n        class u extends a.Web3Context {\n          getId(e = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return c.getId(this, e);\n            });\n          }\n          getPeerCount(e = this.defaultReturnFormat) {\n            return s(this, void 0, void 0, function* () {\n              return c.getPeerCount(this, e);\n            });\n          }\n          isListening() {\n            return s(this, void 0, void 0, function* () {\n              return c.isListening(this);\n            });\n          }\n        }\n        t.Net = u;\n      },\n      7961: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isListening = t.getPeerCount = t.getId = void 0;\n        const o = r(9634),\n          i = r(1181);\n        t.getId = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            const r = yield i.netRpcMethods.getId(e.requestManager);\n            return (0, o.format)({\n              format: \"uint\"\n            }, r, t);\n          });\n        }, t.getPeerCount = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            const r = yield i.netRpcMethods.getPeerCount(e.requestManager);\n            return (0, o.format)({\n              format: \"uint\"\n            }, r, t);\n          });\n        }, t.isListening = e => n(void 0, void 0, void 0, function* () {\n          return i.netRpcMethods.isListening(e.requestManager);\n        });\n      },\n      2636: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (o, i) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__importDefault || function (e) {\n            return e && e.__esModule ? e : {\n              default: e\n            };\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.HttpProvider = void 0;\n        const i = o(r(6279)),\n          s = r(9970),\n          a = r(5071);\n        class c extends s.Web3BaseProvider {\n          constructor(e, t) {\n            if (super(), !c.validateClientUrl(e)) throw new a.InvalidClientError(e);\n            this.clientUrl = e, this.httpProviderOptions = t;\n          }\n          static validateClientUrl(e) {\n            return \"string\" == typeof e && /^http(s)?:\\/\\//i.test(e);\n          }\n          getStatus() {\n            throw new a.MethodNotImplementedError();\n          }\n          supportsSubscriptions() {\n            return !1;\n          }\n          request(e, t) {\n            var r;\n            return n(this, void 0, void 0, function* () {\n              const n = Object.assign(Object.assign({}, null === (r = this.httpProviderOptions) || void 0 === r ? void 0 : r.providerOptions), t),\n                o = yield (0, i.default)(this.clientUrl, Object.assign(Object.assign({}, n), {\n                  method: \"POST\",\n                  headers: Object.assign(Object.assign({}, n.headers), {\n                    \"Content-Type\": \"application/json\"\n                  }),\n                  body: JSON.stringify(e)\n                }));\n              if (!o.ok) throw new a.ResponseError(yield o.json());\n              return yield o.json();\n            });\n          }\n          on() {\n            throw new a.MethodNotImplementedError();\n          }\n          removeListener() {\n            throw new a.MethodNotImplementedError();\n          }\n          once() {\n            throw new a.MethodNotImplementedError();\n          }\n          removeAllListeners() {\n            throw new a.MethodNotImplementedError();\n          }\n          connect() {\n            throw new a.MethodNotImplementedError();\n          }\n          disconnect() {\n            throw new a.MethodNotImplementedError();\n          }\n          reset() {\n            throw new a.MethodNotImplementedError();\n          }\n          reconnect() {\n            throw new a.MethodNotImplementedError();\n          }\n        }\n        t.default = c, t.HttpProvider = c;\n      },\n      1161: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.WebSocketProvider = void 0;\n        const o = n(r(7475)),\n          i = r(9634),\n          s = r(5071);\n        class a extends i.SocketProvider {\n          constructor(e, t, r) {\n            super(e, t, r);\n          }\n          _validateProviderPath(e) {\n            return \"string\" == typeof e && /^ws(s)?:\\/\\//i.test(e);\n          }\n          getStatus() {\n            if (this._socketConnection && !(0, i.isNullish)(this._socketConnection)) switch (this._socketConnection.readyState) {\n              case this._socketConnection.CONNECTING:\n                return \"connecting\";\n              case this._socketConnection.OPEN:\n                return \"connected\";\n              default:\n                return \"disconnected\";\n            }\n            return \"disconnected\";\n          }\n          _openSocketConnection() {\n            this._socketConnection = new o.default(this._socketPath, void 0, this._socketOptions && 0 === Object.keys(this._socketOptions).length ? void 0 : this._socketOptions);\n          }\n          _closeSocketConnection(e, t) {\n            var r;\n            null === (r = this._socketConnection) || void 0 === r || r.close(e, t);\n          }\n          _sendToSocket(e) {\n            var t;\n            if (\"disconnected\" === this.getStatus()) throw new s.ConnectionNotOpenError();\n            null === (t = this._socketConnection) || void 0 === t || t.send(JSON.stringify(e));\n          }\n          _parseResponses(e) {\n            return this.chunkResponseParser.parseResponse(e.data);\n          }\n          _addSocketListeners() {\n            var e, t, r, n;\n            null === (e = this._socketConnection) || void 0 === e || e.addEventListener(\"open\", this._onOpenHandler), null === (t = this._socketConnection) || void 0 === t || t.addEventListener(\"message\", this._onMessageHandler), null === (r = this._socketConnection) || void 0 === r || r.addEventListener(\"close\", e => this._onCloseHandler(e)), null === (n = this._socketConnection) || void 0 === n || n.addEventListener(\"error\", this._onErrorHandler);\n          }\n          _removeSocketListeners() {\n            var e, t, r;\n            null === (e = this._socketConnection) || void 0 === e || e.removeEventListener(\"message\", this._onMessageHandler), null === (t = this._socketConnection) || void 0 === t || t.removeEventListener(\"open\", this._onOpenHandler), null === (r = this._socketConnection) || void 0 === r || r.removeEventListener(\"close\", this._onCloseHandler);\n          }\n          _onCloseEvent(e) {\n            var t;\n            !this._reconnectOptions.autoReconnect || [1e3, 1001].includes(e.code) && e.wasClean ? (this._clearQueues(e), this._removeSocketListeners(), this._onDisconnect(e.code, e.reason), null === (t = this._socketConnection) || void 0 === t || t.removeEventListener(\"error\", this._onErrorHandler)) : this._reconnect();\n          }\n        }\n        t.default = a, t.WebSocketProvider = a;\n      },\n      9298: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getProof = t.getChainId = t.requestAccounts = t.getPendingTransactions = t.getFeeHistory = t.submitHashrate = t.submitWork = t.getWork = t.getLogs = t.getFilterLogs = t.getFilterChanges = t.uninstallFilter = t.newPendingTransactionFilter = t.newBlockFilter = t.newFilter = t.compileSerpent = t.compileLLL = t.compileSolidity = t.getCompilers = t.getUncleByBlockNumberAndIndex = t.getUncleByBlockHashAndIndex = t.getTransactionReceipt = t.getTransactionByBlockNumberAndIndex = t.getTransactionByBlockHashAndIndex = t.getTransactionByHash = t.getBlockByNumber = t.getBlockByHash = t.estimateGas = t.call = t.sendRawTransaction = t.sendTransaction = t.signTransaction = t.sign = t.getCode = t.getUncleCountByBlockNumber = t.getUncleCountByBlockHash = t.getBlockTransactionCountByNumber = t.getBlockTransactionCountByHash = t.getTransactionCount = t.getStorageAt = t.getBalance = t.getBlockNumber = t.getAccounts = t.getMaxPriorityFeePerGas = t.getGasPrice = t.getHashRate = t.getMining = t.getCoinbase = t.getSyncing = t.getProtocolVersion = void 0, t.signTypedData = t.createAccessList = t.getNodeInfo = void 0;\n        const o = r(7345);\n        t.getProtocolVersion = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_protocolVersion\",\n              params: []\n            });\n          });\n        }, t.getSyncing = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_syncing\",\n              params: []\n            });\n          });\n        }, t.getCoinbase = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_coinbase\",\n              params: []\n            });\n          });\n        }, t.getMining = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_mining\",\n              params: []\n            });\n          });\n        }, t.getHashRate = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_hashrate\",\n              params: []\n            });\n          });\n        }, t.getGasPrice = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_gasPrice\",\n              params: []\n            });\n          });\n        }, t.getMaxPriorityFeePerGas = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_maxPriorityFeePerGas\",\n              params: []\n            });\n          });\n        }, t.getAccounts = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_accounts\",\n              params: []\n            });\n          });\n        }, t.getBlockNumber = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_blockNumber\",\n              params: []\n            });\n          });\n        }, t.getBalance = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"address\", \"blockNumberOrTag\"], [t, r]), e.send({\n              method: \"eth_getBalance\",\n              params: [t, r]\n            });\n          });\n        }, t.getStorageAt = function (e, t, r, i) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"address\", \"hex\", \"blockNumberOrTag\"], [t, r, i]), e.send({\n              method: \"eth_getStorageAt\",\n              params: [t, r, i]\n            });\n          });\n        }, t.getTransactionCount = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"address\", \"blockNumberOrTag\"], [t, r]), e.send({\n              method: \"eth_getTransactionCount\",\n              params: [t, r]\n            });\n          });\n        }, t.getBlockTransactionCountByHash = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"bytes32\"], [t]), e.send({\n              method: \"eth_getBlockTransactionCountByHash\",\n              params: [t]\n            });\n          });\n        }, t.getBlockTransactionCountByNumber = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"blockNumberOrTag\"], [t]), e.send({\n              method: \"eth_getBlockTransactionCountByNumber\",\n              params: [t]\n            });\n          });\n        }, t.getUncleCountByBlockHash = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"bytes32\"], [t]), e.send({\n              method: \"eth_getUncleCountByBlockHash\",\n              params: [t]\n            });\n          });\n        }, t.getUncleCountByBlockNumber = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"blockNumberOrTag\"], [t]), e.send({\n              method: \"eth_getUncleCountByBlockNumber\",\n              params: [t]\n            });\n          });\n        }, t.getCode = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"address\", \"blockNumberOrTag\"], [t, r]), e.send({\n              method: \"eth_getCode\",\n              params: [t, r]\n            });\n          });\n        }, t.sign = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"address\", \"hex\"], [t, r]), e.send({\n              method: \"eth_sign\",\n              params: [t, r]\n            });\n          });\n        }, t.signTransaction = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_signTransaction\",\n              params: [t]\n            });\n          });\n        }, t.sendTransaction = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_sendTransaction\",\n              params: [t]\n            });\n          });\n        }, t.sendRawTransaction = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"hex\"], [t]), e.send({\n              method: \"eth_sendRawTransaction\",\n              params: [t]\n            });\n          });\n        }, t.call = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"blockNumberOrTag\"], [r]), e.send({\n              method: \"eth_call\",\n              params: [t, r]\n            });\n          });\n        }, t.estimateGas = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"blockNumberOrTag\"], [r]), e.send({\n              method: \"eth_estimateGas\",\n              params: [t, r]\n            });\n          });\n        }, t.getBlockByHash = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"bytes32\", \"bool\"], [t, r]), e.send({\n              method: \"eth_getBlockByHash\",\n              params: [t, r]\n            });\n          });\n        }, t.getBlockByNumber = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"blockNumberOrTag\", \"bool\"], [t, r]), e.send({\n              method: \"eth_getBlockByNumber\",\n              params: [t, r]\n            });\n          });\n        }, t.getTransactionByHash = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"bytes32\"], [t]), e.send({\n              method: \"eth_getTransactionByHash\",\n              params: [t]\n            });\n          });\n        }, t.getTransactionByBlockHashAndIndex = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"bytes32\", \"hex\"], [t, r]), e.send({\n              method: \"eth_getTransactionByBlockHashAndIndex\",\n              params: [t, r]\n            });\n          });\n        }, t.getTransactionByBlockNumberAndIndex = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"blockNumberOrTag\", \"hex\"], [t, r]), e.send({\n              method: \"eth_getTransactionByBlockNumberAndIndex\",\n              params: [t, r]\n            });\n          });\n        }, t.getTransactionReceipt = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"bytes32\"], [t]), e.send({\n              method: \"eth_getTransactionReceipt\",\n              params: [t]\n            });\n          });\n        }, t.getUncleByBlockHashAndIndex = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"bytes32\", \"hex\"], [t, r]), e.send({\n              method: \"eth_getUncleByBlockHashAndIndex\",\n              params: [t, r]\n            });\n          });\n        }, t.getUncleByBlockNumberAndIndex = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"blockNumberOrTag\", \"hex\"], [t, r]), e.send({\n              method: \"eth_getUncleByBlockNumberAndIndex\",\n              params: [t, r]\n            });\n          });\n        }, t.getCompilers = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_getCompilers\",\n              params: []\n            });\n          });\n        }, t.compileSolidity = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"string\"], [t]), e.send({\n              method: \"eth_compileSolidity\",\n              params: [t]\n            });\n          });\n        }, t.compileLLL = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"string\"], [t]), e.send({\n              method: \"eth_compileLLL\",\n              params: [t]\n            });\n          });\n        }, t.compileSerpent = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"string\"], [t]), e.send({\n              method: \"eth_compileSerpent\",\n              params: [t]\n            });\n          });\n        }, t.newFilter = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"filter\"], [t]), e.send({\n              method: \"eth_newFilter\",\n              params: [t]\n            });\n          });\n        }, t.newBlockFilter = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_newBlockFilter\",\n              params: []\n            });\n          });\n        }, t.newPendingTransactionFilter = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_newPendingTransactionFilter\",\n              params: []\n            });\n          });\n        }, t.uninstallFilter = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"hex\"], [t]), e.send({\n              method: \"eth_uninstallFilter\",\n              params: [t]\n            });\n          });\n        }, t.getFilterChanges = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"hex\"], [t]), e.send({\n              method: \"eth_getFilterChanges\",\n              params: [t]\n            });\n          });\n        }, t.getFilterLogs = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"hex\"], [t]), e.send({\n              method: \"eth_getFilterLogs\",\n              params: [t]\n            });\n          });\n        }, t.getLogs = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"filter\"], [t]), e.send({\n              method: \"eth_getLogs\",\n              params: [t]\n            });\n          });\n        }, t.getWork = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_getWork\",\n              params: []\n            });\n          });\n        }, t.submitWork = function (e, t, r, i) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"bytes8\", \"bytes32\", \"bytes32\"], [t, r, i]), e.send({\n              method: \"eth_submitWork\",\n              params: [t, r, i]\n            });\n          });\n        }, t.submitHashrate = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"bytes32\", \"bytes32\"], [t, r]), e.send({\n              method: \"eth_submitHashrate\",\n              params: [t, r]\n            });\n          });\n        }, t.getFeeHistory = function (e, t, r, i) {\n          return n(this, void 0, void 0, function* () {\n            o.validator.validate([\"hex\", \"blockNumberOrTag\"], [t, r]);\n            for (const e of i) o.validator.validate([\"number\"], [e]);\n            return e.send({\n              method: \"eth_feeHistory\",\n              params: [t, r, i]\n            });\n          });\n        }, t.getPendingTransactions = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_pendingTransactions\",\n              params: []\n            });\n          });\n        }, t.requestAccounts = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_requestAccounts\",\n              params: []\n            });\n          });\n        }, t.getChainId = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_chainId\",\n              params: []\n            });\n          });\n        }, t.getProof = function (e, t, r, i) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"address\", \"bytes32[]\", \"blockNumberOrTag\"], [t, r, i]), e.send({\n              method: \"eth_getProof\",\n              params: [t, r, i]\n            });\n          });\n        }, t.getNodeInfo = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"web3_clientVersion\",\n              params: []\n            });\n          });\n        }, t.createAccessList = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"blockNumberOrTag\"], [r]), e.send({\n              method: \"eth_createAccessList\",\n              params: [t, r]\n            });\n          });\n        }, t.signTypedData = function (e, t, r, i = !1) {\n          return n(this, void 0, void 0, function* () {\n            return o.validator.validate([\"address\"], [t]), e.send({\n              method: \"eth_signTypedData\" + (i ? \"\" : \"_v4\"),\n              params: [t, r]\n            });\n          });\n        };\n      },\n      1181: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          i = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return o(t, e), t;\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.personalRpcMethods = t.netRpcMethods = t.ethRpcMethods = void 0;\n        const s = i(r(9298));\n        t.ethRpcMethods = s;\n        const a = i(r(9960));\n        t.netRpcMethods = a;\n        const c = i(r(6745));\n        t.personalRpcMethods = c;\n      },\n      9960: function (e, t) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isListening = t.getPeerCount = t.getId = void 0, t.getId = function (e) {\n          return r(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"net_version\",\n              params: []\n            });\n          });\n        }, t.getPeerCount = function (e) {\n          return r(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"net_peerCount\",\n              params: []\n            });\n          });\n        }, t.isListening = function (e) {\n          return r(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"net_listening\",\n              params: []\n            });\n          });\n        };\n      },\n      6745: function (e, t) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ecRecover = t.sign = t.signTransaction = t.sendTransaction = t.importRawKey = t.lockAccount = t.unlockAccount = t.newAccount = t.getAccounts = void 0, t.getAccounts = e => r(void 0, void 0, void 0, function* () {\n          return e.send({\n            method: \"personal_listAccounts\",\n            params: []\n          });\n        }), t.newAccount = (e, t) => r(void 0, void 0, void 0, function* () {\n          return e.send({\n            method: \"personal_newAccount\",\n            params: [t]\n          });\n        }), t.unlockAccount = (e, t, n, o) => r(void 0, void 0, void 0, function* () {\n          return e.send({\n            method: \"personal_unlockAccount\",\n            params: [t, n, o]\n          });\n        }), t.lockAccount = (e, t) => r(void 0, void 0, void 0, function* () {\n          return e.send({\n            method: \"personal_lockAccount\",\n            params: [t]\n          });\n        }), t.importRawKey = (e, t, n) => r(void 0, void 0, void 0, function* () {\n          return e.send({\n            method: \"personal_importRawKey\",\n            params: [t, n]\n          });\n        }), t.sendTransaction = (e, t, n) => r(void 0, void 0, void 0, function* () {\n          return e.send({\n            method: \"personal_sendTransaction\",\n            params: [t, n]\n          });\n        }), t.signTransaction = (e, t, n) => r(void 0, void 0, void 0, function* () {\n          return e.send({\n            method: \"personal_signTransaction\",\n            params: [t, n]\n          });\n        }), t.sign = (e, t, n, o) => r(void 0, void 0, void 0, function* () {\n          return e.send({\n            method: \"personal_sign\",\n            params: [t, n, o]\n          });\n        }), t.ecRecover = (e, t, n) => r(void 0, void 0, void 0, function* () {\n          return e.send({\n            method: \"personal_ecRecover\",\n            params: [t, n]\n          });\n        });\n      },\n      294: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.mainnet = void 0;\n        const i = r(8590);\n        o(r(4740), t), o(r(8590), t), o(r(7214), t), t.mainnet = new i.QuickNodeProvider();\n      },\n      4740: (e, t) => {\n        \"use strict\";\n\n        var r, n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Network = t.Transport = void 0, (n = t.Transport || (t.Transport = {})).HTTPS = \"https\", n.WebSocket = \"wss\", (r = t.Network || (t.Network = {})).ETH_MAINNET = \"eth_mainnet\", r.ETH_GOERLI = \"eth_goerli\", r.ETH_SEPOLIA = \"eth_sepolia\", r.ETH_HOLESKY = \"eth_holesky\", r.POLYGON_MAINNET = \"polygon_mainnet\", r.POLYGON_MUMBAI = \"polygon_mumbai\", r.POLYGON_AMONY = \"polygon_amony\", r.ARBITRUM_MAINNET = \"arbitrum_mainnet\", r.ARBITRUM_SEPOLIA = \"arbitrum_sepolia\", r.BASE_MAINNET = \"base_mainnet\", r.BASE_SEPOLIA = \"base_sepolia\", r.OPTIMISM_MAINNET = \"optimism_mainnet\", r.OPTIMISM_SEPOLIA = \"optimism_sepolia\", r.BNB_MAINNET = \"bnb_mainnet\", r.BNB_TESTNET = \"bnb_testnet\";\n      },\n      7214: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (o, i) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__importDefault || function (e) {\n            return e && e.__esModule ? e : {\n              default: e\n            };\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3ExternalProvider = void 0;\n        const i = o(r(2636)),\n          s = o(r(1161)),\n          a = r(9634),\n          c = r(4740);\n        class u extends a.Eip1193Provider {\n          constructor(e, t, r, n) {\n            super(), this.transport = t, t === c.Transport.HTTPS ? this.provider = new i.default(this.getRPCURL(e, t, r, n)) : t === c.Transport.WebSocket && (this.provider = new s.default(this.getRPCURL(e, t, r, n)));\n          }\n          request(e, t) {\n            return n(this, void 0, void 0, function* () {\n              return this.transport === c.Transport.HTTPS ? this.provider.request(e, t) : this.provider.request(e);\n            });\n          }\n          getStatus() {\n            return this.provider.getStatus();\n          }\n          supportsSubscriptions() {\n            return this.provider.supportsSubscriptions();\n          }\n          once(e, t) {\n            var r;\n            (null === (r = this.provider) || void 0 === r ? void 0 : r.once) && this.provider.once(e, t);\n          }\n          removeAllListeners(e) {\n            var t;\n            (null === (t = this.provider) || void 0 === t ? void 0 : t.removeAllListeners) && this.provider.removeAllListeners(e);\n          }\n          connect() {\n            var e;\n            (null === (e = this.provider) || void 0 === e ? void 0 : e.connect) && this.provider.connect();\n          }\n          disconnect(e, t) {\n            var r;\n            (null === (r = this.provider) || void 0 === r ? void 0 : r.disconnect) && this.provider.disconnect(e, t);\n          }\n          reset() {\n            var e;\n            (null === (e = this.provider) || void 0 === e ? void 0 : e.reset) && this.provider.reset();\n          }\n          on(e, t) {\n            this.provider && this.provider.on(e, t);\n          }\n          removeListener(e, t) {\n            this.provider && this.provider.removeListener(e, t);\n          }\n        }\n        t.Web3ExternalProvider = u;\n      },\n      8590: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.QuickNodeProvider = void 0;\n        const n = r(4740),\n          o = r(7214),\n          i = e => void 0 !== e && e.trim().length > 0;\n        class s extends o.Web3ExternalProvider {\n          constructor(e = n.Network.ETH_MAINNET, t = n.Transport.HTTPS, r = \"\", o = \"\") {\n            super(e, t, r, o);\n          }\n          getRPCURL(e, t, r, o) {\n            let s = \"\",\n              a = \"\";\n            switch (e) {\n              case n.Network.ETH_MAINNET:\n                s = i(o) ? o : \"powerful-holy-bush.quiknode.pro\", a = i(r) ? r : \"3240624a343867035925ff7561eb60dfdba2a668\";\n                break;\n              case n.Network.ETH_SEPOLIA:\n                s = i(o) ? o : \"dimensional-fabled-glitter.ethereum-sepolia.quiknode.pro\", a = i(r) ? r : \"382a3b5a4b938f2d6e8686c19af4b22921fde2cd\";\n                break;\n              case n.Network.ETH_HOLESKY:\n                s = i(o) ? o : \"yolo-morning-card.ethereum-holesky.quiknode.pro\", a = i(r) ? r : \"481ebe70638c4dcf176af617a16d02ab866b9af9\";\n                break;\n              case n.Network.ARBITRUM_MAINNET:\n                s = i(o) ? o : \"autumn-divine-dinghy.arbitrum-mainnet.quiknode.pro\", a = i(r) ? r : \"a5d7bfbf60b5ae9ce3628e53d69ef50d529e9a8c\";\n                break;\n              case n.Network.ARBITRUM_SEPOLIA:\n                s = i(o) ? o : \"few-patient-pond.arbitrum-sepolia.quiknode.pro\", a = i(r) ? r : \"3be985450970628c860b959c65cd2642dcafe53c\";\n                break;\n              case n.Network.BNB_MAINNET:\n                s = i(o) ? o : \"purple-empty-reel.bsc.quiknode.pro\", a = i(r) ? r : \"ebf6c532961e21f092ff2facce1ec4c89c540158\";\n                break;\n              case n.Network.BNB_TESTNET:\n                s = i(o) ? o : \"floral-rough-scion.bsc-testnet.quiknode.pro\", a = i(r) ? r : \"5b297e5acff5f81f4c37ebf6f235f7299b6f9d28\";\n                break;\n              case n.Network.POLYGON_MAINNET:\n                s = i(o) ? o : \"small-chaotic-moon.matic.quiknode.pro\", a = i(r) ? r : \"847569f8a017e84d985e10d0f44365d965a951f1\";\n                break;\n              case n.Network.POLYGON_AMONY:\n                s = i(o) ? o : \"prettiest-side-shape.matic-amoy.quiknode.pro\", a = i(r) ? r : \"79a9476eea661d4f82de614db1d8a895b14b881c\";\n                break;\n              default:\n                throw new Error(\"Network info not avalible.\");\n            }\n            return `${t}://${s}/${a}`;\n          }\n        }\n        t.QuickNodeProvider = s;\n      },\n      6325: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      5529: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      2453: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      2856: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      6877: (e, t) => {\n        \"use strict\";\n\n        var r, n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ETH_DATA_FORMAT = t.DEFAULT_RETURN_FORMAT = t.FMT_BYTES = t.FMT_NUMBER = void 0, function (e) {\n          e.NUMBER = \"NUMBER_NUMBER\", e.HEX = \"NUMBER_HEX\", e.STR = \"NUMBER_STR\", e.BIGINT = \"NUMBER_BIGINT\";\n        }(r = t.FMT_NUMBER || (t.FMT_NUMBER = {})), function (e) {\n          e.HEX = \"BYTES_HEX\", e.UINT8ARRAY = \"BYTES_UINT8ARRAY\";\n        }(n = t.FMT_BYTES || (t.FMT_BYTES = {})), t.DEFAULT_RETURN_FORMAT = {\n          number: r.BIGINT,\n          bytes: n.HEX\n        }, t.ETH_DATA_FORMAT = {\n          number: r.HEX,\n          bytes: n.HEX\n        };\n      },\n      9779: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      1517: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      8223: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      4205: (e, t) => {\n        \"use strict\";\n\n        var r, n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.HardforksOrdered = t.BlockTags = void 0, (n = t.BlockTags || (t.BlockTags = {})).EARLIEST = \"earliest\", n.LATEST = \"latest\", n.PENDING = \"pending\", n.SAFE = \"safe\", n.FINALIZED = \"finalized\", (r = t.HardforksOrdered || (t.HardforksOrdered = {})).chainstart = \"chainstart\", r.frontier = \"frontier\", r.homestead = \"homestead\", r.dao = \"dao\", r.tangerineWhistle = \"tangerineWhistle\", r.spuriousDragon = \"spuriousDragon\", r.byzantium = \"byzantium\", r.constantinople = \"constantinople\", r.petersburg = \"petersburg\", r.istanbul = \"istanbul\", r.muirGlacier = \"muirGlacier\", r.berlin = \"berlin\", r.london = \"london\", r.altair = \"altair\", r.arrowGlacier = \"arrowGlacier\", r.grayGlacier = \"grayGlacier\", r.bellatrix = \"bellatrix\", r.merge = \"merge\", r.capella = \"capella\", r.shanghai = \"shanghai\";\n      },\n      9970: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), o(r(9779), t), o(r(6325), t), o(r(2453), t), o(r(2856), t), o(r(5529), t), o(r(6877), t), o(r(4205), t), o(r(1517), t), o(r(8223), t), o(r(2196), t), o(r(8887), t), o(r(8173), t), o(r(1040), t), o(r(5640), t), o(r(1436), t), o(r(4933), t);\n      },\n      2196: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      8887: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.TypedArray = void 0, t.TypedArray = Object.getPrototypeOf(Uint8Array);\n      },\n      8173: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      1040: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      5640: function (e, t) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3BaseProvider = void 0;\n        const n = Symbol.for(\"web3/base-provider\");\n        class o {\n          static isWeb3Provider(e) {\n            return e instanceof o || Boolean(e && e[n]);\n          }\n          get [n]() {\n            return !0;\n          }\n          send(e, t) {\n            this.request(e).then(e => {\n              t(null, e);\n            }).catch(e => {\n              t(e);\n            });\n          }\n          sendAsync(e) {\n            return r(this, void 0, void 0, function* () {\n              return this.request(e);\n            });\n          }\n          asEIP1193Provider() {\n            const e = Object.create(this),\n              t = e.request;\n            return e.request = function (e) {\n              return r(this, void 0, void 0, function* () {\n                return (yield t(e)).result;\n              });\n            }, e.asEIP1193Provider = void 0, e;\n          }\n        }\n        t.Web3BaseProvider = o;\n      },\n      1436: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3BaseWallet = void 0, t.Web3BaseWallet = class extends Array {\n          constructor(e) {\n            super(), this._accountProvider = e;\n          }\n        };\n      },\n      4933: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      4108: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ChunkResponseParser = void 0;\n        const n = r(5071);\n        t.ChunkResponseParser = class {\n          constructor(e, t) {\n            this.eventEmitter = e, this.autoReconnect = t, this.chunkTimeout = 15e3;\n          }\n          clearQueues() {\n            \"function\" == typeof this._clearQueues && this._clearQueues();\n          }\n          onError(e) {\n            this._clearQueues = e;\n          }\n          parseResponse(e) {\n            const t = [];\n            return e.replace(/\\}[\\n\\r]?\\{/g, \"}|--|{\").replace(/\\}\\][\\n\\r]?\\[\\{/g, \"}]|--|[{\").replace(/\\}[\\n\\r]?\\[\\{/g, \"}|--|[{\").replace(/\\}\\][\\n\\r]?\\{/g, \"}]|--|{\").split(\"|--|\").forEach(e => {\n              let r,\n                o = e;\n              this.lastChunk && (o = this.lastChunk + o);\n              try {\n                r = JSON.parse(o);\n              } catch (e) {\n                return this.lastChunk = o, this.lastChunkTimeout && clearTimeout(this.lastChunkTimeout), void (this.lastChunkTimeout = setTimeout(() => {\n                  this.autoReconnect || (this.clearQueues(), this.eventEmitter.emit(\"error\", new n.InvalidResponseError({\n                    id: 1,\n                    jsonrpc: \"2.0\",\n                    error: {\n                      code: 2,\n                      message: \"Chunk timeout\"\n                    }\n                  })));\n                }, this.chunkTimeout));\n              }\n              clearTimeout(this.lastChunkTimeout), this.lastChunk = void 0, r && t.push(r);\n            }), t;\n          }\n        };\n      },\n      7086: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.toBool = t.toChecksumAddress = t.toWei = t.fromWei = t.toBigInt = t.toNumber = t.toHex = t.toAscii = t.hexToAscii = t.fromAscii = t.asciiToHex = t.hexToString = t.utf8ToBytes = t.toUtf8 = t.hexToUtf8 = t.stringToHex = t.fromUtf8 = t.utf8ToHex = t.hexToNumberString = t.fromDecimal = t.numberToHex = t.toDecimal = t.hexToNumber = t.hexToBytes = t.bytesToHex = t.bytesToUint8Array = t.ethUnitMap = void 0;\n        const n = r(3687),\n          o = r(5487),\n          i = r(7345),\n          s = r(5071),\n          a = r(7541);\n        t.ethUnitMap = {\n          noether: BigInt(0),\n          wei: BigInt(1),\n          kwei: BigInt(1e3),\n          Kwei: BigInt(1e3),\n          babbage: BigInt(1e3),\n          femtoether: BigInt(1e3),\n          mwei: BigInt(1e6),\n          Mwei: BigInt(1e6),\n          lovelace: BigInt(1e6),\n          picoether: BigInt(1e6),\n          gwei: BigInt(1e9),\n          Gwei: BigInt(1e9),\n          shannon: BigInt(1e9),\n          nanoether: BigInt(1e9),\n          nano: BigInt(1e9),\n          szabo: BigInt(1e12),\n          microether: BigInt(1e12),\n          micro: BigInt(1e12),\n          finney: BigInt(1e15),\n          milliether: BigInt(1e15),\n          milli: BigInt(1e15),\n          ether: BigInt(\"1000000000000000000\"),\n          kether: BigInt(\"1000000000000000000000\"),\n          grand: BigInt(\"1000000000000000000000\"),\n          mether: BigInt(\"1000000000000000000000000\"),\n          gether: BigInt(\"1000000000000000000000000000\"),\n          tether: BigInt(\"1000000000000000000000000000000\")\n        };\n        const c = \"Warning: Using type `number` with values that are large or contain many decimals may cause loss of precision, it is recommended to use type `string` or `BigInt` when using conversion methods\";\n        t.bytesToUint8Array = e => {\n          if (i.validator.validate([\"bytes\"], [e]), (0, a.isUint8Array)(e)) return e;\n          if (Array.isArray(e)) return new Uint8Array(e);\n          if (\"string\" == typeof e) return i.utils.hexToUint8Array(e);\n          throw new s.InvalidBytesError(e);\n        };\n        const {\n          uint8ArrayToHexString: u\n        } = i.utils;\n        t.bytesToHex = e => u((0, t.bytesToUint8Array)(e)), t.hexToBytes = e => \"string\" == typeof e && \"0x\" !== e.slice(0, 2).toLowerCase() ? (0, t.bytesToUint8Array)(`0x${e}`) : (0, t.bytesToUint8Array)(e), t.hexToNumber = e => (i.validator.validate([\"hex\"], [e]), i.utils.hexToNumber(e)), t.toDecimal = t.hexToNumber, t.numberToHex = (e, t) => {\n          \"bigint\" != typeof e && i.validator.validate([\"int\"], [e]);\n          let r = i.utils.numberToHex(e);\n          return t && (r.startsWith(\"-\") || r.length % 2 != 1 ? r.length % 2 == 0 && r.startsWith(\"-\") && (r = \"-0x0\".concat(r.slice(3))) : r = \"0x0\".concat(r.slice(2))), r;\n        }, t.fromDecimal = t.numberToHex, t.hexToNumberString = e => (0, t.hexToNumber)(e).toString(), t.utf8ToHex = e => {\n          i.validator.validate([\"string\"], [e]);\n          let r = e.replace(/^(?:\\u0000)/, \"\");\n          return r = r.replace(/(?:\\u0000)$/, \"\"), (0, t.bytesToHex)(new TextEncoder().encode(r));\n        }, t.fromUtf8 = t.utf8ToHex, t.stringToHex = t.utf8ToHex, t.hexToUtf8 = e => (0, o.bytesToUtf8)((0, t.hexToBytes)(e)), t.toUtf8 = e => \"string\" == typeof e ? (0, t.hexToUtf8)(e) : (i.validator.validate([\"bytes\"], [e]), (0, o.bytesToUtf8)(e)), t.utf8ToBytes = o.utf8ToBytes, t.hexToString = t.hexToUtf8, t.asciiToHex = e => {\n          i.validator.validate([\"string\"], [e]);\n          let t = \"\";\n          for (let r = 0; r < e.length; r += 1) {\n            const n = e.charCodeAt(r).toString(16);\n            t += n.length % 2 != 0 ? `0${n}` : n;\n          }\n          return `0x${t}`;\n        }, t.fromAscii = t.asciiToHex, t.hexToAscii = e => new TextDecoder(\"ascii\").decode((0, t.hexToBytes)(e)), t.toAscii = t.hexToAscii, t.toHex = (e, r) => {\n          if (\"string\" == typeof e && (0, i.isAddress)(e)) return r ? \"address\" : `0x${e.toLowerCase().replace(/^0x/i, \"\")}`;\n          if (\"boolean\" == typeof e) return r ? \"bool\" : e ? \"0x01\" : \"0x00\";\n          if (\"number\" == typeof e) return r ? e < 0 ? \"int256\" : \"uint256\" : (0, t.numberToHex)(e);\n          if (\"bigint\" == typeof e) return r ? \"bigint\" : (0, t.numberToHex)(e);\n          if ((0, a.isUint8Array)(e)) return r ? \"bytes\" : (0, t.bytesToHex)(e);\n          if (\"object\" == typeof e && e) return r ? \"string\" : (0, t.utf8ToHex)(JSON.stringify(e));\n          if (\"string\" == typeof e) {\n            if (e.startsWith(\"-0x\") || e.startsWith(\"-0X\")) return r ? \"int256\" : (0, t.numberToHex)(e);\n            if ((0, i.isHexStrict)(e)) return r ? \"bytes\" : e;\n            if ((0, i.isHex)(e) && !(0, i.isInt)(e) && !(0, i.isUInt)(e)) return r ? \"bytes\" : `0x${e}`;\n            if ((0, i.isHex)(e) && !(0, i.isInt)(e) && (0, i.isUInt)(e)) return r ? \"uint\" : (0, t.numberToHex)(e);\n            if (!Number.isFinite(e)) return r ? \"string\" : (0, t.utf8ToHex)(e);\n          }\n          throw new s.HexProcessingError(e);\n        }, t.toNumber = e => {\n          if (\"number\" == typeof e) return e > 1e20 ? (console.warn(c), BigInt(e)) : e;\n          if (\"bigint\" == typeof e) return e >= Number.MIN_SAFE_INTEGER && e <= Number.MAX_SAFE_INTEGER ? Number(e) : e;\n          if (\"string\" == typeof e && (0, i.isHexStrict)(e)) return (0, t.hexToNumber)(e);\n          try {\n            return (0, t.toNumber)(BigInt(e));\n          } catch (t) {\n            throw new s.InvalidNumberError(e);\n          }\n        }, t.toBigInt = e => {\n          if (\"number\" == typeof e) return BigInt(e);\n          if (\"bigint\" == typeof e) return e;\n          if (\"string\" == typeof e && (0, i.isHex)(e)) return e.startsWith(\"-\") ? -BigInt(e.substring(1)) : BigInt(e);\n          throw new s.InvalidNumberError(e);\n        }, t.fromWei = (e, r) => {\n          let n;\n          if (\"string\" == typeof r) {\n            if (n = t.ethUnitMap[r], !n) throw new s.InvalidUnitError(r);\n          } else {\n            if (r < 0 || !Number.isInteger(r)) throw new s.InvalidIntegerError(r);\n            n = (0, i.bigintPower)(BigInt(10), BigInt(r));\n          }\n          const o = String((0, t.toNumber)(e)),\n            a = n.toString().length - 1;\n          if (a <= 0) return o.toString();\n          const c = o.padStart(a, \"0\"),\n            u = c.slice(0, -a),\n            d = c.slice(-a).replace(/\\.?0+$/, \"\");\n          return \"\" === u ? `0.${d}` : \"\" === d ? u : `${u}.${d}`.slice(0, u.length + a + 1);\n        }, t.toWei = (e, r) => {\n          let n;\n          if (i.validator.validate([\"number\"], [e]), \"string\" == typeof r) {\n            if (n = t.ethUnitMap[r], !n) throw new s.InvalidUnitError(r);\n          } else {\n            if (r < 0 || !Number.isInteger(r)) throw new s.InvalidIntegerError(r);\n            n = (0, i.bigintPower)(BigInt(10), BigInt(r));\n          }\n          let o = e;\n          \"number\" == typeof o && (o < 1e-15 && console.warn(c), o > 1e20 ? (console.warn(c), o = BigInt(o)) : o = o.toLocaleString(\"fullwide\", {\n            useGrouping: !1,\n            maximumFractionDigits: 20\n          }));\n          const [a, u] = String(\"string\" != typeof o || (0, i.isHexStrict)(o) ? (0, t.toNumber)(o) : o).split(\".\").concat(\"\"),\n            d = BigInt(`${a}${u}`) * n,\n            l = u.length;\n          return 0 === l ? d.toString() : d.toString().slice(0, -l);\n        }, t.toChecksumAddress = e => {\n          if (!(0, i.isAddress)(e, !1)) throw new s.InvalidAddressError(e);\n          const r = e.toLowerCase().replace(/^0x/i, \"\"),\n            o = i.utils.uint8ArrayToHexString((0, n.keccak256)(i.utils.ensureIfUint8Array((0, t.utf8ToBytes)(r))));\n          if ((0, i.isNullish)(o) || \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" === o) return \"\";\n          let a = \"0x\";\n          const c = o.replace(/^0x/i, \"\");\n          for (let e = 0; e < r.length; e += 1) parseInt(c[e], 16) > 7 ? a += r[e].toUpperCase() : a += r[e];\n          return a;\n        }, t.toBool = e => {\n          if (\"boolean\" == typeof e) return e;\n          if (\"number\" == typeof e && (0 === e || 1 === e)) return Boolean(e);\n          if (\"bigint\" == typeof e && (e === BigInt(0) || e === BigInt(1))) return Boolean(e);\n          if (\"string\" == typeof e && !(0, i.isHexStrict)(e) && (\"1\" === e || \"0\" === e || \"false\" === e || \"true\" === e)) return \"true\" === e || \"false\" !== e && Boolean(Number(e));\n          if (\"string\" == typeof e && (0, i.isHexStrict)(e) && (\"0x1\" === e || \"0x0\" === e)) return Boolean((0, t.toNumber)(e));\n          throw new s.InvalidBooleanError(e);\n        };\n      },\n      8512: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.EventEmitter = void 0;\n        const o = n(r(9386));\n        class i extends o.default {\n          constructor() {\n            super(...arguments), this.maxListeners = Number.MAX_SAFE_INTEGER;\n          }\n          setMaxListeners(e) {\n            return this.maxListeners = e, this;\n          }\n          getMaxListeners() {\n            return this.maxListeners;\n          }\n        }\n        t.EventEmitter = i;\n      },\n      3065: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.format = t.convert = t.convertScalarValue = t.isDataFormat = void 0;\n        const n = r(5071),\n          o = r(9970),\n          i = r(7345),\n          s = r(7086),\n          a = r(7151),\n          c = r(2557),\n          u = r(7541),\n          {\n            parseBaseType: d\n          } = i.utils;\n        t.isDataFormat = e => \"object\" == typeof e && !(0, i.isNullish)(e) && \"number\" in e && \"bytes\" in e;\n        const l = (e, t, r = []) => {\n          let n,\n            o = Object.assign({}, e);\n          for (const e of t) {\n            if (o.oneOf && n) {\n              const e = n,\n                t = r.find(([t]) => t === e);\n              t && t[0] === n && (o = o.oneOf[t[1]]);\n            }\n            if (!o.properties && !o.items) return;\n            o.properties ? o = o.properties[e] : o.items && o.items.properties ? o = o.items.properties[e] : o.items && (0, i.isObject)(o.items) ? o = o.items : o.items && Array.isArray(o.items) && (o = o.items[parseInt(e, 10)]), o && e && (n = e);\n          }\n          return o;\n        };\n        t.convertScalarValue = (e, t, r) => {\n          try {\n            const {\n              baseType: i,\n              baseTypeSize: a\n            } = d(t);\n            if (\"int\" === i || \"uint\" === i) switch (r.number) {\n              case o.FMT_NUMBER.NUMBER:\n                return Number((0, s.toBigInt)(e));\n              case o.FMT_NUMBER.HEX:\n                return (0, s.numberToHex)((0, s.toBigInt)(e));\n              case o.FMT_NUMBER.STR:\n                return (0, s.toBigInt)(e).toString();\n              case o.FMT_NUMBER.BIGINT:\n                return (0, s.toBigInt)(e);\n              default:\n                throw new n.FormatterError(`Invalid format: ${String(r.number)}`);\n            }\n            if (\"bytes\" === i) {\n              let t;\n              switch (a ? \"string\" == typeof e ? t = (0, c.padLeft)(e, 2 * a) : (0, u.isUint8Array)(e) && (t = (0, u.uint8ArrayConcat)(new Uint8Array(a - e.length), e)) : t = e, r.bytes) {\n                case o.FMT_BYTES.HEX:\n                  return (0, s.bytesToHex)((0, s.bytesToUint8Array)(t));\n                case o.FMT_BYTES.UINT8ARRAY:\n                  return (0, s.bytesToUint8Array)(t);\n                default:\n                  throw new n.FormatterError(`Invalid format: ${String(r.bytes)}`);\n              }\n            }\n          } catch (t) {\n            return e;\n          }\n          return e;\n        };\n        const h = ({\n          value: e,\n          schemaProp: r,\n          schema: n,\n          object: o,\n          key: s,\n          dataPath: a,\n          format: c,\n          oneOfPath: u = []\n        }) => {\n          var d, l;\n          if (Array.isArray(e)) {\n            let h = r;\n            if (void 0 !== (null == r ? void 0 : r.oneOf) && r.oneOf.forEach((t, n) => {\n              var o, i;\n              !Array.isArray(null == r ? void 0 : r.items) && (\"object\" == typeof e[0] && \"object\" === (null === (o = null == t ? void 0 : t.items) || void 0 === o ? void 0 : o.type) || \"string\" == typeof e[0] && \"object\" !== (null === (i = null == t ? void 0 : t.items) || void 0 === i ? void 0 : i.type)) && (h = t, u.push([s, n]));\n            }), (0, i.isNullish)(null == h ? void 0 : h.items)) return delete o[s], a.pop(), !0;\n            if ((0, i.isObject)(h.items) && !(0, i.isNullish)(h.items.format)) {\n              for (let r = 0; r < e.length; r += 1) o[s][r] = (0, t.convertScalarValue)(e[r], null === (d = null == h ? void 0 : h.items) || void 0 === d ? void 0 : d.format, c);\n              return a.pop(), !0;\n            }\n            if (!Array.isArray(null == h ? void 0 : h.items) && \"object\" === (null === (l = null == h ? void 0 : h.items) || void 0 === l ? void 0 : l.type)) {\n              for (const r of e) (0, t.convert)(r, n, a, c, u);\n              return a.pop(), !0;\n            }\n            if (Array.isArray(null == h ? void 0 : h.items)) {\n              for (let r = 0; r < e.length; r += 1) o[s][r] = (0, t.convertScalarValue)(e[r], h.items[r].format, c);\n              return a.pop(), !0;\n            }\n          }\n          return !1;\n        };\n        t.convert = (e, r, n, o, s = []) => {\n          var a;\n          if (!(0, i.isObject)(e) && !Array.isArray(e)) return (0, t.convertScalarValue)(e, null == r ? void 0 : r.format, o);\n          const c = e;\n          if (Array.isArray(c) && \"array\" === (null == r ? void 0 : r.type) && \"object\" === (null === (a = null == r ? void 0 : r.items) || void 0 === a ? void 0 : a.type)) h({\n            value: c,\n            schemaProp: r,\n            schema: r,\n            object: c,\n            key: \"\",\n            dataPath: n,\n            format: o,\n            oneOfPath: s\n          });else for (const [e, a] of Object.entries(c)) {\n            n.push(e);\n            const u = l(r, n, s);\n            (0, i.isNullish)(u) ? (delete c[e], n.pop()) : (0, i.isObject)(a) ? ((0, t.convert)(a, r, n, o, s), n.pop()) : h({\n              value: a,\n              schemaProp: u,\n              schema: r,\n              object: c,\n              key: e,\n              dataPath: n,\n              format: o,\n              oneOfPath: s\n            }) || (c[e] = (0, t.convertScalarValue)(a, u.format, o), n.pop());\n          }\n          return c;\n        }, t.format = (e, r, s = o.DEFAULT_RETURN_FORMAT) => {\n          let c;\n          c = (0, i.isObject)(r) ? (0, a.mergeDeep)({}, r) : Array.isArray(r) ? [...r] : r;\n          const u = (0, i.isObject)(e) ? e : i.utils.ethAbiToJsonSchema(e);\n          if (!u.properties && !u.items && !u.format) throw new n.FormatterError(\"Invalid json schema for formatting\");\n          return (0, t.convert)(c, u, [], s);\n        };\n      },\n      3561: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getStorageSlotNumForLongString = t.soliditySha3Raw = t.soliditySha3 = t.encodePacked = t.processSolidityEncodePackedArgs = t.keccak256 = t.keccak256Wrapper = t.sha3Raw = t.sha3 = void 0;\n        const n = r(3687),\n          o = r(5487),\n          i = r(5071),\n          s = r(7345),\n          a = r(7086),\n          c = r(2557),\n          u = \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\";\n        t.sha3 = e => {\n          let t;\n          t = \"string\" == typeof e ? e.startsWith(\"0x\") && (0, s.isHexStrict)(e) ? (0, a.hexToBytes)(e) : (0, o.utf8ToBytes)(e) : e;\n          const r = (0, a.bytesToHex)((0, n.keccak256)(s.utils.ensureIfUint8Array(t)));\n          return r === u ? void 0 : r;\n        }, t.sha3Raw = e => {\n          const r = (0, t.sha3)(e);\n          return (0, s.isNullish)(r) ? u : r;\n        }, t.keccak256Wrapper = e => {\n          let t;\n          return t = \"bigint\" == typeof e || \"number\" == typeof e ? (0, o.utf8ToBytes)(e.toString()) : Array.isArray(e) ? new Uint8Array(e) : \"string\" != typeof e || (0, s.isHexStrict)(e) ? (0, a.bytesToUint8Array)(e) : (0, o.utf8ToBytes)(e), (0, a.bytesToHex)((0, n.keccak256)(s.utils.ensureIfUint8Array(t)));\n        }, t.keccak256 = t.keccak256Wrapper;\n        const d = (e, t) => {\n            const r = /^(\\d+).*$/.exec(e.slice(t));\n            return r ? parseInt(r[1], 10) : 0;\n          },\n          l = e => e.toString(2).length,\n          h = (e, t) => {\n            const r = t.toString();\n            if (\"string\" === e) {\n              if (\"string\" == typeof t) return (0, a.utf8ToHex)(t);\n              throw new i.InvalidStringError(t);\n            }\n            if (\"bool\" === e || \"boolean\" === e) {\n              if (\"boolean\" == typeof t) return t ? \"01\" : \"00\";\n              throw new i.InvalidBooleanError(t);\n            }\n            if (\"address\" === e) {\n              if (!(0, s.isAddress)(r)) throw new i.InvalidAddressError(r);\n              return r;\n            }\n            const n = (e => e.startsWith(\"int[\") ? `int256${e.slice(3)}` : \"int\" === e ? \"int256\" : e.startsWith(\"uint[\") ? `uint256'${e.slice(4)}` : \"uint\" === e ? \"uint256\" : e)(e);\n            if (e.startsWith(\"uint\")) {\n              const e = d(n, \"uint\".length);\n              if (e % 8 || e < 8 || e > 256) throw new i.InvalidSizeError(r);\n              const t = (0, a.toNumber)(r);\n              if (l(t) > e) throw new i.InvalidLargeValueError(r);\n              if (t < BigInt(0)) throw new i.InvalidUnsignedIntegerError(r);\n              return e ? (0, c.leftPad)(t.toString(16), e / 8 * 2) : t.toString(16);\n            }\n            if (e.startsWith(\"int\")) {\n              const t = d(n, \"int\".length);\n              if (t % 8 || t < 8 || t > 256) throw new i.InvalidSizeError(e);\n              const o = (0, a.toNumber)(r);\n              if (l(o) > t) throw new i.InvalidLargeValueError(r);\n              return o < BigInt(0) ? (0, c.toTwosComplement)(o.toString(), t / 8 * 2) : t ? (0, c.leftPad)(o.toString(16), t / 4) : o.toString(16);\n            }\n            if (\"bytes\" === n) {\n              if (r.replace(/^0x/i, \"\").length % 2 != 0) throw new i.InvalidBytesError(r);\n              return r;\n            }\n            if (e.startsWith(\"bytes\")) {\n              if (r.replace(/^0x/i, \"\").length % 2 != 0) throw new i.InvalidBytesError(r);\n              const t = d(e, \"bytes\".length);\n              if (!t || t < 1 || t > 64 || t < r.replace(/^0x/i, \"\").length / 2) throw new i.InvalidBytesError(r);\n              return (0, c.rightPad)(r, 2 * t);\n            }\n            return \"\";\n          };\n        t.processSolidityEncodePackedArgs = e => {\n          const [t, r] = (e => {\n            if (Array.isArray(e)) throw new Error(\"Autodetection of array types is not supported.\");\n            let t, r;\n            if (\"object\" == typeof e && (\"t\" in e || \"type\" in e) && (\"v\" in e || \"value\" in e)) t = \"t\" in e ? e.t : e.type, r = \"v\" in e ? e.v : e.value, t = \"bigint\" === t.toLowerCase() ? \"int\" : t;else {\n              if (\"bigint\" == typeof e) return [\"int\", e];\n              t = (0, a.toHex)(e, !0), r = (0, a.toHex)(e), t.startsWith(\"int\") || t.startsWith(\"uint\") || (t = \"bytes\");\n            }\n            return !t.startsWith(\"int\") && !t.startsWith(\"uint\") || \"string\" != typeof r || /^(-)?0x/i.test(r) || (r = (0, a.toBigInt)(r)), [t, r];\n          })(e);\n          return Array.isArray(r) ? r.map(e => h(t, e).replace(\"0x\", \"\")).join(\"\") : h(t, r).replace(\"0x\", \"\");\n        }, t.encodePacked = (...e) => `0x${e.map(t.processSolidityEncodePackedArgs).join(\"\").toLowerCase()}`, t.soliditySha3 = (...e) => (0, t.sha3)((0, t.encodePacked)(...e)), t.soliditySha3Raw = (...e) => (0, t.sha3Raw)((0, t.encodePacked)(...e)), t.getStorageSlotNumForLongString = e => (0, t.sha3)(`0x${(\"number\" == typeof e ? e.toString() : e).padStart(64, \"0\")}`);\n      },\n      9634: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          i = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          },\n          s = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return o(t, e), t;\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.jsonRpc = void 0, i(r(7086), t), i(r(8512), t), i(r(4578), t), i(r(3065), t), i(r(3561), t), i(r(4822), t), i(r(2557), t), i(r(7151), t), i(r(3718), t), i(r(9250), t), t.jsonRpc = s(r(9250)), i(r(6982), t), i(r(4108), t), i(r(7717), t), i(r(997), t), i(r(222), t), i(r(7541), t);\n      },\n      9250: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isBatchRequest = t.toBatchPayload = t.toPayload = t.setRequestIdStart = t.isBatchResponse = t.isValidResponse = t.validateResponse = t.isSubscriptionResult = t.isResponseWithNotification = t.isResponseWithError = t.isResponseWithResult = t.isResponseRpcError = void 0;\n        const n = r(7345),\n          o = r(5071),\n          i = r(7717);\n        let s;\n        t.isResponseRpcError = e => {\n          const t = e.error.code;\n          return o.rpcErrorsMap.has(t) || t >= -32099 && t <= -32e3;\n        }, t.isResponseWithResult = e => !Array.isArray(e) && !!e && \"2.0\" === e.jsonrpc && \"result\" in e && (0, n.isNullish)(e.error) && (\"number\" == typeof e.id || \"string\" == typeof e.id), t.isResponseWithError = e => !Array.isArray(e) && \"2.0\" === e.jsonrpc && !!e && (0, n.isNullish)(e.result) && \"error\" in e && (\"number\" == typeof e.id || \"string\" == typeof e.id), t.isResponseWithNotification = e => !(Array.isArray(e) || !e || \"2.0\" !== e.jsonrpc || (0, n.isNullish)(e.params) || (0, n.isNullish)(e.method)), t.isSubscriptionResult = e => !Array.isArray(e) && !!e && \"2.0\" === e.jsonrpc && \"id\" in e && \"result\" in e, t.validateResponse = e => (0, t.isResponseWithResult)(e) || (0, t.isResponseWithError)(e), t.isValidResponse = e => Array.isArray(e) ? e.every(t.validateResponse) : (0, t.validateResponse)(e), t.isBatchResponse = e => Array.isArray(e) && e.length > 0 && (0, t.isValidResponse)(e), t.setRequestIdStart = e => {\n          s = e;\n        }, t.toPayload = e => {\n          var t, r, n, o;\n          return void 0 !== s && (s += 1), {\n            jsonrpc: null !== (t = e.jsonrpc) && void 0 !== t ? t : \"2.0\",\n            id: null !== (n = null !== (r = e.id) && void 0 !== r ? r : s) && void 0 !== n ? n : (0, i.uuidV4)(),\n            method: e.method,\n            params: null !== (o = e.params) && void 0 !== o ? o : void 0\n          };\n        }, t.toBatchPayload = e => e.map(e => (0, t.toPayload)(e)), t.isBatchRequest = e => Array.isArray(e) && e.length > 0;\n      },\n      7151: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.mergeDeep = void 0;\n        const n = r(9970),\n          o = r(7345),\n          i = e => !(\"object\" != typeof e || (0, o.isNullish)(e) || Array.isArray(e) || e instanceof n.TypedArray);\n        t.mergeDeep = (e, ...r) => {\n          if (!i(e)) return e;\n          const s = Object.assign({}, e);\n          for (const e of r) for (const r in e) i(e[r]) ? (s[r] || (s[r] = {}), s[r] = (0, t.mergeDeep)(s[r], e[r])) : !(0, o.isNullish)(e[r]) && Object.hasOwnProperty.call(e, r) && (Array.isArray(e[r]) || e[r] instanceof n.TypedArray ? s[r] = e[r].slice(0) : s[r] = e[r]);\n          return s;\n        };\n      },\n      3718: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.rejectIfConditionAtInterval = t.rejectIfTimeout = t.pollTillDefined = t.pollTillDefinedAndReturnIntervalId = t.waitWithTimeout = t.isPromise = void 0;\n        const o = r(7345);\n        function i(e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            let n;\n            const o = yield Promise.race([e instanceof Promise ? e : e(), new Promise((e, o) => {\n              n = setTimeout(() => r ? o(r) : e(void 0), t);\n            })]);\n            if (n && clearTimeout(n), o instanceof Error) throw o;\n            return o;\n          });\n        }\n        function s(e, t) {\n          let r;\n          return [new Promise((s, a) => {\n            r = setInterval(function c() {\n              return (() => {\n                n(this, void 0, void 0, function* () {\n                  try {\n                    const n = yield i(e, t);\n                    (0, o.isNullish)(n) || (clearInterval(r), s(n));\n                  } catch (e) {\n                    clearInterval(r), a(e);\n                  }\n                });\n              })(), c;\n            }(), t);\n          }), r];\n        }\n        t.isPromise = function (e) {\n          return (\"object\" == typeof e || \"function\" == typeof e) && \"function\" == typeof e.then;\n        }, t.waitWithTimeout = i, t.pollTillDefinedAndReturnIntervalId = s, t.pollTillDefined = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return s(e, t)[0];\n          });\n        }, t.rejectIfTimeout = function (e, t) {\n          let r;\n          const n = new Promise((n, o) => {\n            r = setTimeout(() => {\n              o(t);\n            }, e);\n          });\n          return [r, n];\n        }, t.rejectIfConditionAtInterval = function (e, t) {\n          let r;\n          const o = new Promise((o, i) => {\n            r = setInterval(() => {\n              (() => {\n                n(this, void 0, void 0, function* () {\n                  const t = yield e();\n                  t && (clearInterval(r), i(t));\n                });\n              })();\n            }, t);\n          });\n          return [r, o];\n        };\n      },\n      4822: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.randomHex = t.randomBytes = void 0;\n        const n = r(1341),\n          o = r(7086);\n        t.randomBytes = e => (0, n.getRandomBytesSync)(e), t.randomHex = e => (0, o.bytesToHex)((0, t.randomBytes)(e));\n      },\n      222: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          i = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return o(t, e), t;\n          },\n          s = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (o, i) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SocketProvider = void 0;\n        const a = r(5071),\n          c = r(997),\n          u = r(4108),\n          d = r(4578),\n          l = r(6982),\n          h = i(r(9250)),\n          f = {\n            autoReconnect: !0,\n            delay: 5e3,\n            maxAttempts: 5\n          };\n        class p extends c.Eip1193Provider {\n          constructor(e, t, r) {\n            if (super(), this._connectionStatus = \"connecting\", this._onMessageHandler = this._onMessage.bind(this), this._onOpenHandler = this._onConnect.bind(this), this._onCloseHandler = this._onCloseEvent.bind(this), this._onErrorHandler = this._onError.bind(this), !this._validateProviderPath(e)) throw new a.InvalidClientError(e);\n            this._socketPath = e, this._socketOptions = t, this._reconnectOptions = Object.assign(Object.assign({}, f), null != r ? r : {}), this._pendingRequestsQueue = new Map(), this._sentRequestsQueue = new Map(), this._init(), this.connect(), this.chunkResponseParser = new u.ChunkResponseParser(this._eventEmitter, this._reconnectOptions.autoReconnect), this.chunkResponseParser.onError(() => {\n              this._clearQueues();\n            }), this.isReconnecting = !1;\n          }\n          get SocketConnection() {\n            return this._socketConnection;\n          }\n          _init() {\n            this._reconnectAttempts = 0;\n          }\n          connect() {\n            try {\n              this._openSocketConnection(), this._connectionStatus = \"connecting\", this._addSocketListeners();\n            } catch (e) {\n              if (!this.isReconnecting) throw this._connectionStatus = \"disconnected\", e && e.message ? new a.ConnectionError(`Error while connecting to ${this._socketPath}. Reason: ${e.message}`) : new a.InvalidClientError(this._socketPath);\n              setImmediate(() => {\n                this._reconnect();\n              });\n            }\n          }\n          _validateProviderPath(e) {\n            return !!e;\n          }\n          getPendingRequestQueueSize() {\n            return this._pendingRequestsQueue.size;\n          }\n          getSentRequestsQueueSize() {\n            return this._sentRequestsQueue.size;\n          }\n          supportsSubscriptions() {\n            return !0;\n          }\n          on(e, t) {\n            this._eventEmitter.on(e, t);\n          }\n          once(e, t) {\n            this._eventEmitter.once(e, t);\n          }\n          removeListener(e, t) {\n            this._eventEmitter.removeListener(e, t);\n          }\n          _onDisconnect(e, t) {\n            this._connectionStatus = \"disconnected\", super._onDisconnect(e, t);\n          }\n          disconnect(e, t) {\n            const r = null != e ? e : 1e3;\n            this._removeSocketListeners(), \"disconnected\" !== this.getStatus() && this._closeSocketConnection(r, t), this._onDisconnect(r, t);\n          }\n          safeDisconnect(e, t, r = !1, n = 1e3) {\n            return s(this, void 0, void 0, function* () {\n              let o = 0;\n              yield (() => s(this, void 0, void 0, function* () {\n                return new Promise(e => {\n                  const t = setInterval(() => {\n                    r && o >= 5 && this.clearQueues(), 0 === this.getPendingRequestQueueSize() && 0 === this.getSentRequestsQueueSize() && (clearInterval(t), e(!0)), o += 1;\n                  }, n);\n                });\n              }))(), this.disconnect(e, t);\n            });\n          }\n          removeAllListeners(e) {\n            this._eventEmitter.removeAllListeners(e);\n          }\n          _onError(e) {\n            this.isReconnecting ? this._reconnect() : this._eventEmitter.emit(\"error\", e);\n          }\n          reset() {\n            this._sentRequestsQueue.clear(), this._pendingRequestsQueue.clear(), this._init(), this._removeSocketListeners(), this._addSocketListeners();\n          }\n          _reconnect() {\n            this.isReconnecting || (this.isReconnecting = !0, this._sentRequestsQueue.size > 0 && this._sentRequestsQueue.forEach((e, t) => {\n              e.deferredPromise.reject(new a.PendingRequestsOnReconnectingError()), this._sentRequestsQueue.delete(t);\n            }), this._reconnectAttempts < this._reconnectOptions.maxAttempts ? (this._reconnectAttempts += 1, setTimeout(() => {\n              this._removeSocketListeners(), this.connect(), this.isReconnecting = !1;\n            }, this._reconnectOptions.delay)) : (this.isReconnecting = !1, this._clearQueues(), this._removeSocketListeners(), this._eventEmitter.emit(\"error\", new a.MaxAttemptsReachedOnReconnectingError(this._reconnectOptions.maxAttempts))));\n          }\n          request(e) {\n            return s(this, void 0, void 0, function* () {\n              if ((0, d.isNullish)(this._socketConnection)) throw new Error(\"Connection is undefined\");\n              \"disconnected\" === this.getStatus() && this.connect();\n              const t = h.isBatchRequest(e) ? e[0].id : e.id;\n              if (!t) throw new a.Web3WSProviderError(\"Request Id not defined\");\n              if (this._sentRequestsQueue.has(t)) throw new a.RequestAlreadySentError(t);\n              const r = new l.Web3DeferredPromise();\n              r.catch(e => {\n                this._eventEmitter.emit(\"error\", e);\n              });\n              const n = {\n                payload: e,\n                deferredPromise: r\n              };\n              if (\"connecting\" === this.getStatus()) return this._pendingRequestsQueue.set(t, n), n.deferredPromise;\n              this._sentRequestsQueue.set(t, n);\n              try {\n                this._sendToSocket(n.payload);\n              } catch (e) {\n                this._sentRequestsQueue.delete(t), this._eventEmitter.emit(\"error\", e);\n              }\n              return r;\n            });\n          }\n          _onConnect() {\n            this._connectionStatus = \"connected\", this._reconnectAttempts = 0, super._onConnect(), this._sendPendingRequests();\n          }\n          _sendPendingRequests() {\n            for (const [e, t] of this._pendingRequestsQueue.entries()) this._sendToSocket(t.payload), this._pendingRequestsQueue.delete(e), this._sentRequestsQueue.set(e, t);\n          }\n          _onMessage(e) {\n            const t = this._parseResponses(e);\n            if (!(0, d.isNullish)(t) && 0 !== t.length) for (const e of t) {\n              if (h.isResponseWithNotification(e) && e.method.endsWith(\"_subscription\")) return void this._eventEmitter.emit(\"message\", e);\n              const t = h.isBatchResponse(e) ? e[0].id : e.id,\n                r = this._sentRequestsQueue.get(t);\n              if (!r) return;\n              (h.isBatchResponse(e) || h.isResponseWithResult(e) || h.isResponseWithError(e)) && (this._eventEmitter.emit(\"message\", e), r.deferredPromise.resolve(e)), this._sentRequestsQueue.delete(t);\n            }\n          }\n          clearQueues(e) {\n            this._clearQueues(e);\n          }\n          _clearQueues(e) {\n            this._pendingRequestsQueue.size > 0 && this._pendingRequestsQueue.forEach((t, r) => {\n              t.deferredPromise.reject(new a.ConnectionNotOpenError(e)), this._pendingRequestsQueue.delete(r);\n            }), this._sentRequestsQueue.size > 0 && this._sentRequestsQueue.forEach((t, r) => {\n              t.deferredPromise.reject(new a.ConnectionNotOpenError(e)), this._sentRequestsQueue.delete(r);\n            }), this._removeSocketListeners();\n          }\n        }\n        t.SocketProvider = p;\n      },\n      2557: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.fromTwosComplement = t.toTwosComplement = t.leftPad = t.rightPad = t.padRight = t.padLeft = void 0;\n        const n = r(5071),\n          o = r(7345),\n          i = r(7086);\n        t.padLeft = (e, t, r = \"0\") => \"string\" == typeof e ? (0, o.isHexStrict)(e) ? o.utils.padLeft(e, t, r) : e.padStart(t, r) : (o.validator.validate([\"int\"], [e]), o.utils.padLeft(e, t, r)), t.padRight = (e, t, r = \"0\") => {\n          if (\"string\" == typeof e && !(0, o.isHexStrict)(e)) return e.padEnd(t, r);\n          o.validator.validate([\"int\"], [e]);\n          const n = \"string\" == typeof e && (0, o.isHexStrict)(e) ? e : (0, i.numberToHex)(e),\n            s = n.startsWith(\"-\") ? 3 : 2;\n          return n.padEnd(t + s, r);\n        }, t.rightPad = t.padRight, t.leftPad = t.padLeft, t.toTwosComplement = (e, r = 64) => {\n          o.validator.validate([\"int\"], [e]);\n          const s = (0, i.toNumber)(e);\n          if (s >= 0) return (0, t.padLeft)((0, i.toHex)(s), r);\n          const a = (0, o.bigintPower)(BigInt(2), BigInt(4 * r));\n          if (-s >= a) throw new n.NibbleWidthError(`value: ${e}, nibbleWidth: ${r}`);\n          const c = BigInt(s) + a;\n          return (0, t.padLeft)((0, i.numberToHex)(c), r);\n        }, t.fromTwosComplement = (e, t = 64) => {\n          o.validator.validate([\"int\"], [e]);\n          const r = (0, i.toNumber)(e);\n          if (r < 0) return r;\n          const s = Math.ceil(Math.log(Number(r)) / Math.log(2));\n          if (s > 4 * t) throw new n.NibbleWidthError(`value: \"${e}\", nibbleWidth: \"${t}\"`);\n          if (4 * t !== s) return r;\n          const a = (0, o.bigintPower)(BigInt(2), BigInt(t) * BigInt(4));\n          return (0, i.toNumber)(BigInt(r) - a);\n        };\n      },\n      7541: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.uint8ArrayEquals = t.uint8ArrayConcat = t.isUint8Array = void 0, t.isUint8Array = function (e) {\n          var t, r;\n          return e instanceof Uint8Array || \"Uint8Array\" === (null === (t = null == e ? void 0 : e.constructor) || void 0 === t ? void 0 : t.name) || \"Buffer\" === (null === (r = null == e ? void 0 : e.constructor) || void 0 === r ? void 0 : r.name);\n        }, t.uint8ArrayConcat = function (...e) {\n          const t = e.reduce((e, t) => e + t.length, 0),\n            r = new Uint8Array(t);\n          let n = 0;\n          for (const t of e) r.set(t, n), n += t.length;\n          return r;\n        }, t.uint8ArrayEquals = function (e, t) {\n          if (e === t) return !0;\n          if (e.byteLength !== t.byteLength) return !1;\n          for (let r = 0; r < e.byteLength; r += 1) if (e[r] !== t[r]) return !1;\n          return !0;\n        };\n      },\n      7717: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.uuidV4 = void 0;\n        const n = r(7086),\n          o = r(4822);\n        t.uuidV4 = () => {\n          const e = (0, o.randomBytes)(16);\n          e[6] = 15 & e[6] | 64, e[8] = 63 & e[8] | 128;\n          const t = (0, n.bytesToHex)(e);\n          return [t.substring(2, 10), t.substring(10, 14), t.substring(14, 18), t.substring(18, 22), t.substring(22, 34)].join(\"-\");\n        };\n      },\n      4578: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isNullish = t.isContractInitOptions = t.compareBlockNumbers = t.isTopicInBloom = t.isTopic = t.isContractAddressInBloom = t.isUserEthereumAddressInBloom = t.isInBloom = t.isBloom = t.isAddress = t.checkAddressCheckSum = t.isHex = t.isHexStrict = void 0;\n        const n = r(5071),\n          o = r(7345),\n          i = r(9970);\n        t.isHexStrict = o.isHexStrict, t.isHex = o.isHex, t.checkAddressCheckSum = o.checkAddressCheckSum, t.isAddress = o.isAddress, t.isBloom = o.isBloom, t.isInBloom = o.isInBloom, t.isUserEthereumAddressInBloom = o.isUserEthereumAddressInBloom, t.isContractAddressInBloom = o.isContractAddressInBloom, t.isTopic = o.isTopic, t.isTopicInBloom = o.isTopicInBloom, t.compareBlockNumbers = (e, t) => {\n          const r = \"string\" == typeof e && (0, o.isBlockTag)(e),\n            s = \"string\" == typeof t && (0, o.isBlockTag)(t);\n          if (e === t || (\"earliest\" === e || 0 === e) && (\"earliest\" === t || 0 === t)) return 0;\n          if (\"earliest\" === e && t > 0) return -1;\n          if (\"earliest\" === t && e > 0) return 1;\n          if (r && s) {\n            const r = {\n              [i.BlockTags.EARLIEST]: 1,\n              [i.BlockTags.FINALIZED]: 2,\n              [i.BlockTags.SAFE]: 3,\n              [i.BlockTags.LATEST]: 4,\n              [i.BlockTags.PENDING]: 5\n            };\n            return r[e] < r[t] ? -1 : 1;\n          }\n          if (r && !s || !r && s) throw new n.InvalidBlockError(\"Cannot compare blocktag with provided non-blocktag input.\");\n          const a = BigInt(e),\n            c = BigInt(t);\n          return a < c ? -1 : a === c ? 0 : 1;\n        }, t.isContractInitOptions = e => \"object\" == typeof e && !(0, o.isNullish)(e) && 0 !== Object.keys(e).length && [\"input\", \"data\", \"from\", \"gas\", \"gasPrice\", \"gasLimit\", \"address\", \"jsonInterface\", \"syncWithContext\", \"dataInputFill\"].some(t => t in e), t.isNullish = o.isNullish;\n      },\n      6982: function (e, t, r) {\n        \"use strict\";\n\n        var n,\n          o = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (o, i) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3DeferredPromise = void 0;\n        const i = r(5071);\n        t.Web3DeferredPromise = class {\n          constructor({\n            timeout: e,\n            eagerStart: t,\n            timeoutMessage: r\n          } = {\n            timeout: 0,\n            eagerStart: !1,\n            timeoutMessage: \"DeferredPromise timed out\"\n          }) {\n            this[n] = \"Promise\", this._state = \"pending\", this._promise = new Promise((e, t) => {\n              this._resolve = e, this._reject = t;\n            }), this._timeoutMessage = r, this._timeoutInterval = e, t && this.startTimer();\n          }\n          get state() {\n            return this._state;\n          }\n          then(e, t) {\n            return o(this, void 0, void 0, function* () {\n              return this._promise.then(e, t);\n            });\n          }\n          catch(e) {\n            return o(this, void 0, void 0, function* () {\n              return this._promise.catch(e);\n            });\n          }\n          finally(e) {\n            return o(this, void 0, void 0, function* () {\n              return this._promise.finally(e);\n            });\n          }\n          resolve(e) {\n            this._resolve(e), this._state = \"fulfilled\", this._clearTimeout();\n          }\n          reject(e) {\n            this._reject(e), this._state = \"rejected\", this._clearTimeout();\n          }\n          startTimer() {\n            this._timeoutInterval && this._timeoutInterval > 0 && (this._timeoutId = setTimeout(this._checkTimeout.bind(this), this._timeoutInterval));\n          }\n          _checkTimeout() {\n            \"pending\" === this._state && this._timeoutId && this.reject(new i.OperationTimeoutError(this._timeoutMessage));\n          }\n          _clearTimeout() {\n            this._timeoutId && clearTimeout(this._timeoutId);\n          }\n        }, n = Symbol.toStringTag;\n      },\n      997: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (o, i) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                i(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Eip1193Provider = void 0;\n        const o = r(9970),\n          i = r(9386),\n          s = r(5071),\n          a = r(9250);\n        class c extends o.Web3BaseProvider {\n          constructor() {\n            super(...arguments), this._eventEmitter = new i.EventEmitter(), this._chainId = \"\", this._accounts = [];\n          }\n          _getChainId() {\n            var e;\n            return n(this, void 0, void 0, function* () {\n              const t = yield this.request((0, a.toPayload)({\n                method: \"eth_chainId\",\n                params: []\n              }));\n              return null !== (e = null == t ? void 0 : t.result) && void 0 !== e ? e : \"\";\n            });\n          }\n          _getAccounts() {\n            var e;\n            return n(this, void 0, void 0, function* () {\n              const t = yield this.request((0, a.toPayload)({\n                method: \"eth_accounts\",\n                params: []\n              }));\n              return null !== (e = null == t ? void 0 : t.result) && void 0 !== e ? e : [];\n            });\n          }\n          _onConnect() {\n            Promise.all([this._getChainId().then(e => {\n              e !== this._chainId && (this._chainId = e, this._eventEmitter.emit(\"chainChanged\", this._chainId));\n            }).catch(e => {\n              console.error(e);\n            }), this._getAccounts().then(e => {\n              this._accounts.length === e.length && e.every(t => e.includes(t)) || (this._accounts = e, this._onAccountsChanged());\n            }).catch(e => {\n              console.error(e);\n            })]).then(() => this._eventEmitter.emit(\"connect\", {\n              chainId: this._chainId\n            })).catch(e => {\n              console.error(e);\n            });\n          }\n          _onDisconnect(e, t) {\n            this._eventEmitter.emit(\"disconnect\", new s.EIP1193ProviderRpcError(e, t));\n          }\n          _onAccountsChanged() {\n            this._eventEmitter.emit(\"accountsChanged\", this._accounts);\n          }\n        }\n        t.Eip1193Provider = c;\n      },\n      1438: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.VALID_ETH_BASE_TYPES = void 0, t.VALID_ETH_BASE_TYPES = [\"bool\", \"int\", \"uint\", \"bytes\", \"string\", \"address\", \"tuple\"];\n      },\n      3637: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.validator = void 0;\n        const n = r(7985);\n        t.validator = new n.Web3Validator();\n      },\n      356: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3ValidatorError = void 0;\n        const n = r(5071),\n          o = e => e.message ? e.message : \"unspecified error\";\n        class i extends n.BaseWeb3Error {\n          constructor(e) {\n            super(), this.code = n.ERR_VALIDATION, this.errors = e, super.message = `Web3 validator found ${e.length} error[s]:\\n${this._compileErrors().join(\"\\n\")}`;\n          }\n          _compileErrors() {\n            return this.errors.map(o);\n          }\n        }\n        t.Web3ValidatorError = i;\n      },\n      2677: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n        const n = r(2681),\n          o = r(6660),\n          i = r(5191),\n          s = r(4416),\n          a = r(3921),\n          c = r(5164),\n          u = r(7420),\n          d = r(6378),\n          l = {\n            address: e => (0, n.isAddress)(e),\n            bloom: e => (0, i.isBloom)(e),\n            blockNumber: e => (0, o.isBlockNumber)(e),\n            blockTag: e => (0, o.isBlockTag)(e),\n            blockNumberOrTag: e => (0, o.isBlockNumberOrTag)(e),\n            bool: e => (0, s.isBoolean)(e),\n            bytes: e => (0, a.isBytes)(e),\n            filter: e => (0, c.isFilterObject)(e),\n            hex: e => (0, u.isHexStrict)(e),\n            uint: e => (0, d.isUInt)(e),\n            int: e => (0, d.isInt)(e),\n            number: e => (0, d.isNumber)(e),\n            string: e => (0, u.isString)(e)\n          };\n        for (let e = 8; e <= 256; e += 8) l[`int${e}`] = t => (0, d.isInt)(t, {\n          bitSize: e\n        }), l[`uint${e}`] = t => (0, d.isUInt)(t, {\n          bitSize: e\n        });\n        for (let e = 1; e <= 32; e += 1) l[`bytes${e}`] = t => (0, a.isBytes)(t, {\n          size: e\n        });\n        l.bytes256 = l.bytes, t.default = l;\n      },\n      7345: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          i = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          },\n          s = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return o(t, e), t;\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.utils = void 0, i(r(7985), t), i(r(3637), t), i(r(5421), t), t.utils = s(r(8171)), i(r(356), t), i(r(1438), t), i(r(1851), t);\n      },\n      5421: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      8171: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ensureIfUint8Array = t.hexToUint8Array = t.uint8ArrayToHexString = t.padLeft = t.numberToHex = t.hexToNumber = t.codePointToInt = t.transformJsonDataToAbiFormat = t.fetchArrayElement = t.ethAbiToJsonSchema = t.abiSchemaToJsonSchema = t.parseBaseType = void 0;\n        const n = r(5071),\n          o = r(1438),\n          i = r(1283),\n          s = r(7420),\n          a = r(356),\n          c = [\"hex\", \"number\", \"blockNumber\", \"blockNumberOrTag\", \"filter\", \"bloom\"];\n        t.parseBaseType = e => {\n          let t,\n            r = e.replace(/ /, \"\"),\n            n = !1,\n            i = [];\n          if (e.includes(\"[\") && (r = r.slice(0, r.indexOf(\"[\")), i = [...e.matchAll(/(?:\\[(\\d*)\\])/g)].map(e => parseInt(e[1], 10)).map(e => Number.isNaN(e) ? -1 : e), n = i.length > 0), o.VALID_ETH_BASE_TYPES.includes(r)) return {\n            baseType: r,\n            isArray: n,\n            baseTypeSize: t,\n            arraySizes: i\n          };\n          if (r.startsWith(\"int\")) t = parseInt(r.substring(3), 10), r = \"int\";else if (r.startsWith(\"uint\")) t = parseInt(e.substring(4), 10), r = \"uint\";else {\n            if (!r.startsWith(\"bytes\")) return {\n              baseType: void 0,\n              isArray: !1,\n              baseTypeSize: void 0,\n              arraySizes: i\n            };\n            t = parseInt(r.substring(5), 10), r = \"bytes\";\n          }\n          return {\n            baseType: r,\n            isArray: n,\n            baseTypeSize: t,\n            arraySizes: i\n          };\n        };\n        const u = (e, r = {}) => {\n          if (Object.keys(r).includes(\"type\")) throw new a.Web3ValidatorError([{\n            keyword: \"eth\",\n            message: 'Either \"eth\" or \"type\" can be presented in schema',\n            params: {\n              eth: e\n            },\n            instancePath: \"\",\n            schemaPath: \"\"\n          }]);\n          const {\n            baseType: n,\n            baseTypeSize: o\n          } = (0, t.parseBaseType)(e);\n          if (!n && !c.includes(e)) throw new a.Web3ValidatorError([{\n            keyword: \"eth\",\n            message: `Eth data type \"${e}\" is not valid`,\n            params: {\n              eth: e\n            },\n            instancePath: \"\",\n            schemaPath: \"\"\n          }]);\n          if (n) {\n            if (\"tuple\" === n) throw new Error('\"tuple\" type is not implemented directly.');\n            return {\n              format: `${n}${null != o ? o : \"\"}`,\n              required: !0\n            };\n          }\n          return e ? {\n            format: e,\n            required: !0\n          } : {};\n        };\n        t.abiSchemaToJsonSchema = (e, r = \"/0\") => {\n          const n = {\n            type: \"array\",\n            items: [],\n            maxItems: e.length,\n            minItems: e.length\n          };\n          for (const [o, s] of e.entries()) {\n            let e,\n              a,\n              c = [];\n            (0, i.isAbiParameterSchema)(s) ? (e = s.type, a = s.name || `${r}/${o}`, c = s.components) : \"string\" == typeof s ? (e = s, a = `${r}/${o}`) : Array.isArray(s) && (s[0] && \"string\" == typeof s[0] && s[0].startsWith(\"tuple\") && !Array.isArray(s[0]) && s[1] && Array.isArray(s[1]) ? (e = s[0], a = `${r}/${o}`, c = s[1]) : (e = \"tuple\", a = `${r}/${o}`, c = s));\n            const {\n              baseType: d,\n              isArray: l,\n              arraySizes: h\n            } = (0, t.parseBaseType)(e);\n            let f,\n              p = n;\n            for (let e = h.length - 1; e > 0; e -= 1) f = {\n              type: \"array\",\n              $id: a,\n              items: [],\n              maxItems: h[e],\n              minItems: h[e]\n            }, h[e] < 0 && (delete f.maxItems, delete f.minItems), Array.isArray(p.items) ? 0 === p.items.length ? p.items = [f] : p.items.push(f) : p.items = [p.items, f], p = f;\n            if (\"tuple\" !== d || l) {\n              if (\"tuple\" === d && l) {\n                const e = h[0],\n                  r = Object.assign({\n                    type: \"array\",\n                    $id: a,\n                    items: (0, t.abiSchemaToJsonSchema)(c, a)\n                  }, e >= 0 && {\n                    minItems: e,\n                    maxItems: e\n                  });\n                p.items.push(r);\n              } else if (l) {\n                const t = h[0],\n                  r = Object.assign({\n                    type: \"array\",\n                    $id: a,\n                    items: u(e)\n                  }, t >= 0 && {\n                    minItems: t,\n                    maxItems: t\n                  });\n                p.items.push(r);\n              } else Array.isArray(p.items), p.items.push(Object.assign({\n                $id: a\n              }, u(e)));\n            } else {\n              const e = (0, t.abiSchemaToJsonSchema)(c, a);\n              e.$id = a, p.items.push(e);\n            }\n            p = n;\n          }\n          return n;\n        }, t.ethAbiToJsonSchema = e => (0, t.abiSchemaToJsonSchema)(e), t.fetchArrayElement = (e, r) => 1 === r ? e : (0, t.fetchArrayElement)(e[0], r - 1), t.transformJsonDataToAbiFormat = (e, r, n) => {\n          const o = [];\n          for (const [s, a] of e.entries()) {\n            let e,\n              c,\n              u = [];\n            (0, i.isAbiParameterSchema)(a) ? (e = a.type, c = a.name, u = a.components) : \"string\" == typeof a ? e = a : Array.isArray(a) && (a[1] && Array.isArray(a[1]) ? (e = a[0], u = a[1]) : (e = \"tuple\", u = a));\n            const {\n                baseType: d,\n                isArray: l,\n                arraySizes: h\n              } = (0, t.parseBaseType)(e),\n              f = Array.isArray(r) ? r[s] : r[c];\n            if (\"tuple\" !== d || l) {\n              if (\"tuple\" === d && l) {\n                const e = [];\n                for (const r of f) if (h.length > 1) {\n                  const o = (0, t.fetchArrayElement)(r, h.length - 1),\n                    i = [];\n                  for (const e of o) i.push((0, t.transformJsonDataToAbiFormat)(u, e, n));\n                  e.push(i);\n                } else e.push((0, t.transformJsonDataToAbiFormat)(u, r, n));\n                o.push(e);\n              } else o.push(f);\n            } else o.push((0, t.transformJsonDataToAbiFormat)(u, f, n));\n          }\n          return (n = null != n ? n : []).push(...o), n;\n        }, t.codePointToInt = e => {\n          if (e >= 48 && e <= 57) return e - 48;\n          if (e >= 65 && e <= 70) return e - 55;\n          if (e >= 97 && e <= 102) return e - 87;\n          throw new Error(`Invalid code point: ${e}`);\n        }, t.hexToNumber = e => {\n          if (!(0, s.isHexStrict)(e)) throw new Error(\"Invalid hex string\");\n          const [t, r] = e.startsWith(\"-\") ? [!0, e.slice(1)] : [!1, e],\n            n = BigInt(r);\n          return n > Number.MAX_SAFE_INTEGER ? t ? -n : n : n < Number.MIN_SAFE_INTEGER ? n : t ? -1 * Number(n) : Number(n);\n        }, t.numberToHex = e => {\n          if ((\"number\" == typeof e || \"bigint\" == typeof e) && e < 0) return `-0x${e.toString(16).slice(1)}`;\n          if ((\"number\" == typeof e || \"bigint\" == typeof e) && e >= 0) return `0x${e.toString(16)}`;\n          if (\"string\" == typeof e && (0, s.isHexStrict)(e)) {\n            const [t, r] = e.startsWith(\"-\") ? [!0, e.slice(1)] : [!1, e];\n            return `${t ? \"-\" : \"\"}0x${r.split(/^(-)?0(x|X)/).slice(-1)[0].replace(/^0+/, \"\").toLowerCase()}`;\n          }\n          if (\"string\" == typeof e && !(0, s.isHexStrict)(e)) return (0, t.numberToHex)(BigInt(e));\n          throw new n.InvalidNumberError(e);\n        }, t.padLeft = (e, r, n = \"0\") => {\n          if (\"string\" == typeof e && !(0, s.isHexStrict)(e)) return e.padStart(r, n);\n          const o = \"string\" == typeof e && (0, s.isHexStrict)(e) ? e : (0, t.numberToHex)(e),\n            [i, a] = o.startsWith(\"-\") ? [\"-0x\", o.slice(3)] : [\"0x\", o.slice(2)];\n          return `${i}${a.padStart(r, n)}`;\n        }, t.uint8ArrayToHexString = function (e) {\n          let t = \"0x\";\n          for (const r of e) {\n            const e = r.toString(16);\n            t += 1 === e.length ? `0${e}` : e;\n          }\n          return t;\n        };\n        function d(e) {\n          return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : void 0;\n        }\n        t.hexToUint8Array = function (e) {\n          let t = 0;\n          if (!e.startsWith(\"0\") || \"x\" !== e[1] && \"X\" !== e[1] || (t = 2), e.length % 2 != 0) throw new n.InvalidBytesError(`hex string has odd length: ${e}`);\n          const r = (e.length - t) / 2,\n            o = new Uint8Array(r);\n          for (let i = 0, s = t; i < r; i += 1) {\n            const t = d(e.charCodeAt(s++)),\n              r = d(e.charCodeAt(s++));\n            if (void 0 === t || void 0 === r) throw new n.InvalidBytesError(`Invalid byte sequence (\"${e[s - 2]}${e[s - 1]}\" in \"${e}\").`);\n            o[i] = 16 * t + r;\n          }\n          return o;\n        }, t.ensureIfUint8Array = function (e) {\n          var t;\n          return e instanceof Uint8Array || \"Uint8Array\" !== (null === (t = null == e ? void 0 : e.constructor) || void 0 === t ? void 0 : t.name) ? e : Uint8Array.from(e);\n        };\n      },\n      1283: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isAbiParameterSchema = void 0, t.isAbiParameterSchema = e => \"object\" == typeof e && \"type\" in e && \"name\" in e;\n      },\n      2681: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isAddress = t.checkAddressCheckSum = void 0;\n        const n = r(4488),\n          o = r(7737),\n          i = r(8171),\n          s = r(7420),\n          a = r(3921);\n        t.checkAddressCheckSum = e => {\n          if (!/^(0x)?[0-9a-f]{40}$/i.test(e)) return !1;\n          const t = e.slice(2),\n            r = (0, o.utf8ToBytes)(t.toLowerCase()),\n            s = (0, i.uint8ArrayToHexString)((0, n.keccak256)((0, i.ensureIfUint8Array)(r))).slice(2);\n          for (let e = 0; e < 40; e += 1) if (parseInt(s[e], 16) > 7 && t[e].toUpperCase() !== t[e] || parseInt(s[e], 16) <= 7 && t[e].toLowerCase() !== t[e]) return !1;\n          return !0;\n        }, t.isAddress = (e, r = !0) => {\n          if (\"string\" != typeof e && !(0, a.isUint8Array)(e)) return !1;\n          let n;\n          return n = (0, a.isUint8Array)(e) ? (0, i.uint8ArrayToHexString)(e) : \"string\" != typeof e || (0, s.isHexStrict)(e) || e.toLowerCase().startsWith(\"0x\") ? e : `0x${e}`, !!/^(0x)?[0-9a-f]{40}$/i.test(n) && (!(!/^(0x|0X)?[0-9a-f]{40}$/.test(n) && !/^(0x|0X)?[0-9A-F]{40}$/.test(n)) || !r || (0, t.checkAddressCheckSum)(n));\n        };\n      },\n      6660: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isBlockNumberOrTag = t.isBlockTag = t.isBlockNumber = void 0;\n        const n = r(9970),\n          o = r(6378);\n        t.isBlockNumber = e => (0, o.isUInt)(e), t.isBlockTag = e => Object.values(n.BlockTags).includes(e), t.isBlockNumberOrTag = e => (0, t.isBlockTag)(e) || (0, t.isBlockNumber)(e);\n      },\n      5191: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isContractAddressInBloom = t.isUserEthereumAddressInBloom = t.isInBloom = t.isBloom = void 0;\n        const n = r(4488),\n          o = r(8171),\n          i = r(2681),\n          s = r(7420);\n        t.isBloom = e => !(\"string\" != typeof e || !/^(0x)?[0-9a-f]{512}$/i.test(e) || !/^(0x)?[0-9a-f]{512}$/.test(e) && !/^(0x)?[0-9A-F]{512}$/.test(e)), t.isInBloom = (e, r) => {\n          if (\"string\" == typeof r && !(0, s.isHexStrict)(r)) return !1;\n          if (!(0, t.isBloom)(e)) return !1;\n          const i = \"string\" == typeof r ? (0, o.hexToUint8Array)(r) : r,\n            a = (0, o.uint8ArrayToHexString)((0, n.keccak256)(i)).slice(2);\n          for (let t = 0; t < 12; t += 4) {\n            const r = (parseInt(a.slice(t, t + 2), 16) << 8) + parseInt(a.slice(t + 2, t + 4), 16) & 2047,\n              n = 1 << r % 4;\n            if (((0, o.codePointToInt)(e.charCodeAt(e.length - 1 - Math.floor(r / 4))) & n) !== n) return !1;\n          }\n          return !0;\n        }, t.isUserEthereumAddressInBloom = (e, r) => {\n          if (!(0, t.isBloom)(e)) return !1;\n          if (!(0, i.isAddress)(r)) return !1;\n          const n = (0, o.padLeft)(r, 64);\n          return (0, t.isInBloom)(e, n);\n        }, t.isContractAddressInBloom = (e, r) => !!(0, t.isBloom)(e) && !!(0, i.isAddress)(r) && (0, t.isInBloom)(e, r);\n      },\n      4416: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isBoolean = void 0;\n        const n = r(7420);\n        t.isBoolean = e => !![\"number\", \"string\", \"boolean\"].includes(typeof e) && (\"boolean\" == typeof e || (\"string\" != typeof e || (0, n.isHexStrict)(e) ? \"string\" == typeof e && (0, n.isHexStrict)(e) ? \"0x1\" === e || \"0x0\" === e : 1 === e || 0 === e : \"1\" === e || \"0\" === e));\n      },\n      3921: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isBytes = t.isUint8Array = void 0;\n        const n = r(8171),\n          o = r(7420);\n        t.isUint8Array = e => {\n          var t, r;\n          return e instanceof Uint8Array || \"Uint8Array\" === (null === (t = null == e ? void 0 : e.constructor) || void 0 === t ? void 0 : t.name) || \"Buffer\" === (null === (r = null == e ? void 0 : e.constructor) || void 0 === r ? void 0 : r.name);\n        }, t.isBytes = (e, r = {\n          abiType: \"bytes\"\n        }) => {\n          if (\"string\" != typeof e && !Array.isArray(e) && !(0, t.isUint8Array)(e)) return !1;\n          if (\"string\" == typeof e && (0, o.isHexStrict)(e) && e.startsWith(\"-\")) return !1;\n          if (\"string\" == typeof e && !(0, o.isHexStrict)(e)) return !1;\n          let i;\n          if (\"string\" == typeof e) {\n            if (e.length % 2 != 0) return !1;\n            i = (0, n.hexToUint8Array)(e);\n          } else if (Array.isArray(e)) {\n            if (e.some(e => e < 0 || e > 255 || !Number.isInteger(e))) return !1;\n            i = new Uint8Array(e);\n          } else i = e;\n          if (null == r ? void 0 : r.abiType) {\n            const {\n              baseTypeSize: e\n            } = (0, n.parseBaseType)(r.abiType);\n            return !e || i.length === e;\n          }\n          return !(null == r ? void 0 : r.size) || i.length === (null == r ? void 0 : r.size);\n        };\n      },\n      1478: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isValidEthBaseType = void 0;\n        const n = r(8171);\n        t.isValidEthBaseType = e => {\n          const {\n            baseType: t,\n            baseTypeSize: r\n          } = (0, n.parseBaseType)(e);\n          return !!t && (t === e || (\"int\" !== t && \"uint\" !== t || !r || r <= 256 && r % 8 == 0) && (\"bytes\" !== t || !r || r >= 1 && r <= 32));\n        };\n      },\n      5164: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isFilterObject = void 0;\n        const n = r(2681),\n          o = r(6660),\n          i = r(2102),\n          s = r(5702);\n        t.isFilterObject = e => {\n          const t = [\"fromBlock\", \"toBlock\", \"address\", \"topics\", \"blockHash\"];\n          if ((0, i.isNullish)(e) || \"object\" != typeof e) return !1;\n          if (!Object.keys(e).every(e => t.includes(e))) return !1;\n          if (!(0, i.isNullish)(e.fromBlock) && !(0, o.isBlockNumberOrTag)(e.fromBlock) || !(0, i.isNullish)(e.toBlock) && !(0, o.isBlockNumberOrTag)(e.toBlock)) return !1;\n          if (!(0, i.isNullish)(e.address)) if (Array.isArray(e.address)) {\n            if (!e.address.every(e => (0, n.isAddress)(e))) return !1;\n          } else if (!(0, n.isAddress)(e.address)) return !1;\n          return !(!(0, i.isNullish)(e.topics) && !e.topics.every(e => !!(0, i.isNullish)(e) || (Array.isArray(e) ? e.every(e => (0, s.isTopic)(e)) : !!(0, s.isTopic)(e))));\n        };\n      },\n      1851: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var o = Object.getOwnPropertyDescriptor(t, r);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, o);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), o(r(2681), t), o(r(6660), t), o(r(5191), t), o(r(4416), t), o(r(3921), t), o(r(1478), t), o(r(5164), t), o(r(6378), t), o(r(7420), t), o(r(5702), t), o(r(2102), t);\n      },\n      6378: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isNumber = t.isInt = t.isUInt = t.bigintPower = t.isBigInt = void 0;\n        const n = r(8171),\n          o = r(7420);\n        t.isBigInt = e => \"bigint\" == typeof e, t.bigintPower = (e, t) => {\n          if (t === BigInt(0)) return BigInt(1);\n          let r = e;\n          for (let n = 1; n < t; n += 1) r *= e;\n          return r;\n        }, t.isUInt = (e, r = {\n          abiType: \"uint\"\n        }) => {\n          if (![\"number\", \"string\", \"bigint\"].includes(typeof e) || \"string\" == typeof e && 0 === e.length) return !1;\n          let i;\n          if (null == r ? void 0 : r.abiType) {\n            const {\n              baseTypeSize: e\n            } = (0, n.parseBaseType)(r.abiType);\n            e && (i = e);\n          } else r.bitSize && (i = r.bitSize);\n          const s = (0, t.bigintPower)(BigInt(2), BigInt(null != i ? i : 256)) - BigInt(1);\n          try {\n            const t = \"string\" == typeof e && (0, o.isHexStrict)(e) ? BigInt((0, n.hexToNumber)(e)) : BigInt(e);\n            return t >= 0 && t <= s;\n          } catch (e) {\n            return !1;\n          }\n        }, t.isInt = (e, r = {\n          abiType: \"int\"\n        }) => {\n          if (![\"number\", \"string\", \"bigint\"].includes(typeof e)) return !1;\n          if (\"number\" == typeof e && e > Number.MAX_SAFE_INTEGER) return !1;\n          let i;\n          if (null == r ? void 0 : r.abiType) {\n            const {\n              baseTypeSize: e,\n              baseType: t\n            } = (0, n.parseBaseType)(r.abiType);\n            if (\"int\" !== t) return !1;\n            e && (i = e);\n          } else r.bitSize && (i = r.bitSize);\n          const s = (0, t.bigintPower)(BigInt(2), BigInt((null != i ? i : 256) - 1)),\n            a = BigInt(-1) * (0, t.bigintPower)(BigInt(2), BigInt((null != i ? i : 256) - 1));\n          try {\n            const t = \"string\" == typeof e && (0, o.isHexStrict)(e) ? BigInt((0, n.hexToNumber)(e)) : BigInt(e);\n            return t >= a && t <= s;\n          } catch (e) {\n            return !1;\n          }\n        }, t.isNumber = e => !!(0, t.isInt)(e) || !(\"string\" != typeof e || !/[0-9.]/.test(e) || e.indexOf(\".\") !== e.lastIndexOf(\".\")) || \"number\" == typeof e;\n      },\n      2102: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isObject = t.isNullish = void 0;\n        const n = r(9970);\n        t.isNullish = e => null == e, t.isObject = e => !(\"object\" != typeof e || (0, t.isNullish)(e) || Array.isArray(e) || e instanceof n.TypedArray);\n      },\n      7420: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.validateNoLeadingZeroes = t.isHexPrefixed = t.isHexString32Bytes = t.isHexString8Bytes = t.isHex = t.isHexString = t.isHexStrict = t.isString = void 0, t.isString = e => \"string\" == typeof e, t.isHexStrict = e => \"string\" == typeof e && /^((-)?0x[0-9a-f]+|(0x))$/i.test(e), t.isHexString = function (e, t) {\n          return !(\"string\" != typeof e || !e.match(/^0x[0-9A-Fa-f]*$/) || void 0 !== t && t > 0 && e.length !== 2 + 2 * t);\n        }, t.isHex = e => \"number\" == typeof e || \"bigint\" == typeof e || \"string\" == typeof e && /^((-0x|0x|-)?[0-9a-f]+|(0x))$/i.test(e), t.isHexString8Bytes = (e, r = !0) => r ? (0, t.isHexStrict)(e) && 18 === e.length : (0, t.isHex)(e) && 16 === e.length, t.isHexString32Bytes = (e, r = !0) => r ? (0, t.isHexStrict)(e) && 66 === e.length : (0, t.isHex)(e) && 64 === e.length, t.isHexPrefixed = function (e) {\n          if (\"string\" != typeof e) throw new Error(\"[isHexPrefixed] input must be type 'string', received type \" + typeof e);\n          return e.startsWith(\"0x\");\n        }, t.validateNoLeadingZeroes = function (e) {\n          for (const [t, r] of Object.entries(e)) if (void 0 !== r && r.length > 0 && 0 === r[0]) throw new Error(`${t} cannot have leading zeroes, received: ${r.toString()}`);\n        };\n      },\n      5702: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isTopicInBloom = t.isTopic = void 0;\n        const n = r(5191);\n        t.isTopic = e => !(\"string\" != typeof e || !/^(0x)?[0-9a-f]{64}$/i.test(e) || !/^(0x)?[0-9a-f]{64}$/.test(e) && !/^(0x)?[0-9A-F]{64}$/.test(e)), t.isTopicInBloom = (e, r) => !!(0, n.isBloom)(e) && !!(0, t.isTopic)(r) && (0, n.isInBloom)(e, r);\n      },\n      1714: function (e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Validator = void 0;\n        const o = r(5071),\n          i = r(6750),\n          s = r(356),\n          a = n(r(2677)),\n          c = e => {\n            if ((!(null == e ? void 0 : e.type) || \"object\" === (null == e ? void 0 : e.type)) && (null == e ? void 0 : e.properties)) {\n              const t = {};\n              for (const r of Object.keys(e.properties)) {\n                const n = c(e.properties[r]);\n                n && (t[r] = n);\n              }\n              return Array.isArray(e.required) ? i.z.object(t).partial().required(e.required.reduce((e, t) => Object.assign(Object.assign({}, e), {\n                [t]: !0\n              }), {})) : i.z.object(t).partial();\n            }\n            if (\"array\" === (null == e ? void 0 : e.type) && (null == e ? void 0 : e.items)) {\n              if (Array.isArray(e.items) && e.items.length > 1 && void 0 !== e.maxItems && new Set(e.items.map(e => e.$id)).size === e.items.length) {\n                const t = [];\n                for (const r of e.items) {\n                  const e = c(r);\n                  e && t.push(e);\n                }\n                return i.z.tuple(t);\n              }\n              const t = Array.isArray(e.items) ? e.items[0] : e.items;\n              let r = i.z.array(c(t));\n              return r = void 0 !== e.minItems ? r.min(e.minItems) : r, r = void 0 !== e.maxItems ? r.max(e.maxItems) : r, r;\n            }\n            if (e.oneOf && Array.isArray(e.oneOf)) return i.z.union(e.oneOf.map(e => c(e)));\n            if (null == e ? void 0 : e.format) {\n              if (!a.default[e.format]) throw new o.SchemaFormatError(e.format);\n              return i.z.any().refine(a.default[e.format], t => ({\n                params: {\n                  value: t,\n                  format: e.format\n                }\n              }));\n            }\n            return (null == e ? void 0 : e.type) && \"object\" !== (null == e ? void 0 : e.type) && \"function\" == typeof i.z[String(e.type)] ? i.z[String(e.type)]() : i.z.object({\n              data: i.z.any()\n            }).partial();\n          };\n        class u {\n          static factory() {\n            return u.validatorInstance || (u.validatorInstance = new u()), u.validatorInstance;\n          }\n          validate(e, t, r) {\n            var n, o;\n            const i = c(e).safeParse(t);\n            if (!i.success) {\n              const e = this.convertErrors(null !== (o = null === (n = i.error) || void 0 === n ? void 0 : n.issues) && void 0 !== o ? o : []);\n              if (e) {\n                if (null == r ? void 0 : r.silent) return e;\n                throw new s.Web3ValidatorError(e);\n              }\n            }\n          }\n          convertErrors(e) {\n            if (e && Array.isArray(e) && e.length > 0) return e.map(e => {\n              var t;\n              let r, n, o, s;\n              s = e.path.join(\"/\");\n              const a = String(e.path[e.path.length - 1]),\n                c = e.path.join(\"/\");\n              if (e.code === i.ZodIssueCode.too_big) n = \"maxItems\", s = `${c}/maxItems`, o = {\n                limit: e.maximum\n              }, r = `must NOT have more than ${e.maximum} items`;else if (e.code === i.ZodIssueCode.too_small) n = \"minItems\", s = `${c}/minItems`, o = {\n                limit: e.minimum\n              }, r = `must NOT have fewer than ${e.minimum} items`;else if (e.code === i.ZodIssueCode.custom) {\n                const {\n                  value: n,\n                  format: i\n                } = null !== (t = e.params) && void 0 !== t ? t : {};\n                r = void 0 === n ? `value at \"/${s}\" is required` : `value \"${\"object\" == typeof n ? JSON.stringify(n) : n}\" at \"/${s}\" must pass \"${i}\" validation`, o = {\n                  value: n\n                };\n              }\n              return {\n                keyword: null != n ? n : a,\n                instancePath: c ? `/${c}` : \"\",\n                schemaPath: s ? `#${s}` : \"#\",\n                params: null != o ? o : {\n                  value: e.message\n                },\n                message: null != r ? r : e.message\n              };\n            });\n          }\n        }\n        t.Validator = u;\n      },\n      7985: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3Validator = void 0;\n        const n = r(1714),\n          o = r(8171),\n          i = r(356);\n        t.Web3Validator = class {\n          constructor() {\n            this._validator = n.Validator.factory();\n          }\n          validateJSONSchema(e, t, r) {\n            return this._validator.validate(e, t, r);\n          }\n          validate(e, t, r = {\n            silent: !1\n          }) {\n            var n, s;\n            const a = (0, o.ethAbiToJsonSchema)(e);\n            if (!Array.isArray(a.items) || 0 !== (null === (n = a.items) || void 0 === n ? void 0 : n.length) || 0 !== t.length) {\n              if (Array.isArray(a.items) && 0 === (null === (s = a.items) || void 0 === s ? void 0 : s.length) && 0 !== t.length) throw new i.Web3ValidatorError([{\n                instancePath: \"/0\",\n                schemaPath: \"/\",\n                keyword: \"required\",\n                message: \"empty schema against data can not be validated\",\n                params: t\n              }]);\n              return this._validator.validate(a, t, r);\n            }\n          }\n        };\n      },\n      1655: (e, t, r) => {\n        \"use strict\";\n\n        function n(e, t) {\n          return e.exec(t)?.groups;\n        }\n        r.r(t), r.d(t, {\n          BaseError: () => u,\n          narrow: () => d,\n          parseAbi: () => M,\n          parseAbiItem: () => L,\n          parseAbiParameter: () => D,\n          parseAbiParameters: () => F\n        });\n        var o = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,\n          i = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,\n          s = /^\\(.+?\\).*?$/,\n          a = Object.defineProperty,\n          c = (e, t, r) => (((e, t, r) => {\n            t in e ? a(e, t, {\n              enumerable: !0,\n              configurable: !0,\n              writable: !0,\n              value: r\n            }) : e[t] = r;\n          })(e, \"symbol\" != typeof t ? t + \"\" : t, r), r),\n          u = class extends Error {\n            constructor(e, t = {}) {\n              const r = t.cause instanceof u ? t.cause.details : t.cause?.message ? t.cause.message : t.details,\n                n = t.cause instanceof u && t.cause.docsPath || t.docsPath;\n              super([e || \"An error occurred.\", \"\", ...(t.metaMessages ? [...t.metaMessages, \"\"] : []), ...(n ? [`Docs: https://abitype.dev${n}`] : []), ...(r ? [`Details: ${r}`] : []), \"Version: abitype@0.7.1\"].join(\"\\n\")), c(this, \"details\"), c(this, \"docsPath\"), c(this, \"metaMessages\"), c(this, \"shortMessage\"), c(this, \"name\", \"AbiTypeError\"), t.cause && (this.cause = t.cause), this.details = r, this.docsPath = n, this.metaMessages = t.metaMessages, this.shortMessage = e;\n            }\n          };\n        function d(e) {\n          return e;\n        }\n        var l = /^error (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)$/,\n          h = /^event (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)$/,\n          f = /^function (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns \\((?<returns>.*?)\\))?$/,\n          p = /^struct (?<name>[a-zA-Z0-9_]+) \\{(?<properties>.*?)\\}$/;\n        function m(e) {\n          return p.test(e);\n        }\n        function g(e) {\n          return n(p, e);\n        }\n        var y = /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/,\n          v = /^fallback\\(\\)$/,\n          b = /^receive\\(\\) external payable$/,\n          E = new Set([\"memory\", \"indexed\", \"storage\", \"calldata\"]),\n          _ = new Set([\"indexed\"]),\n          A = new Set([\"calldata\", \"memory\", \"storage\"]),\n          T = new Map([[\"address\", {\n            type: \"address\"\n          }], [\"bool\", {\n            type: \"bool\"\n          }], [\"bytes\", {\n            type: \"bytes\"\n          }], [\"bytes32\", {\n            type: \"bytes32\"\n          }], [\"int\", {\n            type: \"int256\"\n          }], [\"int256\", {\n            type: \"int256\"\n          }], [\"string\", {\n            type: \"string\"\n          }], [\"uint\", {\n            type: \"uint256\"\n          }], [\"uint8\", {\n            type: \"uint8\"\n          }], [\"uint16\", {\n            type: \"uint16\"\n          }], [\"uint24\", {\n            type: \"uint24\"\n          }], [\"uint32\", {\n            type: \"uint32\"\n          }], [\"uint64\", {\n            type: \"uint64\"\n          }], [\"uint96\", {\n            type: \"uint96\"\n          }], [\"uint112\", {\n            type: \"uint112\"\n          }], [\"uint160\", {\n            type: \"uint160\"\n          }], [\"uint192\", {\n            type: \"uint192\"\n          }], [\"uint256\", {\n            type: \"uint256\"\n          }], [\"address owner\", {\n            type: \"address\",\n            name: \"owner\"\n          }], [\"address to\", {\n            type: \"address\",\n            name: \"to\"\n          }], [\"bool approved\", {\n            type: \"bool\",\n            name: \"approved\"\n          }], [\"bytes _data\", {\n            type: \"bytes\",\n            name: \"_data\"\n          }], [\"bytes data\", {\n            type: \"bytes\",\n            name: \"data\"\n          }], [\"bytes signature\", {\n            type: \"bytes\",\n            name: \"signature\"\n          }], [\"bytes32 hash\", {\n            type: \"bytes32\",\n            name: \"hash\"\n          }], [\"bytes32 r\", {\n            type: \"bytes32\",\n            name: \"r\"\n          }], [\"bytes32 root\", {\n            type: \"bytes32\",\n            name: \"root\"\n          }], [\"bytes32 s\", {\n            type: \"bytes32\",\n            name: \"s\"\n          }], [\"string name\", {\n            type: \"string\",\n            name: \"name\"\n          }], [\"string symbol\", {\n            type: \"string\",\n            name: \"symbol\"\n          }], [\"string tokenURI\", {\n            type: \"string\",\n            name: \"tokenURI\"\n          }], [\"uint tokenId\", {\n            type: \"uint256\",\n            name: \"tokenId\"\n          }], [\"uint8 v\", {\n            type: \"uint8\",\n            name: \"v\"\n          }], [\"uint256 balance\", {\n            type: \"uint256\",\n            name: \"balance\"\n          }], [\"uint256 tokenId\", {\n            type: \"uint256\",\n            name: \"tokenId\"\n          }], [\"uint256 value\", {\n            type: \"uint256\",\n            name: \"value\"\n          }], [\"event:address indexed from\", {\n            type: \"address\",\n            name: \"from\",\n            indexed: !0\n          }], [\"event:address indexed to\", {\n            type: \"address\",\n            name: \"to\",\n            indexed: !0\n          }], [\"event:uint indexed tokenId\", {\n            type: \"uint256\",\n            name: \"tokenId\",\n            indexed: !0\n          }], [\"event:uint256 indexed tokenId\", {\n            type: \"uint256\",\n            name: \"tokenId\",\n            indexed: !0\n          }]]);\n        function w(e, t = {}) {\n          if (function (e) {\n            return f.test(e);\n          }(e)) {\n            const r = function (e) {\n              return n(f, e);\n            }(e);\n            if (!r) throw new u(\"Invalid function signature.\", {\n              details: e\n            });\n            const o = O(r.parameters),\n              i = [],\n              s = o.length;\n            for (let e = 0; e < s; e++) i.push(x(o[e], {\n              modifiers: A,\n              structs: t,\n              type: \"function\"\n            }));\n            const a = [];\n            if (r.returns) {\n              const e = O(r.returns),\n                n = e.length;\n              for (let r = 0; r < n; r++) a.push(x(e[r], {\n                modifiers: A,\n                structs: t,\n                type: \"function\"\n              }));\n            }\n            return {\n              name: r.name,\n              type: \"function\",\n              stateMutability: r.stateMutability ?? \"nonpayable\",\n              inputs: i,\n              outputs: a\n            };\n          }\n          if (function (e) {\n            return h.test(e);\n          }(e)) {\n            const r = function (e) {\n              return n(h, e);\n            }(e);\n            if (!r) throw new u(\"Invalid event signature.\", {\n              details: e\n            });\n            const o = O(r.parameters),\n              i = [],\n              s = o.length;\n            for (let e = 0; e < s; e++) i.push(x(o[e], {\n              modifiers: _,\n              structs: t,\n              type: \"event\"\n            }));\n            return {\n              name: r.name,\n              type: \"event\",\n              inputs: i\n            };\n          }\n          if (function (e) {\n            return l.test(e);\n          }(e)) {\n            const r = function (e) {\n              return n(l, e);\n            }(e);\n            if (!r) throw new u(\"Invalid error signature.\", {\n              details: e\n            });\n            const o = O(r.parameters),\n              i = [],\n              s = o.length;\n            for (let e = 0; e < s; e++) i.push(x(o[e], {\n              structs: t,\n              type: \"error\"\n            }));\n            return {\n              name: r.name,\n              type: \"error\",\n              inputs: i\n            };\n          }\n          if (function (e) {\n            return y.test(e);\n          }(e)) {\n            const r = function (e) {\n              return n(y, e);\n            }(e);\n            if (!r) throw new u(\"Invalid constructor signature.\", {\n              details: e\n            });\n            const o = O(r.parameters),\n              i = [],\n              s = o.length;\n            for (let e = 0; e < s; e++) i.push(x(o[e], {\n              structs: t,\n              type: \"constructor\"\n            }));\n            return {\n              type: \"constructor\",\n              stateMutability: r.stateMutability ?? \"nonpayable\",\n              inputs: i\n            };\n          }\n          if (function (e) {\n            return v.test(e);\n          }(e)) return {\n            type: \"fallback\"\n          };\n          if (function (e) {\n            return b.test(e);\n          }(e)) return {\n            type: \"receive\",\n            stateMutability: \"payable\"\n          };\n          throw new u(\"Unknown signature.\", {\n            details: e\n          });\n        }\n        var I = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z0-9_]+))?$/,\n          R = /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z0-9_]+))?$/,\n          P = /^u?int$/;\n        function x(e, t) {\n          const r = function (e, t) {\n            return t ? `${t}:${e}` : e;\n          }(e, t?.type);\n          if (T.has(r)) return T.get(r);\n          const a = s.test(e),\n            c = n(a ? R : I, e);\n          if (!c) throw new u(\"Invalid ABI parameter.\", {\n            details: e\n          });\n          if (c.name && function (e) {\n            return \"address\" === e || \"bool\" === e || \"function\" === e || \"string\" === e || \"tuple\" === e || o.test(e) || i.test(e) || C.test(e);\n          }(c.name)) throw new u(\"Invalid ABI parameter.\", {\n            details: e,\n            metaMessages: [`\"${c.name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`]\n          });\n          const d = c.name ? {\n              name: c.name\n            } : {},\n            l = \"indexed\" === c.modifier ? {\n              indexed: !0\n            } : {},\n            h = t?.structs ?? {};\n          let f,\n            p = {};\n          if (a) {\n            f = \"tuple\";\n            const e = O(c.type),\n              t = [],\n              r = e.length;\n            for (let n = 0; n < r; n++) t.push(x(e[n], {\n              structs: h\n            }));\n            p = {\n              components: t\n            };\n          } else if (c.type in h) f = \"tuple\", p = {\n            components: h[c.type]\n          };else if (P.test(c.type)) f = `${c.type}256`;else if (f = c.type, \"struct\" !== t?.type && !S(f)) throw new u(\"Unknown type.\", {\n            metaMessages: [`Type \"${f}\" is not a valid ABI type.`]\n          });\n          if (c.modifier) {\n            if (!t?.modifiers?.has?.(c.modifier)) throw new u(\"Invalid ABI parameter.\", {\n              details: e,\n              metaMessages: [`Modifier \"${c.modifier}\" not allowed${t?.type ? ` in \"${t.type}\" type` : \"\"}.`]\n            });\n            if (A.has(c.modifier) && !function (e, t) {\n              return t || \"bytes\" === e || \"string\" === e || \"tuple\" === e;\n            }(f, !!c.array)) throw new u(\"Invalid ABI parameter.\", {\n              details: e,\n              metaMessages: [`Modifier \"${c.modifier}\" not allowed${t?.type ? ` in \"${t.type}\" type` : \"\"}.`, `Data location can only be specified for array, struct, or mapping types, but \"${c.modifier}\" was given.`]\n            });\n          }\n          const m = {\n            type: `${f}${c.array ?? \"\"}`,\n            ...d,\n            ...l,\n            ...p\n          };\n          return T.set(r, m), m;\n        }\n        function O(e, t = [], r = \"\", n = 0) {\n          if (\"\" === e) {\n            if (\"\" === r) return t;\n            if (0 !== n) throw new u(\"Unbalanced parentheses.\", {\n              metaMessages: [`\"${r.trim()}\" has too many ${n > 0 ? \"opening\" : \"closing\"} parentheses.`],\n              details: `Depth \"${n}\"`\n            });\n            return [...t, r.trim()];\n          }\n          const o = e.length;\n          for (let i = 0; i < o; i++) {\n            const o = e[i],\n              s = e.slice(i + 1);\n            switch (o) {\n              case \",\":\n                return 0 === n ? O(s, [...t, r.trim()]) : O(s, t, `${r}${o}`, n);\n              case \"(\":\n                return O(s, t, `${r}${o}`, n + 1);\n              case \")\":\n                return O(s, t, `${r}${o}`, n - 1);\n              default:\n                return O(s, t, `${r}${o}`, n);\n            }\n          }\n          return [];\n        }\n        function S(e) {\n          return \"address\" === e || \"bool\" === e || \"function\" === e || \"string\" === e || o.test(e) || i.test(e);\n        }\n        var C = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\n        function B(e) {\n          const t = {},\n            r = e.length;\n          for (let n = 0; n < r; n++) {\n            const r = e[n];\n            if (!m(r)) continue;\n            const o = g(r);\n            if (!o) throw new u(\"Invalid struct signature.\", {\n              details: r\n            });\n            const i = o.properties.split(\";\"),\n              s = [],\n              a = i.length;\n            for (let e = 0; e < a; e++) {\n              const t = i[e].trim();\n              if (!t) continue;\n              const r = x(t, {\n                type: \"struct\"\n              });\n              s.push(r);\n            }\n            if (!s.length) throw new u(\"Invalid struct signature.\", {\n              details: r,\n              metaMessages: [\"No properties exist.\"]\n            });\n            t[o.name] = s;\n          }\n          const n = {},\n            o = Object.entries(t),\n            i = o.length;\n          for (let e = 0; e < i; e++) {\n            const [r, i] = o[e];\n            n[r] = N(i, t);\n          }\n          return n;\n        }\n        var k = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\\[\\d*?\\])+?)?$/;\n        function N(e, t, r = new Set()) {\n          const o = [],\n            i = e.length;\n          for (let a = 0; a < i; a++) {\n            const i = e[a];\n            if (s.test(i.type)) o.push(i);else {\n              const e = n(k, i.type);\n              if (!e?.type) throw new u(\"Invalid ABI parameter.\", {\n                details: JSON.stringify(i, null, 2),\n                metaMessages: [\"ABI parameter type is invalid.\"]\n              });\n              const {\n                array: s,\n                type: a\n              } = e;\n              if (a in t) {\n                if (r.has(a)) throw new u(\"Circular reference detected.\", {\n                  metaMessages: [`Struct \"${a}\" is a circular reference.`]\n                });\n                o.push({\n                  ...i,\n                  type: `tuple${s ?? \"\"}`,\n                  components: N(t[a] ?? [], t, new Set([...r, a]))\n                });\n              } else {\n                if (!S(a)) throw new u(\"Unknown type.\", {\n                  metaMessages: [`Type \"${a}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`]\n                });\n                o.push(i);\n              }\n            }\n          }\n          return o;\n        }\n        function M(e) {\n          const t = B(e),\n            r = [],\n            n = e.length;\n          for (let o = 0; o < n; o++) {\n            const n = e[o];\n            m(n) || r.push(w(n, t));\n          }\n          return r;\n        }\n        function L(e) {\n          let t;\n          if (\"string\" == typeof e) t = w(e);else {\n            const r = B(e),\n              n = e.length;\n            for (let o = 0; o < n; o++) {\n              const n = e[o];\n              if (!m(n)) {\n                t = w(n, r);\n                break;\n              }\n            }\n          }\n          if (!t) throw new u(\"Failed to parse ABI item.\", {\n            details: `parseAbiItem(${JSON.stringify(e, null, 2)})`,\n            docsPath: \"/api/human.html#parseabiitem-1\"\n          });\n          return t;\n        }\n        function D(e) {\n          let t;\n          if (\"string\" == typeof e) t = x(e, {\n            modifiers: E\n          });else {\n            const r = B(e),\n              n = e.length;\n            for (let o = 0; o < n; o++) {\n              const n = e[o];\n              if (!m(n)) {\n                t = x(n, {\n                  modifiers: E,\n                  structs: r\n                });\n                break;\n              }\n            }\n          }\n          if (!t) throw new u(\"Failed to parse ABI parameter.\", {\n            details: `parseAbiParameter(${JSON.stringify(e, null, 2)})`,\n            docsPath: \"/api/human.html#parseabiparameter-1\"\n          });\n          return t;\n        }\n        function F(e) {\n          const t = [];\n          if (\"string\" == typeof e) {\n            const r = O(e),\n              n = r.length;\n            for (let e = 0; e < n; e++) t.push(x(r[e], {\n              modifiers: E\n            }));\n          } else {\n            const r = B(e),\n              n = e.length;\n            for (let o = 0; o < n; o++) {\n              const n = e[o];\n              if (m(n)) continue;\n              const i = O(n),\n                s = i.length;\n              for (let e = 0; e < s; e++) t.push(x(i[e], {\n                modifiers: E,\n                structs: r\n              }));\n            }\n          }\n          if (0 === t.length) throw new u(\"Failed to parse ABI parameters.\", {\n            details: `parseAbiParameters(${JSON.stringify(e, null, 2)})`,\n            docsPath: \"/api/human.html#parseabiparameters-1\"\n          });\n          return t;\n        }\n      }\n    },\n    t = {};\n  function r(n) {\n    var o = t[n];\n    if (void 0 !== o) return o.exports;\n    var i = t[n] = {\n      id: n,\n      loaded: !1,\n      exports: {}\n    };\n    return e[n].call(i.exports, i, i.exports, r), i.loaded = !0, i.exports;\n  }\n  r.d = (e, t) => {\n    for (var n in t) r.o(t, n) && !r.o(e, n) && Object.defineProperty(e, n, {\n      enumerable: !0,\n      get: t[n]\n    });\n  }, r.g = function () {\n    if (\"object\" == typeof globalThis) return globalThis;\n    try {\n      return this || new Function(\"return this\")();\n    } catch (e) {\n      if (\"object\" == typeof window) return window;\n    }\n  }(), r.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), r.r = e => {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n      value: \"Module\"\n    }), Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n  }, r.nmd = e => (e.paths = [], e.children || (e.children = []), e);\n  var n = r(9375);\n  return n.default;\n})());","map":null,"metadata":{},"sourceType":"script"}